*------------------------------------------------------------*
User:                Oscar
Date:                January 06, 2024
Time:                00:17:45
Site:                12601940
Platform:            W32_8HOME
Maintenance Release: 9.04.01M3P062415
EM Version:          14.1
* 
*------------------------------------------------------------*
* Training Log
Date:                January 06, 2024
Time:                00:17:42
*------------------------------------------------------------*
14716  proc freq data=EMWS2.TSDP_VariableSet noprint;
14717  table ROLE*LEVEL/out=WORK.TSDPMETA;
14718  run;
 
NOTE: There were 21 observations read from the data set EMWS2.TSDP_VARIABLESET.
NOTE: The data set WORK.TSDPMETA has 5 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.04 seconds
      cpu time            0.00 seconds
 
 
14719  proc print data=WORK.TSDPMETA label noobs;
14720  var ROLE LEVEL COUNT;
14721  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14722  title9 ' ';
14723  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14724  run;
 
NOTE: There were 5 observations read from the data set WORK.TSDPMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14725  title10;
 
14726  %let EMEXCEPTIONSTRING=;
15087  *------------------------------------------------------------*;
15088  * TSDP: Generation of macros and macro variables;
15089  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15090  *------------------------------------------------------------*;
 
15091  %let EMEXCEPTIONSTRING=;
15092  *------------------------------------------------------------*;
15093  * TRAIN: TSDP;
15094  *------------------------------------------------------------*;
15095  %let EM_ACTION = TRAIN;
15096  %let syscc = 0;
15097
15098  %macro EM_TSDP_MAIN;
15099
15100     filename temp catalog 'sashelp.emtsdm.tsdp_macros.source';
15101     %include temp;
15102     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
15103     %include temp;
15104     filename temp;
15105
15106     %if %upcase(&EM_ACTION) = CREATE %then %do;
15107         filename temp catalog 'sashelp.emtsdm.tsdp_create.source';
15108         %include temp;
15109         filename temp;
15110         %EM_TSDP_CREATE;
15111     %end;
15112     %else
15113     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15114          filename temp catalog 'sashelp.emtsdm.tsdp_train.source';
15115             %include temp;
15116             filename temp;
15117         %EM_TSDP_TRAIN;
15118     %end;
15119     %else
15120     %if %upcase(&EM_ACTION) = SCORE %then %do;
15121          filename temp catalog 'sashelp.emtsdm.tsdp_score.source';
15122             %include temp;
15123             filename temp;
15124         %EM_TSDP_SCORE;
15125     %end;
15126     %else
15127     %if %upcase(&EM_ACTION) = REPORT %then %do;
15128             filename temp catalog 'sashelp.emtsdm.tsdp_report.source';
15129             %include temp;
15130             filename temp;
15131          %EM_TSDP_REPORT;
15132     %end;
15133     %else
15134       %if %upcase(&EM_ACTION) = OPENTIMETABLEACTION  %then %do;
15135             filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
15136             %include temp;
15137             filename temp;
15138          %EM_TSDP_OpenTimeTable ;
15139     %end;
15140     %else
15141     %if %upcase(&EM_ACTION) = CLOSETABLEACTION  %then %do;
15142            filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
15143             %include temp;
15144             filename temp;
15145          %EM_TSDP_closeTimeTable ;
15146     %end;
15147
15148  %mend EM_TSDP_MAIN;
15149  %EM_TSDP_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_MACROS.SOURCE.
15150 +/*----------------------------------------------------------------------------------+
15151 + |
15152 + |   Title :
15153 + |   TS Data Preparation Node for Time Series Data Mining
15154 + |
15155 + |   Support : Taiyeong Lee( Taiyeong.Lee@sas.com)
15156 + |
15157 + |   Notes:
15158 + |
15159 + |----------------------------------------------------------------------------------*/
15162 +%Macro EM_TSDP_Timeseries(
15163 +    /*--- input data set and variables ----*/
15164 +    inds            = ,
15165 +    crossid         = ,
15166 +    timeid          = ,
15168 +      /*--- time ID variable ----------------*/
15169 +    interval        = ,
15170 +    accumulation    = ,
15171 +    timeidfmttype   = ,
15172 +    timeidformat    = ,
15173 +    start           = ,
15174 +    end             = ,
15175 +    seasonlength    = ,
15177 +      /*--- transformation ------------------*/
15178 +    transform       = ,
15179 +    boxcoxpara      = ,
15181 +      /*--- differencing --------------------*/
15182 +    applydif        = ,
15183 +    dif             = ,
15184 +    applysdif       = ,
15185 +    sdif            = ,
15187 +      /*--- missing intepretation------------*/
15188 +    missing         = ,
15189 +    missingconstant = ,
15190 +    zeromiss        = ,
15192 +      /*--- output data sets ----------------*/
15193 +    outds           = ,
15194 +    outsum          = ,
15195 +    outseason       =
15196 +);
15198 +/*%if &interval eq Hour or &interval eq Minute or &interval eq Second
15199 +    or &EM_PROPERTY_TIMEOFDAY eq Y or &timeidfmttype eq DATETIME   */
15200 +%if &timeidfmttype eq DATETIME
15201 +%then %do;
15202 +    %let _dtTag=DT;
15203 +%end;
15204 +%else %if &timeidfmttype eq TIME
15205 +%then %do;
15206 +    %let _dtTag=T;
15207 +%end;
15208 +%else %do;
15209 +    %let _dtTag=D;
15210 +%end;
15212 +proc sort data=&inds(keep = &crossid &timeid %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)
15213 +     out=_tmpinds;
15214 +     by &crossid &timeid;
15215 +run;
15217 +proc timeseries data=_tmpinds out=&outds
15218 +    %if "&crossid" eq " "
15219 +        %then %do; outsum=&outsum(rename=(_NAME_=_NAMEID_)) %end;
15220 +        %else %do; outsum=&outsum %end;
15221 +    %if &seasonlength gt 1
15222 +    %then %do;
15223 +        outseason = &outseason seasonality= &seasonlength
15224 +    %end;
15225 +    ;
15227 +    %if &seasonlength gt 1
15228 +    %then %do;
15229 +        season SUM MEAN MIN MAX MEDIAN;
15230 +    %end;
15232 +    %if &crossid ne  %then %do;
15233 +        by &crossid;
15234 +    %end;
15236 +    id &timeid
15237 +        interval   = &interval
15238 +        accumulate = &accumulation
15239 +        %if &missing eq CONSTANT %then %do;
15240 +            setmissing = &missingconstant
15241 +        %end;
15242 +        %else %do;
15243 +            setmissing = &missing
15244 +        %end;
15245 +        %if &zeromiss ne NONE  %then %do;
15246 +            zeromiss = &zeromiss
15247 +        %end;
15248 +        %if &start ne  %then %do;
15249 +            %let  _start = "&start" ;
15250 +            start = &_start.&_dtTag
15251 +        %end;
15252 +        %if &end ne  %then %do;
15253 +            %let  _end = "&end";
15254 +            end = &_end.&_dtTag
15255 +        %end;
15256 +    ;
15258 +    var %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /
15259 +        %if &zeromiss ne NONE  %then %do;
15260 +            zeromiss = &zeromiss
15261 +        %end;
15262 +        %if &transform ne NONE  %then %do;
15263 +            %if &transform eq BOXCOX  %then %do;
15264 +                transform = BOXCOX(&boxcoxpara)
15265 +            %end;
15266 +            %else %do;
15267 +                transform = &transform
15268 +            %end;
15269 +        %end;
15270 +        %if &applydif eq Y  %then %do;
15271 +            dif = (&dif)
15272 +        %end;
15273 +        %if &applysdif eq Y %then %do;
15274 +            sdif = (&sdif)
15275 +        %end;
15276 +    ;
15277 +run;
15278 +quit;
15280 +%mend EM_TSDP_TimeSeries;
15283 +/*-----------------------------------------------------------------
15285 +    MERGE AFTER CLUSTERING
15287 ++------------------------------------------------------------------*/
15289 +%macro EM_TSDP_MergeAfterClustering();
15291 +/*--- need to fix the code based on data Role (train or transaction) ---*/
15293 +%EM_REGISTER(KEY=CLUSTS, TYPE=DATA);
15294 +%EM_GETNAME(KEY=CLUSTS, TYPE=DATA);
15296 +%let _train = ;
15297 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15298 +%if &dsid > 0 %then %do;
15299 + %let vn_data =%sysfunc(varnum(&dsid, DATA));
15300 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
15301 +%do %while(^ %sysfunc(fetch(&dsid)));
15302 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15303 +     %if &_key eq TSDRTRAIN %then %do;
15304 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
15305 +     %end;
15306 +     %else %if &_key eq TSDCTRAIN %then %do;
15307 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
15308 +     %end;
15309 +     %else %if &_key eq TSDPTRAINDS %then %do;
15310 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
15311 +     %end;
15312 +%end;
15313 +%end;
15314 +%let dsid = %sysfunc(close(&dsid));
15316 +proc sort data =&_train out=_inds;
15317 +     by %EM_CROSSID;
15318 +run;
15319 +proc sort data=&EM_IMPORT_DATA out=_outclus(KEEP= %EM_CROSSID _SEGMENT_);
15320 +      by %EM_CROSSID;
15321 +run;
15322 +data &EM_USER_CLUSTS;
15323 +     merge _inds _outclus;
15324 +     by %EM_CROSSID;
15325 +run;
15327 +proc sort data =&EM_USER_TSIDMAP;
15328 +     by %EM_CROSSID;
15329 +run;
15331 +data &EM_USER_TSIDMAP;
15332 +     merge &EM_USER_TSIDMAP _outclus;
15333 +     by %EM_CROSSID;
15334 +run;
15336 +data &EM_USER_CLUSTS ;
15337 +    merge  &EM_USER_TSIDMAP &EM_USER_CLUSTS;
15338 +     by %EM_CROSSID;
15339 +run;
15340 +quit;
15342 +%mend EM_TSDP_MergeAfterClustering;
15344 +%macro EM_TSDP_MergeTSID(inds=, tsidds=, byvar=, outds=);
15346 +    proc sort data =&inds out=_tmp_inds;
15347 +        by &byvar;
15348 +    proc sort data=&tsidds out=_tmp_tsidds;
15349 +        by &byvar;
15350 +    run;
15351 +    %if &outds eq %then %do;
15352 +        data &inds;
15353 +    %end;
15354 +    %else %do;
15355 +        data &outds;
15356 +    %end;
15357 +            merge _tmp_tsidds _tmp_inds;
15358 +            by &byvar;
15359 +        run;
15361 +    %EM_TS_DELETE_DATA(dsname=_tmp_inds);
15362 +    %EM_TS_DELETE_DATA(dsname=_tmp_tsidds);
15364 +%mend EM_TSDP_MergeTSID;
15366 +%macro EM_TS_SummaryDS(inDS=, crossid=);
15367 +    %let j=1;
15368 +    %do %while(%scan(&crossid, &j) ne );
15369 +        %let _csvar=%scan(&crossid, &j);
15370 +        %EM_REGISTER(KEY=OUTSUM&j, TYPE=DATA);
15371 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
15372 +        %EM_TS_SummaryByCSID(inDS=&inDS, outDS=&EM_USER_OUTSUM&j,crossIDVar=&_csvar);
15373 +        %let j=%eval(&j+1);
15374 +    %end;
15375 +%mend EM_TS_SummaryDS;
15378 +%macro EM_TS_SummaryByCSID(inDS=, outDS=, RoleVar=_role_, TSVar=_varname_, crossIDVar=);
15379 +    proc sql noprint;
15380 +        create table &outDS as
15381 +            select distinct &RoleVar, &TSVar, &crossIDVAr,
15382 +                mean(mean1)  as mean      label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmean, noquote))",
15383 +                std(mean1)   as std_mean  label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smean, noquote))",
15384 +                mean(sum1)   as sum       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_msum, noquote))",
15385 +                std(sum1)    as std_sum   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_ssum, noquote))",
15386 +                mean(min1)   as min       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmin, noquote))",
15387 +                std(min1)    as std_min   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smin, noquote))",
15388 +                mean(max1)   as max       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmax, noquote))",
15389 +                std(max1)    as std_max   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smax, noquote))"
15390 +            from &inDS(rename=(mean=mean1 sum=sum1 min=min1 max=max1))
15391 +                group by &TSVar, &crossIDVar
15392 +                order by &TSVar, &crossIDVar
15393 +        ;
15394 +    quit;
15395 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
15396 +/*
15397 +       MACRO: TS Utility macros
15399 +       PURPOSE: TS Utility macros
15400 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
15402 +       HISTORY:
15403 +       NOTE:
15405 +*/
15407 +/*
15408 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
15409 +                          timeid=, timeformat=, timeinformat=);
15410 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
15412 +    %do;
15413 +    %let m_data      = &data;
15414 +    %let m_decdata   = &decdata;
15415 +    %let m_decmeta   = &decmeta;
15416 +    %let m_cmeta     = &cmeta;
15417 +    %let m_outfile   = &outfile;
15418 +    %let m_crossid   = &crossid;
15419 +    %let m_timeid    = &timeid;
15420 +    %let m_timeformat    = &timeformat;
15421 +    %let m_timeinformat    = &timeinformat;
15422 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
15423 +  %end;
15424 +%mend EM_TS_CreateTsMetaDs;
15425 +*/
15426 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
15427 +proc sql;
15428 +      create table _tmp_inds
15429 +      as select distinct &timeid from  &indata;
15430 +quit;
15431 +run;
15432 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
15433 +  id &timeid
15434 +%if &timeinterval ne %then %do;
15435 +    %if &timeformattype eq DATE %then %do;
15436 +        interval=&timeinterval
15437 +    %end;
15438 +    %else %if &timeformattype eq DATETIME  %then %do;
15439 +        %let dttimeinterval= DT&timeinterval;
15440 +         interval=&dttimeinterval
15441 +    %end;
15442 +%end;
15443 +;
15444 +run;
15446 +data &outds;
15447 +     set _tmp_tsmeta;
15448 +     format START &timeformat;
15449 +     format END &timeformat;
15450 +     length APPLY_START_END $8;
15451 +     APPLY_START_END ="No";
15452 +     FORMAT = "&timeformat";
15453 +     ROLE ="TIMEID";
15454 +     rename TIMEID = NAME;
15455 +     rename SEASONALITY= LengthOfCycle;
15456 +     rename INTERVAL = TIMEINTERVAL ;
15457 +     rename FORMAT = TIMEFORMAT;
15458 +     output;
15459 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
15460 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
15461 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
15462 +run;
15464 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
15465 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
15467 +%mend EM_TS_CreateTSMetaData;
15471 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
15473 +/* if updated = Y it will pass the TSMETA created by just the previous node */
15475 +%let _tsmetads = ;
15477 +%if &updated = Y %then %do;
15478 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
15479 +%if %sysfunc(exist(&_tsmetads)) %then %do;
15480 +%goto endline;
15481 +%end;
15482 +%end;
15484 +%if &eminfodata eq %then %do;
15485 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15486 +    data &EM_DATA_EMINFO;
15487 +         set &EM_IMPORT_DATA_EMINFO;
15488 +    run;
15489 +%end;
15490 +%else %do;
15491 +    %let dsid=%sysfunc(open(&eminfodata));
15492 +    data &EM_DATA_EMINFO;
15493 +         set &eminfodata;
15494 +    run;
15495 +%end;
15496 +%if &dsid > 0 %then %do;
15497 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
15498 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
15499 +    %do %while(^ %sysfunc(fetch(&dsid)));
15500 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15501 +         %if &_key eq TSMETA %then %do;
15502 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
15503 +         %end;
15504 +    %end;
15505 +    %let dsid = %sysfunc(close(&dsid));
15506 +%end; /* the end of %if &dsid > 0 %then %do; */
15508 +%endline:
15510 +%if &_tsmetads ne %then %do;
15511 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
15512 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
15513 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
15514 +         data &EM_USER_TSMETA;
15515 +                   set &_tsmetads;
15516 +         run;
15517 +    %end;
15518 +%end;
15520 +*proc print data=&EM_DATA_EMINFO;
15521 +*proc print data=&EM_IMPORT_DATA_EMINFO;
15522 +*run;
15523 +%MEND EM_TS_GETTSMETA;
15526 +/*
15527 +%macro EM_GETTSMETAVARS(TimeInterval=);
15528 +%global &TimeInterval;
15529 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
15530 +%if &dsid > 0 %then %do;
15531 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
15532 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
15533 +%do %while(^ %sysfunc(fetch(&dsid)));
15534 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15535 +     %if &_role eq TIMEID %then %do;
15536 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
15537 +     %end;
15538 +%end;
15539 +%let dsid = %sysfunc(close(&dsid));
15540 +%end;
15541 +%MEND EM_GETTSMETAVARS;
15542 +*/
15543 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
15544 +%global &TimeInterval;
15545 +%global &TimeId;
15546 +%global &EndTime;
15547 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
15548 +proc print data=&EM_USER_TSMETA;
15549 +run;
15550 +%if &dsid > 0 %then %do;
15551 +%if &TimeInterval ne %then %do;
15552 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
15553 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15554 +    %do %while(^ %sysfunc(fetch(&dsid)));
15555 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15556 +        %if &_role eq TIMEID %then %do;
15557 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
15558 +        %end;
15559 +     %end;
15560 +%end;
15561 +%if &TimeId ne %then %do;
15562 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
15563 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15564 +    %do %while(^ %sysfunc(fetch(&dsid)));
15565 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15566 +        %if &_role eq TIMEID %then %do;
15567 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
15568 +        %end;
15569 +    %end;
15570 +%end;
15572 +%if &EndTime ne %then %do;
15573 +    %let vn_end =%sysfunc(varnum(&dsid, END));
15574 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15575 +    %do %while(^ %sysfunc(fetch(&dsid)));
15576 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15577 +        %if &_role eq TIMEID %then %do;
15578 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
15579 +        %end;
15580 +     %end;
15581 +%end;
15582 +%let dsid = %sysfunc(close(&dsid));
15583 +%end;
15584 +%MEND EM_TS_GETTSMETAVARS;
15588 +/*------------------------------------------------------------------
15590 +      Macro EM_GETTSIDMAP
15592 +------------------------------------------------------------------+*/
15595 +%macro EM_TS_GETTSIDMAP(updated=);
15597 +%let _tsidmap = ;
15599 +%if &updated = Y %then %do;
15600 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
15601 +%if %sysfunc(exist(&_tsidmap)) %then %do;
15602 +%goto endline;
15603 +%end;
15604 +%end;
15606 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15607 +%if &dsid > 0 %then %do;
15608 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
15609 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
15610 +%do %while(^ %sysfunc(fetch(&dsid)));
15611 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15612 +     %if &_key eq TSIDMAP %then %do;
15613 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
15614 +     %end;
15615 +%end;
15617 +%let dsid = %sysfunc(close(&dsid));
15618 +%end;
15620 +%endline:
15622 +%if &_tsidmap ne %then %do;
15624 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
15625 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15627 +%if %sysfunc(exist(&_tsidmap)) %then %do;
15628 +         data &EM_USER_TSIDMAP;
15629 +               set &_tsidmap;
15630 +         run;
15631 +    %end;
15632 +%end;
15633 +%MEND EM_TS_GETTSIDMAP;
15635 +/*------------------------------------------------------------------*/
15640 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
15641 +%global &value;
15644 +%let dsid = %sysfunc(open(&data));
15645 +%if &dsid > 0 %then %do;
15646 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
15647 +    %if &vn_var < 1 %then %do;
15648 +        %let &value = 0;
15649 +        %let dsid = %sysfunc(close(&dsid));
15650 +        %goto endline;
15651 +    %end;
15652 +%let dsid = %sysfunc(close(&dsid));
15653 +%end;
15655 +%let _tmp=_tmpDS;
15656 +proc means data=&data &stat;
15657 +     var &var;
15658 +     output out=&_tmp;
15659 +run;
15661 +%let dsid = %sysfunc(open(&_tmp));
15662 +%if &dsid > 0 %then %do;
15663 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
15664 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
15665 +     %do %while(^%sysfunc(fetch(&dsid)));
15666 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
15667 +         %if &_stat eq &stat %then %do;
15668 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
15669 +          %end;
15670 +      %end;
15671 +%let dsid = %sysfunc(close(&dsid));
15672 +%end;
15673 +proc datasets lib=work nolist;
15674 + delete &_tmp;
15675 +run;
15676 +%endline:
15677 +%MEND EM_TS_GET_STAT;
15680 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
15681 +%global &format;
15682 +%global &informat;
15683 +%let dsid = %sysfunc(open(&data));
15684 +%if &dsid > 0 %then %do;
15685 +%let vn_var =%sysfunc(varnum(&dsid, &var));
15686 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
15687 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
15688 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
15689 +%end;
15690 +%let dsid = %sysfunc(close(&dsid));
15691 +%end;
15692 +%MEND EM_TS_GET_VAR_FORMAT;
15694 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
15695 +      %if &lib eq %then %let lib=work;
15696 +       proc datasets lib=&lib nolist;
15697 +              delete &dsname;
15698 +       run;
15699 +%Mend  EM_TS_DELETE_DATA;
15702 +%macro EM_TS_GetNObs(inds=, nobs=);
15703 +    %global &nobs;
15704 +    %let &nobs=0;
15705 +    data _null_;
15706 +        set &inds end=eof;
15707 +        if eof then call symput("&nobs", _N_);
15708 +    run;
15709 +    quit;
15711 +    /*
15712 +    %let dsid=%sysfunc(open(&outdata));
15713 +    %if dsid > 0 %then %do;
15714 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
15715 +        %let dsid = %sysfunc(close(&dsid));
15716 +     %end;
15717 +    */
15718 +%mend  EM_TS_GetNObs;
15721 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
15722 +%global &time1;
15723 +%global &time2;
15724 +%if &default = Y %then %do;
15725 +   data _null_;
15726 +        set &data end=eof;
15727 +        if _N_ = 1 then  call symput("&time1", DATE);
15728 +        if eof then call symput("&time2", DATE);
15729 +    run;%end;
15730 +%else %do;
15731 +    %let dsid = %sysfunc(open(&data));
15732 +    %if &dsid > 0 %then %do;
15733 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
15734 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
15735 +        %do %while(^%sysfunc(fetch(&dsid)));
15736 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
15737 +             %if &_index eq 1 %then %do;
15738 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
15739 +             %end;
15740 +             %if &_index eq 2 %then %do;
15741 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
15742 +             %end;
15743 +        %end;
15744 +    %let dsid = %sysfunc(close(&dsid));
15745 +    %end;
15746 +%end;
15748 +%MEND EM_TS_GET_TIME_VALUES;
15750 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
15751 +%global &exist;
15752 + %let &exist = N;
15753 +%let dsid = %sysfunc(open(&data));
15754 +%if &dsid > 0 %then %do;
15755 +%let vn_var =%sysfunc(varnum(&dsid, &var));
15756 +%if &vn_var > 0 %then %do;
15757 +    %let &exist = Y;
15758 +%end;
15759 +%let dsid = %sysfunc(close(&dsid));
15760 +%end;
15761 +%MEND EM_TS_GET_VAR_EXIST;
15764 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
15765 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
15766 +      set &intreedata;
15767 +        LENGTH NodeType $32;
15768 +      if _PARENT_ eq " " then delete;
15769 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
15770 +        else NodeType = "CLUSTER";
15771 +        LinkID = _N_;
15772 +run;
15773 +%Mend EM_TS_MakeConstellPlotData;
15778 +%macro EM_TS_CreateIDMap(
15779 +/*-------------------------------------------------------------------------*/
15780 +/*---   Written by Xiangxiang Meng                                         */
15781 +/*-------------------------------------------------------------------------*/
15782 +inDS          =,      /* imported data set in TS data mining               */
15783 +outIDMap      =,      /* output data set of TS ID map                      */
15784 +outDS         =,      /* output data set of TS and TS ID merged            */
15785 +variableSet   =,      /* EM variable set                                   */
15786 +TSIDbyCrossID =Y,
15787 +inEM          =Y
15788 +/*-------------------------------------------------------------------------*/
15789 +);
15791 +%global EM_TS_ERR;
15792 +%let EM_TS_ERR = 0;
15794 +%if &inEM eq Y %then %do;
15795 +    %let num_crossIDVar = &EM_NUM_CROSSID;
15796 +    proc sql noprint;
15797 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
15798 +    quit;
15799 +%end;
15800 +%else %do;
15801 +    proc sql noprint;
15802 +         select count(*) into :num_crossIDVar from &variableSet
15803 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15804 +         ;
15805 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
15806 +         ;
15807 +    quit;
15808 +    %let num_crossIDVar=&num_crossIDVar;
15809 +%end;
15811 +* see if _TSID_ exists;
15813 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
15814 +run;
15816 +proc sql noprint;
15817 +    select count(*) into :has_TSID
15818 +        from _emtscm_contents
15819 +        where upcase(strip(name)) eq '_TSID_'
15820 +    ;
15821 +quit;
15823 +/*-------------------------------------------------------------------------*/
15824 +* Creating TSID map..;
15825 +/*-------------------------------------------------------------------------*/
15827 +%if (&num_crossIDVar gt 0) %then %do;
15829 +    data _emtscm_tmpIDMap;
15830 +        set &variableSet;
15831 +        where  (upcase(strip(level)) eq 'INTERVAL')
15832 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
15833 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
15834 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
15835 +          );
15836 +        _emts_dummy=1;
15837 +        keep name label role _emts_dummy;
15838 +    run;
15840 +    proc sql noprint;
15841 +        * create a string of crossID variable like A,B,C,D..;
15842 +        select distinct name into :crossIDVar separated by ','
15843 +            from &variableSet
15844 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15845 +            order by name
15846 +        ;
15847 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
15848 +            from &variableSet
15849 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15850 +            order by name
15851 +        ;
15852 +        * create the TSID map data set;
15853 +        create table _emtscm_tmp1 as
15854 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
15855 +        ;
15856 +        * create a level list of cross ID variables and time series variables;
15857 +        create table &outIDMap as
15858 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
15859 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
15860 +            where a._emts_dummy eq b._emts_dummy
15861 +            order by a.name, &crossIDVar
15862 +        ;
15863 +    quit;
15865 +    %if &TSIDbyCrossID = Y %then %do;
15866 +        * create unique TSID only by Cross ID;
15867 +        data &outIDMap;
15868 +            length _TSID_ 8;
15869 +            set &outIDMap;
15870 +            by _NAMEID_;
15871 +            if first._NAMEID_
15872 +                then _TSID_=1;
15873 +                else _TSID_+1;
15874 +        run;
15875 +        %if "&outDS" ne "" %then %do;
15876 +            * merge TSID into &inDS;
15877 +            proc sql noprint;
15878 +                create table &outDS as
15879 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
15880 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
15881 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
15882 +                        where %do i = 1 %to &num_crossIDVar;
15883 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
15884 +                              %end;
15885 +                             b._TSID_ is not missing
15886 +                    order by b._TSID_, a.&timeIDVar
15887 +                ;
15888 +            quit;
15889 +        %end;
15890 +    %end;
15891 +    %else %do;
15892 +        * create unique TSID by Cross ID and _NAMEID_;
15893 +        data &outIDMap;
15894 +            length _TSID_ 8;
15895 +            set &outIDMap;
15896 +            _TSID_=_n_;
15897 +        run;
15898 +        %if "&outDS" ne "" %then %do;
15899 +            *no merge in this output;
15900 +            data &outDS;
15901 +                set &inDS;
15902 +            run;
15903 +        %end;
15904 +    %end;
15906 +    proc sort data=&outIDMap;
15907 +        by _NAMEID_ _TSID_;
15908 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
15909 +        format _TSID_ best12. _NAMEID2_ $40.;
15910 +        set &outIDMap;
15911 +        by _NAMEID_;
15912 +        if first._NAMEID_
15913 +            then _emts_ind=1;
15914 +            else _emts_ind+1;
15915 +        drop _emts_ind;
15916 +        rename _NAMEID_=_VARNAME_;
15917 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
15918 +        if _labelID_ eq ' '
15919 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
15920 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
15921 +    run;
15923 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
15925 +%end;
15926 +%else %do; /* if no crossid's the nameid needs to be created */
15928 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
15929 +        length _TSID_ 8;
15930 +        set &variableSet;
15931 +        where  (upcase(strip(level)) eq 'INTERVAL')
15932 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
15933 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
15934 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
15935 +          );
15936 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
15937 +        rename ROLE = _ROLE_;
15938 +        _NAMEID_=strip(name);
15939 +        _VARNAME_=strip(name);
15940 +        if label eq ' '
15941 +            then _LABELID_ = strip(name);
15942 +            else _LABELID_ = strip(label);
15943 +        _TSID_=_n_;
15944 +    run;
15946 +    %if "&outDS" ne "" %then %do;
15947 +        *no merge in this output;
15948 +        data &outDS;
15949 +            set &inDS;
15950 +        run;
15951 +    %end;
15952 +%end;
15954 +data &outIDMap;
15955 +    set &outIDMap;
15956 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
15957 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
15958 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
15959 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
15960 +run;
15962 +proc datasets lib=work nolist;
15963 +    delete _emtscm_:;
15964 +run; quit;
15966 +%mend EM_TS_createIDMap;
15968 +%macro EM_TS_CreateMetaData(
15969 +/*-------------------------------------------------------------------------*/
15970 +  inDS          =,      /* imported data set in TS data mining             */
15971 +  outDS         =,      /* output data set of TS metadata                  */
15972 +  variableSet   =,      /* EM variable set                                 */
15973 +  timeInterval  =,      /* time interval                                   */
15974 +  rc            =       /* return code                                     */
15975 +/*-------------------------------------------------------------------------*/
15976 +);
15978 +%if %eval(
15979 +      &EM_NUM_BINARY_INPUT   +
15980 +      &EM_NUM_ORDINAL_INPUT  +
15981 +      &EM_NUM_NOMINAL_INPUT  +
15982 +      &EM_NUM_BINARY_REJECTED   +
15983 +      &EM_NUM_ORDINAL_REJECTED  +
15984 +      &EM_NUM_NOMINAL_REJECTED  +
15985 +      &EM_NUM_ORDINAL_TARGET  +
15986 +      &EM_NUM_NOMINAL_TARGET +
15987 +      &EM_NUM_BINARY_TARGET
15988 +      ) > 0
15989 +%then %do;
15990 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
15991 +        %put &em_codebar;
15992 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
15993 +        %put &errormsg;
15994 +        %put &em_codebar;
15995 +        %goto ENDLINE;
15996 +%end;
15998 +%global EM_TS_ERR;
15999 +%let EM_TS_ERR = 0;
16001 +%if &timeInterval eq AUTO
16002 +    %then %let timeInterval  = ;
16003 +    %else %let timeInterval  = %upcase(&timeInterval);
16005 +/*-------------------------------------------------------------------------*/
16006 +* check time ID variable;
16007 +/*-------------------------------------------------------------------------*/
16009 +* number of variables in the Variableset with ROLE=TIMEID;
16010 +proc sql noprint;
16011 +    select count(*) into :num_timeID from &variableset
16012 +        where upcase(role) eq 'TIMEID';
16013 +quit;
16015 +/*-------------------------------------------------------------------------*/
16016 +* process only when there is one Time ID, otherwise exception message;
16017 +/*-------------------------------------------------------------------------*/
16019 +%if &num_timeID eq 0 %then %do;
16021 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
16022 +    %let EM_TS_ERR = 11;
16023 +    %put &em_codebar;
16024 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
16025 +    %put &errormsg;
16026 +    %put &em_codebar;
16027 +    %goto tscm_endline;
16029 +%end;
16030 +%else %if &num_timeID gt 1 %then %do;
16032 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
16033 +    %let EM_TS_ERR = 12;
16034 +    %put &em_codebar;
16035 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
16036 +    %put &errormsg;
16037 +    %put &em_codebar;
16038 +    %goto tscm_endline;
16040 +%end;
16041 +%else %do;
16042 +    *** proceed when there is one Time ID;
16044 +    data _null_;
16045 +        set &variableset(where=(upcase(role)='TIMEID'));
16046 +        call symput('timeIDFormat',     strip(format));
16047 +        call symput('timeID',           strip(upcase(name)      ));
16048 +        call symput('timeIDLevel',      strip(upcase(level))     );
16049 +        call symput('timeIDFormatType', strip(upcase(formattype)));
16050 +    run;
16052 +    *** exception message if the time ID is not an interval variable;
16053 +    %if &timeIDLevel ne INTERVAL %then %do;
16054 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
16055 +        %let EM_TS_ERR = 13;
16056 +        %put &em_codebar;
16057 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
16058 +        %put &errormsg;
16059 +        %put &em_codebar;
16060 +        %goto tscm_endline;
16061 +    %end;
16063 +    %if (&timeIDFormatType ne DATETIME) and
16064 +        (&timeIDFormatType ne DATE) and
16065 +        (&timeIDFormatType ne TIME) and
16066 +        (&timeIDFormatType ne USER)
16067 +    %then %do;
16068 +        *** sequential format-type of time ID;
16070 +        %let timeInterval = DAY;
16071 +        %let timeIDFormatType = SEQ;
16073 +        proc sql noprint;
16074 +            create table _emtscm_inds as
16075 +                 select distinct &timeID from &inDS(keep=&timeID)
16076 +                 where &timeID is not missing;
16077 +            select count(*) into :num_nonInteger from _emtscm_inds
16078 +                where &timeID ne int(&timeID);
16079 +        quit;
16081 +        %if &num_nonInteger gt 0 %then %do;
16082 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
16083 +            %let EM_TS_ERR = 14;
16084 +            %put &em_codebar;
16085 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
16086 +            %put &errormsg;
16087 +            %put &em_codebar;
16088 +            %goto tscm_endline;
16089 +        %end;
16090 +    %end;
16091 +    %else %do;
16092 +        *** date, datetime, time format-type of time ID;
16094 +        *** must have a format;
16095 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
16096 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
16097 +            %let EM_TS_ERR = 15;
16098 +            %put &em_codebar;
16099 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
16100 +            %put &errormsg;
16101 +            %put &em_codebar;
16102 +            %goto tscm_endline;
16103 +        %end;
16105 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
16106 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
16107 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
16108 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
16109 +                %let EM_TS_ERR = 16;
16110 +                %put &em_codebar;
16111 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
16112 +                %put &errormsg;
16113 +                %put &em_codebar;
16114 +                %goto tscm_endline;
16115 +            %end;
16116 +        %end;
16118 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
16119 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
16120 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
16121 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
16122 +                %let EM_TS_ERR = 17;
16123 +                %put &em_codebar;
16124 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
16125 +                %put &errormsg;
16126 +                %put &em_codebar;
16127 +                %goto tscm_endline;
16128 +            %end;
16129 +        %end;
16131 +        *** the AUTO function is currently turned off for TIME timeID variable;
16132 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
16133 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
16134 +            %let EM_TS_ERR = 18;
16135 +            %put &em_codebar;
16136 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
16137 +            %put &errormsg;
16138 +            %put &em_codebar;
16139 +            %goto tscm_endline;
16140 +        %end;
16142 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
16143 +            %then %let timeInterval =DT&timeInterval;
16145 +        proc sql noprint;
16146 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
16147 +                where &timeID is not missing;
16148 +        quit;
16149 +    %end;
16151 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
16152 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
16153 +    run;
16155 +    %let hasValidInterval = 0;
16156 +    %let hasLengthOne     = 0;
16158 +    proc sql noprint;
16159 +        create table _emtscm_label as
16160 +            select name,label
16161 +            from dictionary.columns
16162 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
16163 +        ;
16164 +        create table _emtscm_meta2 as
16165 +            select a.*, b.label
16166 +            from _emtscm_meta as a, _emtscm_label as b
16167 +            where upcase(a.timeID) eq upcase(b.name)
16168 +        ;
16169 +    quit;
16171 +    data &outDS;
16172 +        set _emtscm_meta2;
16173 +        format
16174 +            timeformat      $30.
16175 +            role            $10.
16176 +            start           &timeIDformat
16177 +            end             &timeIDformat
16178 +            apply_start_end $8.
16179 +        ;
16180 +        rename
16181 +            timeID      = name
16182 +            seasonality = lengthOfCycle
16183 +            interval    = timeinterval
16184 +        ;
16185 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
16187 +        role            = "TIMEID";
16188 +        apply_start_end = 'N';
16189 +        timeformat      = symget('timeIDformat');
16190 +        timeformattype  = symget('timeIDformatType');
16192 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
16193 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
16194 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
16195 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
16196 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
16197 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
16198 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
16199 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
16200 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
16201 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
16203 +        if timeformattype eq 'SEQ' then do;
16204 +            timeformat='BEST12.';
16205 +            seasonality=1;
16206 +        end;
16208 +        call symput('_tinterval',interval);
16210 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
16212 +        if upcase(timeformattype) eq 'DATE' and
16213 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
16214 +            then call symput('hasValidInterval',1);
16216 +        if upcase(timeformattype) eq 'DATETIME' and
16217 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
16218 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
16219 +            then call symput('hasValidInterval',1);
16221 +        if upcase(timeformattype) eq 'TIME' and
16222 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
16223 +            then call symput('hasValidInterval',1);
16225 +        if upcase(timeformattype) eq 'SEQ'
16226 +            then call symput('hasValidInterval',1);
16228 +        if upcase(timeformattype) eq 'USER'
16229 +            then call symput('hasValidInterval',1);
16231 +        if start eq end
16232 +            then call symput('hasLengthOne',1);
16233 +    run;
16235 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
16237 +    *** detect any missing time interval after running PROC TIMEID;
16238 +    %if &_tinterval eq %then %do;
16239 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
16240 +        %let EM_TS_ERR = 19;
16241 +        %put &em_codebar;
16242 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
16243 +        %put &errormsg;
16244 +        %put &em_codebar;
16245 +        %goto tscm_endline;
16246 +    %end;
16248 +    *** detect any missing time interval after running PROC TIMEID;
16249 +    %if &hasValidInterval eq 0 %then %do;
16250 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
16251 +        %let EM_TS_ERR = 20;
16252 +        %put &em_codebar;
16253 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
16254 +        %put &errormsg;
16255 +        %put &em_codebar;
16256 +        %goto tscm_endline;
16257 +    %end;
16259 +    %if &hasLengthOne eq 1 %then %do;
16260 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
16261 +        %let EM_TS_ERR = 21;
16262 +        %put &em_codebar;
16263 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
16264 +        %put &errormsg;
16265 +        %put &em_codebar;
16266 +        %goto tscm_endline;
16267 +    %end;
16269 +%end;
16271 +%tscm_endline:;
16273 +%mend EM_TS_CreateMetaData;
16276 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
16278 +data _null_;
16279 +    set &tsmeta;
16280 +    call symput('_timeidFormatType', timeformattype);
16281 +    call symput('_timeid', strip(name));
16282 +    call symput('_seqstartnum',strip(put(start,best12.)));
16283 +run;
16285 +proc contents data=&inDS noprint
16286 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
16287 +run; quit;
16289 +data _null_;
16290 +    set _emts_tmpp1;
16291 +    call symput('_timeIDlabel',label);
16292 +run;
16294 +%if &_timeidFormatType eq SEQ
16295 +%then %do;
16296 +    proc sql noprint;
16297 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
16298 +    quit;
16299 +    %let _dummystarttime=&_dummystarttime;
16301 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
16302 +        set &inDS;
16303 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
16304 +        drop &_timeid;
16305 +        label _tsdp_tmpID = "&_timeIDlabel";
16307 +    run;
16308 +%end;
16310 +%mend;
16312 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
16314 +data _null_;
16315 +    set &tsmeta;
16316 +    call symput('_timeidFormatType', timeformattype);
16317 +    call symput('_timeidFormat', timeformat);
16318 +    call symput('_timeid', strip(name));
16319 +    call symput('_timeinterval',strip(upcase(timeinterval)));
16320 +run;
16322 +/* manually change time ID format to a longer enough time format */
16323 +/* because proc timeid returns time5. for second time interval */
16324 +/* which is not long enough for transpose with time unit as seconds */
16325 +%if &_timeinterval eq SECOND
16326 +%then %do;
16327 +    %let _timeIDformat = %str(time8.);
16328 +%end;
16330 +proc contents data=&inDS noprint
16331 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
16332 +run; quit;
16334 +data _null_;
16335 +    set _emts_tmpp1;
16336 +    call symput('_timeIDlabel',label);
16337 +run;
16339 +%if &_timeidFormatType eq TIME
16340 +%then %do;
16341 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
16342 +        set &inDS;
16343 +        _tsdp_tmpID = timepart(&_timeID);
16344 +        format _tsdp_tmpID &_timeidFormat;
16345 +        label  _tsdp_tmpID = "&_timeIDlabel";
16346 +        drop &_timeid;
16347 +    run;
16348 +%end;
16350 +%mend;
16352 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
16354 + proc sql noprint;
16355 +     create table _tmptimetable as
16356 +         select distinct &timeidvar as DATE from &inDS
16357 +         where &timeIDVar is not missing
16358 +         order by &timeIDVar;
16359 + quit;
16361 +%if &compare eq Y %then %do;
16362 +    * compare with the existing time table;
16363 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
16364 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
16365 +    run;
16367 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
16369 +    %if &_diffobs > 0 %then %do; /* create it again */
16370 +        data &outDS(keep=DATE _INDEX_);
16371 +            set _tmptimetable end = _eof_;
16372 +            if _N_ = 1
16373 +                then _INDEX_ = 1;
16374 +                else _INDEX_ = 0;
16375 +            if _eof_ then _INDEX_= 2;
16376 +        run;
16377 +    %end;
16379 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
16380 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
16381 +%end;
16382 +%else %do;
16383 +    * create a new time table directly;
16384 +    data &outDS(keep=DATE _INDEX_);
16385 +        set _tmptimetable end = _eof_;
16386 +        if _N_ = 1
16387 +            then _INDEX_ = 1;
16388 +            else _INDEX_ = 0;
16389 +        if _eof_ then _INDEX_= 2;
16390 +    run;
16392 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
16393 +%end;
16395 +* assign a defult format BEST12. for sequential time ID;
16397 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
16399 +%let _nodatefmt=N;
16401 +data _null_;
16402 +    set _tmpcontents;
16403 +    where upcase(name) eq 'DATE';
16404 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
16405 +run;
16407 +%if "&_nodatefmt" eq "Y" %then %do;
16408 +    data &outDS;
16409 +        set &outDS;
16410 +        format date best12.;
16411 +    run;
16412 +%end;
16414 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
16416 +%mend;
16420 +%macro EM_TS_Transpose(
16421 +/*-------------------------------------------------------------------------*/
16422 +  inDS          =,      /* imported data set in TS data mining             */
16423 +  inIDMap       =,      /* input TS ID map                                 */
16424 +  variableSet   =,      /* variable set                                    */
16425 +  transposeBy   =,      /* byTSID or byTimeID                              */
16426 +  outDS         =,      /* output transposed data set                      */
16427 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
16428 +  inEM          =Y,
16429 +  timePrefix    =_T
16430 +/*-------------------------------------------------------------------------*/
16431 +);
16433 +%let timePrefix = &timePrefix;
16435 +%if  &EM_NUM_CROSSID > 0 %then %do;
16437 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
16438 +    set &inIDMap;
16439 +    drop _NAMEID_;
16440 +    run;
16441 +%let inIDMap=_emtstp_map0;
16443 +%end;
16445 +proc sql noprint;
16446 +    * number of TS Variables to be transposed;
16447 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
16448 +    ;
16449 +    * number of TS Variables to be transposed;
16450 +    select max(_TSID_) into :num_TSID from &inIDMap
16451 +    ;
16452 +    * name list of TS Variables;
16453 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
16454 +        from &inIDMap
16455 +        order by _NAMEID_
16456 +    ;
16457 +    * total number of time series =max(_TSID_)*&num_TSVar;
16458 +    * and the number of digits of this variable is &num_digits;
16459 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
16460 +        from &inIDMap
16461 +    ;
16462 +      * Time ID variable;
16463 +    select name into:timeIDVar from &variableset
16464 +        where upcase(role) eq 'TIMEID'
16465 +    ;
16466 +quit;
16467 +%let num_digits = &num_digits;
16468 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
16470 +/*-------------------------------------------------------------------------*/
16472 +* get number of cross IDs and also the TIME ID variable name;
16473 +%if &inEM eq Y %then %do;
16474 +    %let num_crossIDVar = &EM_NUM_CROSSID;
16475 +    %let crossIDVar     = %EM_CROSSID;
16476 +%end;
16477 +%else %do;
16478 +    proc sql noprint;
16479 +        * number of cross ID;
16480 +        select count(*) into :num_crossIDVar
16481 +            from &variableSet
16482 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16483 +        ;
16484 +        * create a string of crossID variable like A B C D..;
16485 +        select distinct name into :crossIDVar separated by ' '
16486 +            from &variableSet
16487 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16488 +            order by name
16489 +        ;
16490 +    quit;
16491 +    %let num_crossIDVar=&num_crossIDVar;
16492 +%end;
16494 +/*-------------------------------------------------------------------------*/
16496 +%if (&num_crossIDVar gt 0) %then %do;
16498 +    data _emtstp_tmpDat;
16499 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
16500 +        _NAMEID_ = cats("_TS_",_TSID_);
16501 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
16502 +    run;
16504 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
16506 +        * update the ID maps;
16507 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
16508 +            by _NAMEID_ _TSID_;
16509 +        data &outIDMap;
16510 +            set _emtstp_tmpmap;
16511 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
16512 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
16513 +        run;
16515 +        * get the names for the new variables;
16516 +        proc sql noprint;
16517 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
16518 +            ;
16519 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
16520 +            ;
16521 +        quit;
16523 +        * data must be sorted before transposed;
16524 +        proc sort data=_emtstp_tmpDat;
16525 +            by &timeIDvar;
16526 +        run;
16528 +        %do i = 1 %to &num_TSVar;
16529 +            %let i = &i;
16530 +            * transpose one cross-type time series data by TSID;
16531 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
16532 +                id _NAMEID_;
16533 +                by &timeIDVar;
16534 +                var &&&TSVar&i;
16535 +            run;
16536 +        %end;
16538 +        * merge all vertical time series, rename and label them;
16539 +        data &outDS;
16540 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
16541 +            by &timeIDVar;
16542 +            rename
16543 +                %do i = 1 %to &num_TSVar;
16544 +                    %do j = 1 %to &num_TSID;
16545 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
16546 +                        /* %put &i &j &num1 &num_TSID; */
16547 +                        _V_&i._TS_&j = &&&tsname&num1
16548 +                    %end;
16549 +                %end;
16550 +            ;
16551 +            label
16552 +                %do i = 1 %to &num_TSVar;
16553 +                    %do j = 1 %to &num_TSID;
16554 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
16555 +                        /* %put &i &j &num1 &num_TSID; */
16556 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
16557 +                    %end;
16558 +                %end;
16559 +            ;
16560 +        run;
16561 +    %end;
16562 +    %else %do;
16564 +        * update the ID maps;
16565 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
16566 +            by _NAMEID_ _TSID_;
16567 +        data &outIDMap;
16568 +            set _emtstp_tmpmap;
16569 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
16570 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
16571 +        run;
16573 +        proc sql noprint;
16574 +            * get the roles for the new variables;
16575 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
16576 +                from &inIDMap
16577 +                order by _NAMEID_
16578 +            ;
16579 +            * get the length of the time series;
16580 +            select count(distinct &timeIDvar) into :num_T
16581 +                from _emtstp_tmpDat
16582 +            ;
16583 +        quit;
16585 +        * data must be sorted before transposed;
16586 +        proc sort data=_emtstp_tmpDat;
16587 +            by _TSID_ &crossIDVar &timeIDvar;
16588 +        run;
16590 +        %do i = 1 %to &num_TSVar;
16591 +            %let i = &i;
16592 +            * transpose one cross-type time series data by TIMEID;
16593 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
16594 +                by _TSID_ &crossIDVar;
16595 +                var &&&TSVar&i;
16596 +            run;
16597 +        %end;
16599 +        * stack all horizontal time series;
16600 +        data &outDS;
16601 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
16602 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
16603 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
16604 +            %do i=1 %to &num_TSVar;
16605 +                if in&i then do;
16606 +                    _NAMEID_ ="&&&TSVar&i";
16607 +                    _ROLE_   ="&&&TSRole&i";
16608 +                end;
16609 +            %end;
16610 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
16611 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
16612 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
16613 +        run;
16614 +    %end;
16615 +%end;
16616 +%else %do;
16618 +    proc sql noprint;
16619 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
16620 +            order by _NAMEID_
16621 +        ;
16622 +    quit;
16624 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
16625 +        * transpose the panel-type time series data by TSID;
16626 +        proc sort data=&inDS out=_emtstp_tmpDat;
16627 +            by &timeIDvar;
16628 +        proc transpose data=_emtstp_tmpDat
16629 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
16630 +            by &timeIDVar;
16631 +            var &panelTSVar;
16632 +        run;
16633 +        proc datasets lib=work nolist;
16634 +            modify _emtstp_tmpDat2;
16635 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
16636 +            run; quit;
16637 +    %end;
16638 +    %else %do;
16639 +        * transpose the panel-type time series data by TIMEID;
16640 +        proc sort data=&inDS out=_emtstp_tmpDat;
16641 +            by &timeIDvar;
16642 +        data _emtstp_tmpDat;
16643 +            set _emtstp_tmpDat;
16644 +            _tmp_ind=_n_;
16645 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
16646 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
16647 +            ID _tmp_ind;
16648 +            var &panelTSVar;
16649 +        run;
16650 +    %end;
16652 +      * merge ID maps to the transpose data set;
16653 +      proc sql noprint;
16654 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
16655 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
16656 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
16657 +          ;
16658 +      quit;
16660 +      * update the TS ID map;
16661 +      data &outIDMap;
16662 +          set &inIDMap;
16663 +      run;
16664 +%end;
16666 +proc datasets lib=work nolist;
16667 +    delete _emtstp:;
16668 +run; quit;
16670 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_TRAIN.SOURCE.
16672 +/*-----------------------------------------------------------------------------------+
16673 + |
16674 + |   Title :
16675 + |   Data Preparation Node for Time Series Data Mining
16676 + |
16677 + |   support : Taiyeong Lee(Taiyeong.Lee@sas.com)
16678 +               Ruiwen Zhang(Ruiwen.Zhang@sas.com)
16679 + |
16680 + |   Notes:
16681 + +-----------------------------------------------------------------------------------*/
16684 +%Macro EM_TSDP_Train;
16686 +/*---------- Check and assign the input data set --------------------------*/
16688 +%let _IMPORT_DATA  = ;
16689 +%let _IMPORT_CMETA = ;
16690 +%let _DATA_EMINFO  = ;
16691 +%let _EXPORT_DATA  = ;
16692 +%let _FILE_CDELTA  = ;
16694 +%let _timeidvar    = %EM_TIMEID;
16696 +%global EM_TS_ERR _diffobs _tsdp_t1 _tsdp_t2;
16698 +* training data has higher priority than transaction;
16699 +%if &EM_IMPORT_DATA ne  %then %do;
16700 +    %let _IMPORT_DATA  = &EM_IMPORT_DATA;
16701 +    %let _IMPORT_CMETA = &EM_IMPORT_DATA_CMETA;
16702 +    %let _DATA_EMINFO  = &EM_IMPORT_DATA_EMINFO;
16703 +    %let _EXPORT_DATA  = &EM_EXPORT_TRAIN;
16704 +    %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
16705 +%end;
16706 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
16707 +    %let _IMPORT_DATA  = &EM_IMPORT_TRANSACTION;
16708 +    %let _IMPORT_CMETA = &EM_IMPORT_TRANSACTION_CMETA;
16709 +    %let _DATA_EMINFO  = &EM_IMPORT_TRANSACTION_EMINFO;
16710 +    %let _EXPORT_DATA  = &EM_EXPORT_TRANSACTION;
16711 +    %let _FILE_CDELTA  = &EM_FILE_CDELTA_TRANSACTION;
16712 +%end;
16713 +%else %do;
16714 +    %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
16715 +    %goto ENDLINE;
16716 +%end;
16718 +/*-------------  check time id variable -----------------------------*/
16719 +%local _numTimeIDs;
16720 +%let _numTimeIDs=0;
16722 +proc sql noprint;
16723 +    select count(*) into :_numTimeIDs
16724 +    from &EM_DATA_VARIABLESET
16725 +    where upcase(role) eq 'TIMEID' and upcase(strip(level)) eq 'INTERVAL' and upcase(strip(use)) in ('Y' 'D');
16726 +quit;
16728 +%if &_numTimeIDs eq 0 %then %do;
16730 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
16731 +    %put &em_codebar;
16732 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
16733 +    %put &errormsg;
16734 +    %put &em_codebar;
16735 +    %goto ENDLINE;
16737 +%end;
16738 +%else %if &_numTimeIDs gt 1 %then %do;
16740 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
16741 +    %put &em_codebar;
16742 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
16743 +    %put &errormsg;
16744 +    %put &em_codebar;
16745 +    %goto ENDLINE;
16747 +%end;
16749 +/*---------- Get the names of EM-registered output data sets -------------*/
16751 +%EM_GETNAME(KEY=MAPDS,           TYPE=DATA);
16752 +%EM_GETNAME(KEY=MULTBARDS,       TYPE=DATA);
16753 +%EM_GETNAME(KEY=TSMETA,          TYPE=DATA);
16754 +%EM_GETNAME(KEY=TSIDMAP,         TYPE=DATA);
16755 +%EM_GETNAME(KEY=TIMESTARTANDEND, TYPE=DATA);
16756 +%EM_GETNAME(KEY=OUTSUMMARY,      TYPE=DATA);
16757 +%EM_GETNAME(KEY=OUTSEASON,       TYPE=DATA);
16758 +%EM_GETNAME(KEY=OUTDS,           TYPE=DATA);
16760 +data &EM_DATA_EMINFO;
16761 +    length TARGET KEY $32 DATA $43;
16762 +    TARGET = "TARGET";
16764 +    KEY = "TSMETA";         DATA = "&EM_USER_TSMETA";      output;
16765 +    KEY = "TSIDMAP";        DATA = "&EM_USER_TSIDMAP";     output;
16766 +    KEY = "TSDPTRAINDS";    DATA = "&_IMPORT_DATA";        output;
16767 +    KEY = "TSDPTRAINCMETA"; DATA = "&_IMPORT_CMETA";       output;
16768 +    KEY = "TSDPVARSET";     DATA = "&EM_DATA_VARIABLESET"; output;
16770 +    %if &EM_PROPERTY_TRANSBYVAR eq BYTIMEID %then %do;
16771 +        KEY = "TSDRTRAIN";      DATA = "&_IMPORT_DATA";    output;
16772 +        KEY = "TSDRTRAINCMETA"; DATA = "&_IMPORT_CMETA";   output;
16773 +    %end;
16774 +run;
16779 +/*----- Create time series metadata ---------------------------------------*/
16781 +%EM_TS_CreateMetadata(
16782 +   inDS         = &_IMPORT_DATA,
16783 +   outDS        = &EM_USER_TSMETA,
16784 +   variableSet  = &EM_DATA_VARIABLESET,
16785 +   timeInterval = &EM_PROPERTY_TIMEINTERVAL
16786 +);
16788 +%if &EM_TS_ERR gt 0 %then %do;
16789 +    %goto endline;
16790 +%end;
16791 +%let EM_TS_ERR = 0;
16794 +/*-- Get Start time and end time from the TIMESTARTANDEND table ---*/
16795 +%if ^%sysfunc(exist(&EM_USER_TIMESTARTANDEND)) %then %do;
16796 +    %EM_TS_CreateTimeStartAndEnd(inDS=&_IMPORT_DATA, outDS=&EM_USER_TIMESTARTANDEND, timeIDVar=&_timeidvar);
16797 +%end;
16798 +%else %do;
16799 +    %if &EM_METASOURCE_CHANGED eq Y %then %do;
16800 +        %EM_TS_CreateTimeStartAndEnd(inDS=&_IMPORT_DATA, outDS=&EM_USER_TIMESTARTANDEND, timeIDVar=&_timeidvar, compare=Y);
16801 +   %end;
16802 +%end;
16804 +%if  &EM_PROPERTY_STARTENDTIME = DEFAULT %then %do;
16805 +    %EM_TS_GET_TIME_VALUES(data=&EM_USER_TIMESTARTANDEND, time1=_tsdp_time1, time2=_tsdp_time2, default=Y);
16806 +%end;
16807 +%else %do;
16808 +    %EM_TS_GET_TIME_VALUES(data=&EM_USER_TIMESTARTANDEND, time1=_tsdp_time1, time2=_tsdp_time2);
16809 +%end;
16811 +%let _tinterval        = ;
16812 +%let _seasonlength     = ;
16813 +%let _timeidformat     = ;
16814 +%let _timeidformattype = ;
16816 +data &EM_USER_TSMETA;
16817 +    set &EM_USER_TSMETA;
16818 +    length userSeasonality 8;
16819 +    label userSeasonality = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_userlencycle, noquote))";
16821 +    * if user specifies a length for seasonlity;
16822 +    if "&EM_PROPERTY_LENGTHCYCLESEL" ne "DEFAULT"
16823 +        then userSeasonality = &EM_PROPERTY_USERLENGTHCYCLE;
16824 +        else userSeasonality = lengthofcycle;
16826 +    * if user specified start/end dates;
16827 +    if "&_tsdp_time1" ne " " and "&_tsdp_time2" ne " " /*and (timeformattype ne 'SEQ')*/
16828 +    then do;
16829 +        start = "&_tsdp_time1";
16830 +        end   = "&_tsdp_time2";
16831 +        apply_start_end = 'Yes';
16832 +    end;
16834 +    * retrieve information for ts metada;
16836 +    call symput('_seasonlength',     userSeasonality);
16837 +    call symput('_tinterval',        timeinterval);
16838 +    call symput('_timeidFormat',     timeformat);
16839 +    call symput('_timeidFormatType', timeformattype);
16841 +    if timeformattype eq 'DATETIME'
16842 +    then do;
16843 +        call symput('_starttime',strip(put(start,datetime.)));
16844 +        call symput('_endtime',  strip(put(end,  datetime.)));
16845 +    end;
16846 +    else if timeformattype eq 'TIME'
16847 +    then do;
16848 +        call symput('_starttime',strip(put(start,time.)));
16849 +        call symput('_endtime',  strip(put(end,  time.)));
16850 +    end;
16851 +    else do;
16852 +        call symput('_starttime',strip(put(start,date9.)));
16853 +        call symput('_endtime',  strip(put(end,  date9.)));
16854 +    end;
16855 +run;
16857 +%let EM_PROPERTY_START        = &_StartTime;
16858 +%let EM_PROPERTY_END          = &_EndTime;
16859 +%let EM_PROPERTY_TIMEINTERVAL = &_tinterval;
16862 +/*----- Run PROC Timeseries for data preparation---------------------------*/
16864 +%EM_TSDP_Timeseries(
16865 +    /*--- input data set and variables ----*/
16866 +    inds            = &_IMPORT_DATA,
16867 +    crossid         = %EM_CROSSID,
16868 +    timeid          = %EM_TIMEID,
16870 +    /*--- time ID variable ----------------*/
16871 +    interval        = &EM_PROPERTY_TIMEINTERVAL,
16872 +    accumulation    = &EM_PROPERTY_ACCUMULATION,
16873 +    timeidfmttype   = &_timeidFormattype,
16874 +    timeidformat    = &_timeidformat,
16875 +    start           = %nrbquote(&_startTime),
16876 +    end             = %nrbquote(&_endTime),
16877 +    seasonlength    = &_seasonlength,
16879 +    /*--- transformation ------------------*/
16880 +    transform       = &EM_PROPERTY_TRANSFORM,
16881 +    boxcoxpara      = &EM_PROPERTY_BOXCOXPARA,
16883 +    /*--- differencing --------------------*/
16884 +    applydif        = &EM_PROPERTY_APPLYDIF,
16885 +    dif             = &EM_PROPERTY_DIF,
16886 +    applysdif       = &EM_PROPERTY_APPLYSDIF,
16887 +    sdif            = 1,
16889 +    /*--- missing intepretation------------*/
16890 +    missing         = &EM_PROPERTY_MISSING,
16891 +    missingconstant = &EM_PROPERTY_MISSINGCONSTANT,
16892 +    zeromiss        = &EM_PROPERTY_ZEROMISS,
16894 +    /*--- output data sets ----------------*/
16895 +    outds           = &EM_USER_OUTDS,
16896 +    outsum          = &EM_USER_OUTSUMMARY,
16897 +    outseason       = &EM_USER_OUTSEASON
16898 +);
16901 +%EM_TS_Time2Seq(inDS=&EM_USER_OUTDS, tsmeta=&EM_USER_TSMETA);
16902 +%EM_TS_Datetime2Time(inDS=&EM_USER_OUTDS, tsmeta=&EM_USER_TSMETA);
16904 +/*----- Get TS IDMap and Merge it with summary and season outputs----------*/
16906 +%EM_TS_CreateIDMap(
16907 +    inDS          = &EM_USER_OUTDS,
16908 +    outIDMap      = &EM_USER_TSIDMAP,
16909 +    outDS         = &EM_USER_OUTDS,
16910 +    variableSet   = &EM_DATA_VARIABLESET,
16911 +    TSIDbyCrossID = Y
16912 +);
16914 +%if &EM_NUM_CROSSID gt 0 %then %do;
16916 +   %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUMMARY, tsidds=&EM_USER_TSIDMAP, byvar=%EM_CROSSID, outds=);
16917 +   %EM_TS_SummaryDS(inDS=&EM_USER_OUTSUMMARY, crossid=%EM_CROSSID);
16919 +   %if &_seasonlength gt 1 %then %do;
16920 +       data  &EM_USER_OUTSEASON;
16921 +           set &EM_USER_OUTSEASON;
16922 +           rename _NAME_ = _VARNAME_;
16923 +       run;
16924 +       %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSEASON,  tsidds=&EM_USER_TSIDMAP, byvar=%EM_CROSSID _VARNAME_, outds=);
16925 +    %end;
16926 +%end;
16927 +%else %do;
16928 +    %if &_seasonlength gt 1 %then %do;
16929 +        data  &EM_USER_OUTSEASON;
16930 +            set &EM_USER_OUTSEASON;
16931 +            rename _NAME_ = _NAMEID_;
16932 +        run;
16933 +        %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSEASON, tsidds=&EM_USER_TSIDMAP, byvar=_NAMEID_, outds=);
16934 +    %end;
16935 +%end;
16937 +/*----- Transpose the time series -----------------------------------------*/
16939 +%if &EM_PROPERTY_TRANSPOSE eq Y %then %do;
16941 +    %EM_REGISTER(KEY=TRANS_IMPORTDS, TYPE=DATA);
16943 +    data &EM_USER_TRANS_IMPORTDS;
16944 +        set &EM_USER_OUTDS;
16945 +    run;
16947 +    %EM_TS_Transpose(
16948 +        inDS        = &EM_USER_OUTDS,
16949 +        inIDMap     = &EM_USER_TSIDMAP,
16950 +        variableSet = &EM_DATA_VARIABLESET,
16951 +        transposeby = &EM_PROPERTY_TRANSBYVAR,
16952 +        outDS       = &EM_USER_OUTDS,
16953 +        outIDMap    = &EM_USER_TSIDMAP
16954 +    );
16955 +%end;
16957 +%ENDLINE:
16958 +quit;
16960 +%mend EM_TSDP_TRAIN;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set EMWS2.TSDP_EMINFO has 5 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.TSDP_VARIABLESET.
      WHERE UPCASE(role)='TIMEID';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: View EMWS2.FIMPORT4_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
NOTE: There were 6497 observations read from the data set EMWS2.FIMPORT4_DATA.
NOTE: Table WORK._EMTSCM_INDS created, with 1096 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: Number of time vectors processed: 1
NOTE: There were 1096 observations read from the data set WORK._EMTSCM_INDS.
NOTE: The data set WORK._EMTSCM_META has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_LABEL created, with 1 rows and 2 columns.
 
NOTE: Table WORK._EMTSCM_META2 created, with 1 rows and 25 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      384:48    404:62    420:122   430:137   440:136   450:152
NOTE: There were 1 observations read from the data set WORK._EMTSCM_META2.
NOTE: The data set EMWS2.TSDP_TSMETA has 1 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file WORK._EM_TSCM: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: View EMWS2.FIMPORT4_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
NOTE: There were 6497 observations read from the data set EMWS2.FIMPORT4_DATA.
NOTE: Table WORK._TMPTIMETABLE created, with 1096 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_TIMESTARTANDEND.
NOTE: There were 1096 observations read from the data set WORK._TMPTIMETABLE.
NOTE: The data set WORK._TMPDIFF has 0 observations and 3 variables.
NOTE: PROCEDURE COMPARE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      12:146
NOTE: There were 0 observations read from the data set WORK._TMPDIFF.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPDIFF (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPTIMETABLE (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._TMPCONTENTS has 2 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._TMPCONTENTS.
      WHERE UPCASE(name)='DATE';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMPCONTENTS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      9:152    12:120
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_TIMESTARTANDEND.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      1:2   1:2
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      181:6
NOTE: There were 1 observations read from the data set EMWS2.TSDP_TSMETA.
NOTE: The data set EMWS2.TSDP_TSMETA has 1 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 6497 observations read from the data set EMWS2.FIMPORT4_TRAIN.
NOTE: View EMWS2.FIMPORT4_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
NOTE: There were 6497 observations read from the data set EMWS2.FIMPORT4_DATA.
NOTE: The data set WORK._TMPINDS has 6497 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There are 1096 time periods between START=01/01/2020 and END=12/31/2022.
NOTE: Number of series processed: 12
NOTE: There were 6497 observations read from the data set WORK._TMPINDS.
NOTE: The data set EMWS2.TSDP_OUTDS has 13152 observations and 4 variables.
NOTE: The data set EMWS2.TSDP_OUTSUMMARY has 12 observations and 16 variables.
NOTE: The data set EMWS2.TSDP_OUTSEASON has 84 observations and 9 variables.
NOTE: PROCEDURE TIMESERIES used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.TSDP_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.TSDP_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 4 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.TSDP_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set WORK._EMTSCM_TMPIDMAP has 1 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_TMP1 created, with 12 rows and 3 columns.
 
NOTE: Table EMWS2.TSDP_TSIDMAP created, with 12 rows and 5 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set EMWS2.TSDP_TSIDMAP has 12 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
WARNING: This CREATE TABLE statement recursively references the target table. A consequence of this is a possible data integrity problem.
NOTE: Table EMWS2.TSDP_OUTDS created, with 13152 rows and 5 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set EMWS2.TSDP_TSIDMAP has 12 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set EMWS2.TSDP_TSIDMAP has 12 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_INDS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_LABEL (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META2 (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_TMP1 (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_TMPIDMAP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set EMWS2.TSDP_TSIDMAP has 12 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The file WORK._EMTSCM_: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_OUTSUMMARY.
NOTE: The data set WORK._TMP_INDS has 12 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set WORK._TMP_TSIDDS has 12 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set WORK._TMP_TSIDDS.
NOTE: There were 12 observations read from the data set WORK._TMP_INDS.
NOTE: The data set EMWS2.TSDP_OUTSUMMARY has 12 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_INDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_TSIDDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK.EM_USER_KEY has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
WARNING: Apparent symbolic reference EM_USER_OUTSUM not resolved.
NOTE: The query requires remerging summary statistics back with the original data.
NOTE: Table EMWS2.TSDP_OUTSUM1 created, with 6 rows and 11 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK.EM_USER_KEY.
NOTE: The data set WORK.EM_USER_KEY has 2 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
WARNING: Apparent symbolic reference EM_USER_OUTSUM not resolved.
NOTE: The query requires remerging summary statistics back with the original data.
NOTE: Table EMWS2.TSDP_OUTSUM2 created, with 2 rows and 11 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 84 observations read from the data set EMWS2.TSDP_OUTSEASON.
NOTE: The data set EMWS2.TSDP_OUTSEASON has 84 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 84 observations read from the data set EMWS2.TSDP_OUTSEASON.
NOTE: The data set WORK._TMP_INDS has 84 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set WORK._TMP_TSIDDS has 12 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set WORK._TMP_TSIDDS.
NOTE: There were 84 observations read from the data set WORK._TMP_INDS.
NOTE: The data set EMWS2.TSDP_OUTSEASON has 84 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_INDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_TSIDDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2 observations read from the data set WORK.EM_USER_KEY.
NOTE: The data set WORK.EM_USER_KEY has 3 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 13152 observations read from the data set EMWS2.TSDP_OUTDS.
NOTE: The data set EMWS2.TSDP_TRANS_IMPORTDS has 13152 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set WORK._EMTSTP_MAP0 has 12 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 13152 observations read from the data set EMWS2.TSDP_OUTDS.
NOTE: The data set WORK._EMTSTP_TMPDAT has 13152 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set WORK._EMTSTP_MAP0.
NOTE: The data set WORK._EMTSTP_TMPMAP has 12 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set WORK._EMTSTP_TMPMAP.
NOTE: The data set EMWS2.TSDP_TSIDMAP has 12 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 13152 observations read from the data set WORK._EMTSTP_TMPDAT.
NOTE: The data set WORK._EMTSTP_TMPDAT has 13152 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 13152 observations read from the data set WORK._EMTSTP_TMPDAT.
NOTE: The data set WORK._EMTSTP_TD1 has 1096 observations and 13 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set WORK._EMTSTP_TD1.
NOTE: The data set EMWS2.TSDP_OUTDS has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._EMTSTP_MAP0 (memtype=DATA).
NOTE: Deleting WORK._EMTSTP_TD1 (memtype=DATA).
NOTE: Deleting WORK._EMTSTP_TMPDAT (memtype=DATA).
NOTE: Deleting WORK._EMTSTP_TMPMAP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
16961
16962
16963  *------------------------------------------------------------*;
16964  * End TRAIN: TSDP;
16965  *------------------------------------------------------------*;
 
16966  *------------------------------------------------------------*;
16967  * Close any missing semi colons;
16968  *------------------------------------------------------------*;
16969  ;
16970  ;
16971  ;
16972  ;
16973  quit;
16974  *------------------------------------------------------------*;
16975  * Close any unbalanced quotes;
16976  *------------------------------------------------------------*;
16977  /*; *"; *'; */
16978  ;
16979  run;
16980  quit;
16981  /* Reset EM Options */
16982  options formchar="|----|+|---+=|-/\<>*";
16983  options nocenter ls=256 ps=10000;
16984  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                January 06, 2024
Time:                00:17:43
*------------------------------------------------------------*
17086  %let EMEXCEPTIONSTRING=;
17087  *------------------------------------------------------------*;
17088  * SCORE: TSDP;
17089  *------------------------------------------------------------*;
17090  %let EM_ACTION = SCORE;
17091  %let syscc = 0;
17092
17093  %macro EM_TSDP_MAIN;
17094
17095     filename temp catalog 'sashelp.emtsdm.tsdp_macros.source';
17096     %include temp;
17097     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
17098     %include temp;
17099     filename temp;
17100
17101     %if %upcase(&EM_ACTION) = CREATE %then %do;
17102         filename temp catalog 'sashelp.emtsdm.tsdp_create.source';
17103         %include temp;
17104         filename temp;
17105         %EM_TSDP_CREATE;
17106     %end;
17107     %else
17108     %if %upcase(&EM_ACTION) = TRAIN %then %do;
17109          filename temp catalog 'sashelp.emtsdm.tsdp_train.source';
17110             %include temp;
17111             filename temp;
17112         %EM_TSDP_TRAIN;
17113     %end;
17114     %else
17115     %if %upcase(&EM_ACTION) = SCORE %then %do;
17116          filename temp catalog 'sashelp.emtsdm.tsdp_score.source';
17117             %include temp;
17118             filename temp;
17119         %EM_TSDP_SCORE;
17120     %end;
17121     %else
17122     %if %upcase(&EM_ACTION) = REPORT %then %do;
17123             filename temp catalog 'sashelp.emtsdm.tsdp_report.source';
17124             %include temp;
17125             filename temp;
17126          %EM_TSDP_REPORT;
17127     %end;
17128     %else
17129       %if %upcase(&EM_ACTION) = OPENTIMETABLEACTION  %then %do;
17130             filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
17131             %include temp;
17132             filename temp;
17133          %EM_TSDP_OpenTimeTable ;
17134     %end;
17135     %else
17136     %if %upcase(&EM_ACTION) = CLOSETABLEACTION  %then %do;
17137            filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
17138             %include temp;
17139             filename temp;
17140          %EM_TSDP_closeTimeTable ;
17141     %end;
17142
17143  %mend EM_TSDP_MAIN;
17144  %EM_TSDP_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_MACROS.SOURCE.
17145 +/*----------------------------------------------------------------------------------+
17146 + |
17147 + |   Title :
17148 + |   TS Data Preparation Node for Time Series Data Mining
17149 + |
17150 + |   Support : Taiyeong Lee( Taiyeong.Lee@sas.com)
17151 + |
17152 + |   Notes:
17153 + |
17154 + |----------------------------------------------------------------------------------*/
17157 +%Macro EM_TSDP_Timeseries(
17158 +    /*--- input data set and variables ----*/
17159 +    inds            = ,
17160 +    crossid         = ,
17161 +    timeid          = ,
17163 +      /*--- time ID variable ----------------*/
17164 +    interval        = ,
17165 +    accumulation    = ,
17166 +    timeidfmttype   = ,
17167 +    timeidformat    = ,
17168 +    start           = ,
17169 +    end             = ,
17170 +    seasonlength    = ,
17172 +      /*--- transformation ------------------*/
17173 +    transform       = ,
17174 +    boxcoxpara      = ,
17176 +      /*--- differencing --------------------*/
17177 +    applydif        = ,
17178 +    dif             = ,
17179 +    applysdif       = ,
17180 +    sdif            = ,
17182 +      /*--- missing intepretation------------*/
17183 +    missing         = ,
17184 +    missingconstant = ,
17185 +    zeromiss        = ,
17187 +      /*--- output data sets ----------------*/
17188 +    outds           = ,
17189 +    outsum          = ,
17190 +    outseason       =
17191 +);
17193 +/*%if &interval eq Hour or &interval eq Minute or &interval eq Second
17194 +    or &EM_PROPERTY_TIMEOFDAY eq Y or &timeidfmttype eq DATETIME   */
17195 +%if &timeidfmttype eq DATETIME
17196 +%then %do;
17197 +    %let _dtTag=DT;
17198 +%end;
17199 +%else %if &timeidfmttype eq TIME
17200 +%then %do;
17201 +    %let _dtTag=T;
17202 +%end;
17203 +%else %do;
17204 +    %let _dtTag=D;
17205 +%end;
17207 +proc sort data=&inds(keep = &crossid &timeid %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)
17208 +     out=_tmpinds;
17209 +     by &crossid &timeid;
17210 +run;
17212 +proc timeseries data=_tmpinds out=&outds
17213 +    %if "&crossid" eq " "
17214 +        %then %do; outsum=&outsum(rename=(_NAME_=_NAMEID_)) %end;
17215 +        %else %do; outsum=&outsum %end;
17216 +    %if &seasonlength gt 1
17217 +    %then %do;
17218 +        outseason = &outseason seasonality= &seasonlength
17219 +    %end;
17220 +    ;
17222 +    %if &seasonlength gt 1
17223 +    %then %do;
17224 +        season SUM MEAN MIN MAX MEDIAN;
17225 +    %end;
17227 +    %if &crossid ne  %then %do;
17228 +        by &crossid;
17229 +    %end;
17231 +    id &timeid
17232 +        interval   = &interval
17233 +        accumulate = &accumulation
17234 +        %if &missing eq CONSTANT %then %do;
17235 +            setmissing = &missingconstant
17236 +        %end;
17237 +        %else %do;
17238 +            setmissing = &missing
17239 +        %end;
17240 +        %if &zeromiss ne NONE  %then %do;
17241 +            zeromiss = &zeromiss
17242 +        %end;
17243 +        %if &start ne  %then %do;
17244 +            %let  _start = "&start" ;
17245 +            start = &_start.&_dtTag
17246 +        %end;
17247 +        %if &end ne  %then %do;
17248 +            %let  _end = "&end";
17249 +            end = &_end.&_dtTag
17250 +        %end;
17251 +    ;
17253 +    var %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /
17254 +        %if &zeromiss ne NONE  %then %do;
17255 +            zeromiss = &zeromiss
17256 +        %end;
17257 +        %if &transform ne NONE  %then %do;
17258 +            %if &transform eq BOXCOX  %then %do;
17259 +                transform = BOXCOX(&boxcoxpara)
17260 +            %end;
17261 +            %else %do;
17262 +                transform = &transform
17263 +            %end;
17264 +        %end;
17265 +        %if &applydif eq Y  %then %do;
17266 +            dif = (&dif)
17267 +        %end;
17268 +        %if &applysdif eq Y %then %do;
17269 +            sdif = (&sdif)
17270 +        %end;
17271 +    ;
17272 +run;
17273 +quit;
17275 +%mend EM_TSDP_TimeSeries;
17278 +/*-----------------------------------------------------------------
17280 +    MERGE AFTER CLUSTERING
17282 ++------------------------------------------------------------------*/
17284 +%macro EM_TSDP_MergeAfterClustering();
17286 +/*--- need to fix the code based on data Role (train or transaction) ---*/
17288 +%EM_REGISTER(KEY=CLUSTS, TYPE=DATA);
17289 +%EM_GETNAME(KEY=CLUSTS, TYPE=DATA);
17291 +%let _train = ;
17292 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17293 +%if &dsid > 0 %then %do;
17294 + %let vn_data =%sysfunc(varnum(&dsid, DATA));
17295 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
17296 +%do %while(^ %sysfunc(fetch(&dsid)));
17297 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17298 +     %if &_key eq TSDRTRAIN %then %do;
17299 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
17300 +     %end;
17301 +     %else %if &_key eq TSDCTRAIN %then %do;
17302 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
17303 +     %end;
17304 +     %else %if &_key eq TSDPTRAINDS %then %do;
17305 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
17306 +     %end;
17307 +%end;
17308 +%end;
17309 +%let dsid = %sysfunc(close(&dsid));
17311 +proc sort data =&_train out=_inds;
17312 +     by %EM_CROSSID;
17313 +run;
17314 +proc sort data=&EM_IMPORT_DATA out=_outclus(KEEP= %EM_CROSSID _SEGMENT_);
17315 +      by %EM_CROSSID;
17316 +run;
17317 +data &EM_USER_CLUSTS;
17318 +     merge _inds _outclus;
17319 +     by %EM_CROSSID;
17320 +run;
17322 +proc sort data =&EM_USER_TSIDMAP;
17323 +     by %EM_CROSSID;
17324 +run;
17326 +data &EM_USER_TSIDMAP;
17327 +     merge &EM_USER_TSIDMAP _outclus;
17328 +     by %EM_CROSSID;
17329 +run;
17331 +data &EM_USER_CLUSTS ;
17332 +    merge  &EM_USER_TSIDMAP &EM_USER_CLUSTS;
17333 +     by %EM_CROSSID;
17334 +run;
17335 +quit;
17337 +%mend EM_TSDP_MergeAfterClustering;
17339 +%macro EM_TSDP_MergeTSID(inds=, tsidds=, byvar=, outds=);
17341 +    proc sort data =&inds out=_tmp_inds;
17342 +        by &byvar;
17343 +    proc sort data=&tsidds out=_tmp_tsidds;
17344 +        by &byvar;
17345 +    run;
17346 +    %if &outds eq %then %do;
17347 +        data &inds;
17348 +    %end;
17349 +    %else %do;
17350 +        data &outds;
17351 +    %end;
17352 +            merge _tmp_tsidds _tmp_inds;
17353 +            by &byvar;
17354 +        run;
17356 +    %EM_TS_DELETE_DATA(dsname=_tmp_inds);
17357 +    %EM_TS_DELETE_DATA(dsname=_tmp_tsidds);
17359 +%mend EM_TSDP_MergeTSID;
17361 +%macro EM_TS_SummaryDS(inDS=, crossid=);
17362 +    %let j=1;
17363 +    %do %while(%scan(&crossid, &j) ne );
17364 +        %let _csvar=%scan(&crossid, &j);
17365 +        %EM_REGISTER(KEY=OUTSUM&j, TYPE=DATA);
17366 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
17367 +        %EM_TS_SummaryByCSID(inDS=&inDS, outDS=&EM_USER_OUTSUM&j,crossIDVar=&_csvar);
17368 +        %let j=%eval(&j+1);
17369 +    %end;
17370 +%mend EM_TS_SummaryDS;
17373 +%macro EM_TS_SummaryByCSID(inDS=, outDS=, RoleVar=_role_, TSVar=_varname_, crossIDVar=);
17374 +    proc sql noprint;
17375 +        create table &outDS as
17376 +            select distinct &RoleVar, &TSVar, &crossIDVAr,
17377 +                mean(mean1)  as mean      label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmean, noquote))",
17378 +                std(mean1)   as std_mean  label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smean, noquote))",
17379 +                mean(sum1)   as sum       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_msum, noquote))",
17380 +                std(sum1)    as std_sum   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_ssum, noquote))",
17381 +                mean(min1)   as min       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmin, noquote))",
17382 +                std(min1)    as std_min   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smin, noquote))",
17383 +                mean(max1)   as max       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmax, noquote))",
17384 +                std(max1)    as std_max   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smax, noquote))"
17385 +            from &inDS(rename=(mean=mean1 sum=sum1 min=min1 max=max1))
17386 +                group by &TSVar, &crossIDVar
17387 +                order by &TSVar, &crossIDVar
17388 +        ;
17389 +    quit;
17390 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
17391 +/*
17392 +       MACRO: TS Utility macros
17394 +       PURPOSE: TS Utility macros
17395 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
17397 +       HISTORY:
17398 +       NOTE:
17400 +*/
17402 +/*
17403 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
17404 +                          timeid=, timeformat=, timeinformat=);
17405 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
17407 +    %do;
17408 +    %let m_data      = &data;
17409 +    %let m_decdata   = &decdata;
17410 +    %let m_decmeta   = &decmeta;
17411 +    %let m_cmeta     = &cmeta;
17412 +    %let m_outfile   = &outfile;
17413 +    %let m_crossid   = &crossid;
17414 +    %let m_timeid    = &timeid;
17415 +    %let m_timeformat    = &timeformat;
17416 +    %let m_timeinformat    = &timeinformat;
17417 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
17418 +  %end;
17419 +%mend EM_TS_CreateTsMetaDs;
17420 +*/
17421 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
17422 +proc sql;
17423 +      create table _tmp_inds
17424 +      as select distinct &timeid from  &indata;
17425 +quit;
17426 +run;
17427 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
17428 +  id &timeid
17429 +%if &timeinterval ne %then %do;
17430 +    %if &timeformattype eq DATE %then %do;
17431 +        interval=&timeinterval
17432 +    %end;
17433 +    %else %if &timeformattype eq DATETIME  %then %do;
17434 +        %let dttimeinterval= DT&timeinterval;
17435 +         interval=&dttimeinterval
17436 +    %end;
17437 +%end;
17438 +;
17439 +run;
17441 +data &outds;
17442 +     set _tmp_tsmeta;
17443 +     format START &timeformat;
17444 +     format END &timeformat;
17445 +     length APPLY_START_END $8;
17446 +     APPLY_START_END ="No";
17447 +     FORMAT = "&timeformat";
17448 +     ROLE ="TIMEID";
17449 +     rename TIMEID = NAME;
17450 +     rename SEASONALITY= LengthOfCycle;
17451 +     rename INTERVAL = TIMEINTERVAL ;
17452 +     rename FORMAT = TIMEFORMAT;
17453 +     output;
17454 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
17455 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
17456 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
17457 +run;
17459 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
17460 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
17462 +%mend EM_TS_CreateTSMetaData;
17466 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
17468 +/* if updated = Y it will pass the TSMETA created by just the previous node */
17470 +%let _tsmetads = ;
17472 +%if &updated = Y %then %do;
17473 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
17474 +%if %sysfunc(exist(&_tsmetads)) %then %do;
17475 +%goto endline;
17476 +%end;
17477 +%end;
17479 +%if &eminfodata eq %then %do;
17480 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17481 +    data &EM_DATA_EMINFO;
17482 +         set &EM_IMPORT_DATA_EMINFO;
17483 +    run;
17484 +%end;
17485 +%else %do;
17486 +    %let dsid=%sysfunc(open(&eminfodata));
17487 +    data &EM_DATA_EMINFO;
17488 +         set &eminfodata;
17489 +    run;
17490 +%end;
17491 +%if &dsid > 0 %then %do;
17492 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
17493 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
17494 +    %do %while(^ %sysfunc(fetch(&dsid)));
17495 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17496 +         %if &_key eq TSMETA %then %do;
17497 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
17498 +         %end;
17499 +    %end;
17500 +    %let dsid = %sysfunc(close(&dsid));
17501 +%end; /* the end of %if &dsid > 0 %then %do; */
17503 +%endline:
17505 +%if &_tsmetads ne %then %do;
17506 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
17507 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
17508 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
17509 +         data &EM_USER_TSMETA;
17510 +                   set &_tsmetads;
17511 +         run;
17512 +    %end;
17513 +%end;
17515 +*proc print data=&EM_DATA_EMINFO;
17516 +*proc print data=&EM_IMPORT_DATA_EMINFO;
17517 +*run;
17518 +%MEND EM_TS_GETTSMETA;
17521 +/*
17522 +%macro EM_GETTSMETAVARS(TimeInterval=);
17523 +%global &TimeInterval;
17524 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
17525 +%if &dsid > 0 %then %do;
17526 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
17527 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
17528 +%do %while(^ %sysfunc(fetch(&dsid)));
17529 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17530 +     %if &_role eq TIMEID %then %do;
17531 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
17532 +     %end;
17533 +%end;
17534 +%let dsid = %sysfunc(close(&dsid));
17535 +%end;
17536 +%MEND EM_GETTSMETAVARS;
17537 +*/
17538 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
17539 +%global &TimeInterval;
17540 +%global &TimeId;
17541 +%global &EndTime;
17542 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
17543 +proc print data=&EM_USER_TSMETA;
17544 +run;
17545 +%if &dsid > 0 %then %do;
17546 +%if &TimeInterval ne %then %do;
17547 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
17548 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17549 +    %do %while(^ %sysfunc(fetch(&dsid)));
17550 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17551 +        %if &_role eq TIMEID %then %do;
17552 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
17553 +        %end;
17554 +     %end;
17555 +%end;
17556 +%if &TimeId ne %then %do;
17557 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
17558 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17559 +    %do %while(^ %sysfunc(fetch(&dsid)));
17560 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17561 +        %if &_role eq TIMEID %then %do;
17562 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
17563 +        %end;
17564 +    %end;
17565 +%end;
17567 +%if &EndTime ne %then %do;
17568 +    %let vn_end =%sysfunc(varnum(&dsid, END));
17569 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17570 +    %do %while(^ %sysfunc(fetch(&dsid)));
17571 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17572 +        %if &_role eq TIMEID %then %do;
17573 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
17574 +        %end;
17575 +     %end;
17576 +%end;
17577 +%let dsid = %sysfunc(close(&dsid));
17578 +%end;
17579 +%MEND EM_TS_GETTSMETAVARS;
17583 +/*------------------------------------------------------------------
17585 +      Macro EM_GETTSIDMAP
17587 +------------------------------------------------------------------+*/
17590 +%macro EM_TS_GETTSIDMAP(updated=);
17592 +%let _tsidmap = ;
17594 +%if &updated = Y %then %do;
17595 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
17596 +%if %sysfunc(exist(&_tsidmap)) %then %do;
17597 +%goto endline;
17598 +%end;
17599 +%end;
17601 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17602 +%if &dsid > 0 %then %do;
17603 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
17604 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
17605 +%do %while(^ %sysfunc(fetch(&dsid)));
17606 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17607 +     %if &_key eq TSIDMAP %then %do;
17608 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
17609 +     %end;
17610 +%end;
17612 +%let dsid = %sysfunc(close(&dsid));
17613 +%end;
17615 +%endline:
17617 +%if &_tsidmap ne %then %do;
17619 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
17620 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
17622 +%if %sysfunc(exist(&_tsidmap)) %then %do;
17623 +         data &EM_USER_TSIDMAP;
17624 +               set &_tsidmap;
17625 +         run;
17626 +    %end;
17627 +%end;
17628 +%MEND EM_TS_GETTSIDMAP;
17630 +/*------------------------------------------------------------------*/
17635 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
17636 +%global &value;
17639 +%let dsid = %sysfunc(open(&data));
17640 +%if &dsid > 0 %then %do;
17641 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
17642 +    %if &vn_var < 1 %then %do;
17643 +        %let &value = 0;
17644 +        %let dsid = %sysfunc(close(&dsid));
17645 +        %goto endline;
17646 +    %end;
17647 +%let dsid = %sysfunc(close(&dsid));
17648 +%end;
17650 +%let _tmp=_tmpDS;
17651 +proc means data=&data &stat;
17652 +     var &var;
17653 +     output out=&_tmp;
17654 +run;
17656 +%let dsid = %sysfunc(open(&_tmp));
17657 +%if &dsid > 0 %then %do;
17658 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
17659 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
17660 +     %do %while(^%sysfunc(fetch(&dsid)));
17661 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
17662 +         %if &_stat eq &stat %then %do;
17663 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
17664 +          %end;
17665 +      %end;
17666 +%let dsid = %sysfunc(close(&dsid));
17667 +%end;
17668 +proc datasets lib=work nolist;
17669 + delete &_tmp;
17670 +run;
17671 +%endline:
17672 +%MEND EM_TS_GET_STAT;
17675 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
17676 +%global &format;
17677 +%global &informat;
17678 +%let dsid = %sysfunc(open(&data));
17679 +%if &dsid > 0 %then %do;
17680 +%let vn_var =%sysfunc(varnum(&dsid, &var));
17681 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
17682 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
17683 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
17684 +%end;
17685 +%let dsid = %sysfunc(close(&dsid));
17686 +%end;
17687 +%MEND EM_TS_GET_VAR_FORMAT;
17689 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
17690 +      %if &lib eq %then %let lib=work;
17691 +       proc datasets lib=&lib nolist;
17692 +              delete &dsname;
17693 +       run;
17694 +%Mend  EM_TS_DELETE_DATA;
17697 +%macro EM_TS_GetNObs(inds=, nobs=);
17698 +    %global &nobs;
17699 +    %let &nobs=0;
17700 +    data _null_;
17701 +        set &inds end=eof;
17702 +        if eof then call symput("&nobs", _N_);
17703 +    run;
17704 +    quit;
17706 +    /*
17707 +    %let dsid=%sysfunc(open(&outdata));
17708 +    %if dsid > 0 %then %do;
17709 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
17710 +        %let dsid = %sysfunc(close(&dsid));
17711 +     %end;
17712 +    */
17713 +%mend  EM_TS_GetNObs;
17716 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
17717 +%global &time1;
17718 +%global &time2;
17719 +%if &default = Y %then %do;
17720 +   data _null_;
17721 +        set &data end=eof;
17722 +        if _N_ = 1 then  call symput("&time1", DATE);
17723 +        if eof then call symput("&time2", DATE);
17724 +    run;%end;
17725 +%else %do;
17726 +    %let dsid = %sysfunc(open(&data));
17727 +    %if &dsid > 0 %then %do;
17728 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
17729 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
17730 +        %do %while(^%sysfunc(fetch(&dsid)));
17731 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
17732 +             %if &_index eq 1 %then %do;
17733 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
17734 +             %end;
17735 +             %if &_index eq 2 %then %do;
17736 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
17737 +             %end;
17738 +        %end;
17739 +    %let dsid = %sysfunc(close(&dsid));
17740 +    %end;
17741 +%end;
17743 +%MEND EM_TS_GET_TIME_VALUES;
17745 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
17746 +%global &exist;
17747 + %let &exist = N;
17748 +%let dsid = %sysfunc(open(&data));
17749 +%if &dsid > 0 %then %do;
17750 +%let vn_var =%sysfunc(varnum(&dsid, &var));
17751 +%if &vn_var > 0 %then %do;
17752 +    %let &exist = Y;
17753 +%end;
17754 +%let dsid = %sysfunc(close(&dsid));
17755 +%end;
17756 +%MEND EM_TS_GET_VAR_EXIST;
17759 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
17760 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
17761 +      set &intreedata;
17762 +        LENGTH NodeType $32;
17763 +      if _PARENT_ eq " " then delete;
17764 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
17765 +        else NodeType = "CLUSTER";
17766 +        LinkID = _N_;
17767 +run;
17768 +%Mend EM_TS_MakeConstellPlotData;
17773 +%macro EM_TS_CreateIDMap(
17774 +/*-------------------------------------------------------------------------*/
17775 +/*---   Written by Xiangxiang Meng                                         */
17776 +/*-------------------------------------------------------------------------*/
17777 +inDS          =,      /* imported data set in TS data mining               */
17778 +outIDMap      =,      /* output data set of TS ID map                      */
17779 +outDS         =,      /* output data set of TS and TS ID merged            */
17780 +variableSet   =,      /* EM variable set                                   */
17781 +TSIDbyCrossID =Y,
17782 +inEM          =Y
17783 +/*-------------------------------------------------------------------------*/
17784 +);
17786 +%global EM_TS_ERR;
17787 +%let EM_TS_ERR = 0;
17789 +%if &inEM eq Y %then %do;
17790 +    %let num_crossIDVar = &EM_NUM_CROSSID;
17791 +    proc sql noprint;
17792 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
17793 +    quit;
17794 +%end;
17795 +%else %do;
17796 +    proc sql noprint;
17797 +         select count(*) into :num_crossIDVar from &variableSet
17798 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17799 +         ;
17800 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
17801 +         ;
17802 +    quit;
17803 +    %let num_crossIDVar=&num_crossIDVar;
17804 +%end;
17806 +* see if _TSID_ exists;
17808 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
17809 +run;
17811 +proc sql noprint;
17812 +    select count(*) into :has_TSID
17813 +        from _emtscm_contents
17814 +        where upcase(strip(name)) eq '_TSID_'
17815 +    ;
17816 +quit;
17818 +/*-------------------------------------------------------------------------*/
17819 +* Creating TSID map..;
17820 +/*-------------------------------------------------------------------------*/
17822 +%if (&num_crossIDVar gt 0) %then %do;
17824 +    data _emtscm_tmpIDMap;
17825 +        set &variableSet;
17826 +        where  (upcase(strip(level)) eq 'INTERVAL')
17827 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
17828 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
17829 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
17830 +          );
17831 +        _emts_dummy=1;
17832 +        keep name label role _emts_dummy;
17833 +    run;
17835 +    proc sql noprint;
17836 +        * create a string of crossID variable like A,B,C,D..;
17837 +        select distinct name into :crossIDVar separated by ','
17838 +            from &variableSet
17839 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17840 +            order by name
17841 +        ;
17842 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
17843 +            from &variableSet
17844 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17845 +            order by name
17846 +        ;
17847 +        * create the TSID map data set;
17848 +        create table _emtscm_tmp1 as
17849 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
17850 +        ;
17851 +        * create a level list of cross ID variables and time series variables;
17852 +        create table &outIDMap as
17853 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
17854 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
17855 +            where a._emts_dummy eq b._emts_dummy
17856 +            order by a.name, &crossIDVar
17857 +        ;
17858 +    quit;
17860 +    %if &TSIDbyCrossID = Y %then %do;
17861 +        * create unique TSID only by Cross ID;
17862 +        data &outIDMap;
17863 +            length _TSID_ 8;
17864 +            set &outIDMap;
17865 +            by _NAMEID_;
17866 +            if first._NAMEID_
17867 +                then _TSID_=1;
17868 +                else _TSID_+1;
17869 +        run;
17870 +        %if "&outDS" ne "" %then %do;
17871 +            * merge TSID into &inDS;
17872 +            proc sql noprint;
17873 +                create table &outDS as
17874 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
17875 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
17876 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
17877 +                        where %do i = 1 %to &num_crossIDVar;
17878 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
17879 +                              %end;
17880 +                             b._TSID_ is not missing
17881 +                    order by b._TSID_, a.&timeIDVar
17882 +                ;
17883 +            quit;
17884 +        %end;
17885 +    %end;
17886 +    %else %do;
17887 +        * create unique TSID by Cross ID and _NAMEID_;
17888 +        data &outIDMap;
17889 +            length _TSID_ 8;
17890 +            set &outIDMap;
17891 +            _TSID_=_n_;
17892 +        run;
17893 +        %if "&outDS" ne "" %then %do;
17894 +            *no merge in this output;
17895 +            data &outDS;
17896 +                set &inDS;
17897 +            run;
17898 +        %end;
17899 +    %end;
17901 +    proc sort data=&outIDMap;
17902 +        by _NAMEID_ _TSID_;
17903 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
17904 +        format _TSID_ best12. _NAMEID2_ $40.;
17905 +        set &outIDMap;
17906 +        by _NAMEID_;
17907 +        if first._NAMEID_
17908 +            then _emts_ind=1;
17909 +            else _emts_ind+1;
17910 +        drop _emts_ind;
17911 +        rename _NAMEID_=_VARNAME_;
17912 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
17913 +        if _labelID_ eq ' '
17914 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
17915 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
17916 +    run;
17918 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
17920 +%end;
17921 +%else %do; /* if no crossid's the nameid needs to be created */
17923 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
17924 +        length _TSID_ 8;
17925 +        set &variableSet;
17926 +        where  (upcase(strip(level)) eq 'INTERVAL')
17927 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
17928 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
17929 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
17930 +          );
17931 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
17932 +        rename ROLE = _ROLE_;
17933 +        _NAMEID_=strip(name);
17934 +        _VARNAME_=strip(name);
17935 +        if label eq ' '
17936 +            then _LABELID_ = strip(name);
17937 +            else _LABELID_ = strip(label);
17938 +        _TSID_=_n_;
17939 +    run;
17941 +    %if "&outDS" ne "" %then %do;
17942 +        *no merge in this output;
17943 +        data &outDS;
17944 +            set &inDS;
17945 +        run;
17946 +    %end;
17947 +%end;
17949 +data &outIDMap;
17950 +    set &outIDMap;
17951 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
17952 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
17953 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
17954 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
17955 +run;
17957 +proc datasets lib=work nolist;
17958 +    delete _emtscm_:;
17959 +run; quit;
17961 +%mend EM_TS_createIDMap;
17963 +%macro EM_TS_CreateMetaData(
17964 +/*-------------------------------------------------------------------------*/
17965 +  inDS          =,      /* imported data set in TS data mining             */
17966 +  outDS         =,      /* output data set of TS metadata                  */
17967 +  variableSet   =,      /* EM variable set                                 */
17968 +  timeInterval  =,      /* time interval                                   */
17969 +  rc            =       /* return code                                     */
17970 +/*-------------------------------------------------------------------------*/
17971 +);
17973 +%if %eval(
17974 +      &EM_NUM_BINARY_INPUT   +
17975 +      &EM_NUM_ORDINAL_INPUT  +
17976 +      &EM_NUM_NOMINAL_INPUT  +
17977 +      &EM_NUM_BINARY_REJECTED   +
17978 +      &EM_NUM_ORDINAL_REJECTED  +
17979 +      &EM_NUM_NOMINAL_REJECTED  +
17980 +      &EM_NUM_ORDINAL_TARGET  +
17981 +      &EM_NUM_NOMINAL_TARGET +
17982 +      &EM_NUM_BINARY_TARGET
17983 +      ) > 0
17984 +%then %do;
17985 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
17986 +        %put &em_codebar;
17987 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
17988 +        %put &errormsg;
17989 +        %put &em_codebar;
17990 +        %goto ENDLINE;
17991 +%end;
17993 +%global EM_TS_ERR;
17994 +%let EM_TS_ERR = 0;
17996 +%if &timeInterval eq AUTO
17997 +    %then %let timeInterval  = ;
17998 +    %else %let timeInterval  = %upcase(&timeInterval);
18000 +/*-------------------------------------------------------------------------*/
18001 +* check time ID variable;
18002 +/*-------------------------------------------------------------------------*/
18004 +* number of variables in the Variableset with ROLE=TIMEID;
18005 +proc sql noprint;
18006 +    select count(*) into :num_timeID from &variableset
18007 +        where upcase(role) eq 'TIMEID';
18008 +quit;
18010 +/*-------------------------------------------------------------------------*/
18011 +* process only when there is one Time ID, otherwise exception message;
18012 +/*-------------------------------------------------------------------------*/
18014 +%if &num_timeID eq 0 %then %do;
18016 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
18017 +    %let EM_TS_ERR = 11;
18018 +    %put &em_codebar;
18019 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
18020 +    %put &errormsg;
18021 +    %put &em_codebar;
18022 +    %goto tscm_endline;
18024 +%end;
18025 +%else %if &num_timeID gt 1 %then %do;
18027 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
18028 +    %let EM_TS_ERR = 12;
18029 +    %put &em_codebar;
18030 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
18031 +    %put &errormsg;
18032 +    %put &em_codebar;
18033 +    %goto tscm_endline;
18035 +%end;
18036 +%else %do;
18037 +    *** proceed when there is one Time ID;
18039 +    data _null_;
18040 +        set &variableset(where=(upcase(role)='TIMEID'));
18041 +        call symput('timeIDFormat',     strip(format));
18042 +        call symput('timeID',           strip(upcase(name)      ));
18043 +        call symput('timeIDLevel',      strip(upcase(level))     );
18044 +        call symput('timeIDFormatType', strip(upcase(formattype)));
18045 +    run;
18047 +    *** exception message if the time ID is not an interval variable;
18048 +    %if &timeIDLevel ne INTERVAL %then %do;
18049 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
18050 +        %let EM_TS_ERR = 13;
18051 +        %put &em_codebar;
18052 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
18053 +        %put &errormsg;
18054 +        %put &em_codebar;
18055 +        %goto tscm_endline;
18056 +    %end;
18058 +    %if (&timeIDFormatType ne DATETIME) and
18059 +        (&timeIDFormatType ne DATE) and
18060 +        (&timeIDFormatType ne TIME) and
18061 +        (&timeIDFormatType ne USER)
18062 +    %then %do;
18063 +        *** sequential format-type of time ID;
18065 +        %let timeInterval = DAY;
18066 +        %let timeIDFormatType = SEQ;
18068 +        proc sql noprint;
18069 +            create table _emtscm_inds as
18070 +                 select distinct &timeID from &inDS(keep=&timeID)
18071 +                 where &timeID is not missing;
18072 +            select count(*) into :num_nonInteger from _emtscm_inds
18073 +                where &timeID ne int(&timeID);
18074 +        quit;
18076 +        %if &num_nonInteger gt 0 %then %do;
18077 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
18078 +            %let EM_TS_ERR = 14;
18079 +            %put &em_codebar;
18080 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
18081 +            %put &errormsg;
18082 +            %put &em_codebar;
18083 +            %goto tscm_endline;
18084 +        %end;
18085 +    %end;
18086 +    %else %do;
18087 +        *** date, datetime, time format-type of time ID;
18089 +        *** must have a format;
18090 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
18091 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
18092 +            %let EM_TS_ERR = 15;
18093 +            %put &em_codebar;
18094 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
18095 +            %put &errormsg;
18096 +            %put &em_codebar;
18097 +            %goto tscm_endline;
18098 +        %end;
18100 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
18101 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
18102 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
18103 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
18104 +                %let EM_TS_ERR = 16;
18105 +                %put &em_codebar;
18106 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
18107 +                %put &errormsg;
18108 +                %put &em_codebar;
18109 +                %goto tscm_endline;
18110 +            %end;
18111 +        %end;
18113 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
18114 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
18115 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
18116 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
18117 +                %let EM_TS_ERR = 17;
18118 +                %put &em_codebar;
18119 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
18120 +                %put &errormsg;
18121 +                %put &em_codebar;
18122 +                %goto tscm_endline;
18123 +            %end;
18124 +        %end;
18126 +        *** the AUTO function is currently turned off for TIME timeID variable;
18127 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
18128 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
18129 +            %let EM_TS_ERR = 18;
18130 +            %put &em_codebar;
18131 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
18132 +            %put &errormsg;
18133 +            %put &em_codebar;
18134 +            %goto tscm_endline;
18135 +        %end;
18137 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
18138 +            %then %let timeInterval =DT&timeInterval;
18140 +        proc sql noprint;
18141 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
18142 +                where &timeID is not missing;
18143 +        quit;
18144 +    %end;
18146 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
18147 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
18148 +    run;
18150 +    %let hasValidInterval = 0;
18151 +    %let hasLengthOne     = 0;
18153 +    proc sql noprint;
18154 +        create table _emtscm_label as
18155 +            select name,label
18156 +            from dictionary.columns
18157 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
18158 +        ;
18159 +        create table _emtscm_meta2 as
18160 +            select a.*, b.label
18161 +            from _emtscm_meta as a, _emtscm_label as b
18162 +            where upcase(a.timeID) eq upcase(b.name)
18163 +        ;
18164 +    quit;
18166 +    data &outDS;
18167 +        set _emtscm_meta2;
18168 +        format
18169 +            timeformat      $30.
18170 +            role            $10.
18171 +            start           &timeIDformat
18172 +            end             &timeIDformat
18173 +            apply_start_end $8.
18174 +        ;
18175 +        rename
18176 +            timeID      = name
18177 +            seasonality = lengthOfCycle
18178 +            interval    = timeinterval
18179 +        ;
18180 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
18182 +        role            = "TIMEID";
18183 +        apply_start_end = 'N';
18184 +        timeformat      = symget('timeIDformat');
18185 +        timeformattype  = symget('timeIDformatType');
18187 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
18188 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
18189 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
18190 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
18191 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
18192 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
18193 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
18194 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
18195 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
18196 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
18198 +        if timeformattype eq 'SEQ' then do;
18199 +            timeformat='BEST12.';
18200 +            seasonality=1;
18201 +        end;
18203 +        call symput('_tinterval',interval);
18205 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
18207 +        if upcase(timeformattype) eq 'DATE' and
18208 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
18209 +            then call symput('hasValidInterval',1);
18211 +        if upcase(timeformattype) eq 'DATETIME' and
18212 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
18213 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
18214 +            then call symput('hasValidInterval',1);
18216 +        if upcase(timeformattype) eq 'TIME' and
18217 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
18218 +            then call symput('hasValidInterval',1);
18220 +        if upcase(timeformattype) eq 'SEQ'
18221 +            then call symput('hasValidInterval',1);
18223 +        if upcase(timeformattype) eq 'USER'
18224 +            then call symput('hasValidInterval',1);
18226 +        if start eq end
18227 +            then call symput('hasLengthOne',1);
18228 +    run;
18230 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
18232 +    *** detect any missing time interval after running PROC TIMEID;
18233 +    %if &_tinterval eq %then %do;
18234 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
18235 +        %let EM_TS_ERR = 19;
18236 +        %put &em_codebar;
18237 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
18238 +        %put &errormsg;
18239 +        %put &em_codebar;
18240 +        %goto tscm_endline;
18241 +    %end;
18243 +    *** detect any missing time interval after running PROC TIMEID;
18244 +    %if &hasValidInterval eq 0 %then %do;
18245 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
18246 +        %let EM_TS_ERR = 20;
18247 +        %put &em_codebar;
18248 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
18249 +        %put &errormsg;
18250 +        %put &em_codebar;
18251 +        %goto tscm_endline;
18252 +    %end;
18254 +    %if &hasLengthOne eq 1 %then %do;
18255 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
18256 +        %let EM_TS_ERR = 21;
18257 +        %put &em_codebar;
18258 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
18259 +        %put &errormsg;
18260 +        %put &em_codebar;
18261 +        %goto tscm_endline;
18262 +    %end;
18264 +%end;
18266 +%tscm_endline:;
18268 +%mend EM_TS_CreateMetaData;
18271 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
18273 +data _null_;
18274 +    set &tsmeta;
18275 +    call symput('_timeidFormatType', timeformattype);
18276 +    call symput('_timeid', strip(name));
18277 +    call symput('_seqstartnum',strip(put(start,best12.)));
18278 +run;
18280 +proc contents data=&inDS noprint
18281 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
18282 +run; quit;
18284 +data _null_;
18285 +    set _emts_tmpp1;
18286 +    call symput('_timeIDlabel',label);
18287 +run;
18289 +%if &_timeidFormatType eq SEQ
18290 +%then %do;
18291 +    proc sql noprint;
18292 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
18293 +    quit;
18294 +    %let _dummystarttime=&_dummystarttime;
18296 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
18297 +        set &inDS;
18298 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
18299 +        drop &_timeid;
18300 +        label _tsdp_tmpID = "&_timeIDlabel";
18302 +    run;
18303 +%end;
18305 +%mend;
18307 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
18309 +data _null_;
18310 +    set &tsmeta;
18311 +    call symput('_timeidFormatType', timeformattype);
18312 +    call symput('_timeidFormat', timeformat);
18313 +    call symput('_timeid', strip(name));
18314 +    call symput('_timeinterval',strip(upcase(timeinterval)));
18315 +run;
18317 +/* manually change time ID format to a longer enough time format */
18318 +/* because proc timeid returns time5. for second time interval */
18319 +/* which is not long enough for transpose with time unit as seconds */
18320 +%if &_timeinterval eq SECOND
18321 +%then %do;
18322 +    %let _timeIDformat = %str(time8.);
18323 +%end;
18325 +proc contents data=&inDS noprint
18326 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
18327 +run; quit;
18329 +data _null_;
18330 +    set _emts_tmpp1;
18331 +    call symput('_timeIDlabel',label);
18332 +run;
18334 +%if &_timeidFormatType eq TIME
18335 +%then %do;
18336 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
18337 +        set &inDS;
18338 +        _tsdp_tmpID = timepart(&_timeID);
18339 +        format _tsdp_tmpID &_timeidFormat;
18340 +        label  _tsdp_tmpID = "&_timeIDlabel";
18341 +        drop &_timeid;
18342 +    run;
18343 +%end;
18345 +%mend;
18347 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
18349 + proc sql noprint;
18350 +     create table _tmptimetable as
18351 +         select distinct &timeidvar as DATE from &inDS
18352 +         where &timeIDVar is not missing
18353 +         order by &timeIDVar;
18354 + quit;
18356 +%if &compare eq Y %then %do;
18357 +    * compare with the existing time table;
18358 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
18359 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
18360 +    run;
18362 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
18364 +    %if &_diffobs > 0 %then %do; /* create it again */
18365 +        data &outDS(keep=DATE _INDEX_);
18366 +            set _tmptimetable end = _eof_;
18367 +            if _N_ = 1
18368 +                then _INDEX_ = 1;
18369 +                else _INDEX_ = 0;
18370 +            if _eof_ then _INDEX_= 2;
18371 +        run;
18372 +    %end;
18374 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
18375 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
18376 +%end;
18377 +%else %do;
18378 +    * create a new time table directly;
18379 +    data &outDS(keep=DATE _INDEX_);
18380 +        set _tmptimetable end = _eof_;
18381 +        if _N_ = 1
18382 +            then _INDEX_ = 1;
18383 +            else _INDEX_ = 0;
18384 +        if _eof_ then _INDEX_= 2;
18385 +    run;
18387 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
18388 +%end;
18390 +* assign a defult format BEST12. for sequential time ID;
18392 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
18394 +%let _nodatefmt=N;
18396 +data _null_;
18397 +    set _tmpcontents;
18398 +    where upcase(name) eq 'DATE';
18399 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
18400 +run;
18402 +%if "&_nodatefmt" eq "Y" %then %do;
18403 +    data &outDS;
18404 +        set &outDS;
18405 +        format date best12.;
18406 +    run;
18407 +%end;
18409 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
18411 +%mend;
18415 +%macro EM_TS_Transpose(
18416 +/*-------------------------------------------------------------------------*/
18417 +  inDS          =,      /* imported data set in TS data mining             */
18418 +  inIDMap       =,      /* input TS ID map                                 */
18419 +  variableSet   =,      /* variable set                                    */
18420 +  transposeBy   =,      /* byTSID or byTimeID                              */
18421 +  outDS         =,      /* output transposed data set                      */
18422 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
18423 +  inEM          =Y,
18424 +  timePrefix    =_T
18425 +/*-------------------------------------------------------------------------*/
18426 +);
18428 +%let timePrefix = &timePrefix;
18430 +%if  &EM_NUM_CROSSID > 0 %then %do;
18432 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
18433 +    set &inIDMap;
18434 +    drop _NAMEID_;
18435 +    run;
18436 +%let inIDMap=_emtstp_map0;
18438 +%end;
18440 +proc sql noprint;
18441 +    * number of TS Variables to be transposed;
18442 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
18443 +    ;
18444 +    * number of TS Variables to be transposed;
18445 +    select max(_TSID_) into :num_TSID from &inIDMap
18446 +    ;
18447 +    * name list of TS Variables;
18448 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
18449 +        from &inIDMap
18450 +        order by _NAMEID_
18451 +    ;
18452 +    * total number of time series =max(_TSID_)*&num_TSVar;
18453 +    * and the number of digits of this variable is &num_digits;
18454 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
18455 +        from &inIDMap
18456 +    ;
18457 +      * Time ID variable;
18458 +    select name into:timeIDVar from &variableset
18459 +        where upcase(role) eq 'TIMEID'
18460 +    ;
18461 +quit;
18462 +%let num_digits = &num_digits;
18463 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
18465 +/*-------------------------------------------------------------------------*/
18467 +* get number of cross IDs and also the TIME ID variable name;
18468 +%if &inEM eq Y %then %do;
18469 +    %let num_crossIDVar = &EM_NUM_CROSSID;
18470 +    %let crossIDVar     = %EM_CROSSID;
18471 +%end;
18472 +%else %do;
18473 +    proc sql noprint;
18474 +        * number of cross ID;
18475 +        select count(*) into :num_crossIDVar
18476 +            from &variableSet
18477 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
18478 +        ;
18479 +        * create a string of crossID variable like A B C D..;
18480 +        select distinct name into :crossIDVar separated by ' '
18481 +            from &variableSet
18482 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
18483 +            order by name
18484 +        ;
18485 +    quit;
18486 +    %let num_crossIDVar=&num_crossIDVar;
18487 +%end;
18489 +/*-------------------------------------------------------------------------*/
18491 +%if (&num_crossIDVar gt 0) %then %do;
18493 +    data _emtstp_tmpDat;
18494 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
18495 +        _NAMEID_ = cats("_TS_",_TSID_);
18496 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
18497 +    run;
18499 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
18501 +        * update the ID maps;
18502 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
18503 +            by _NAMEID_ _TSID_;
18504 +        data &outIDMap;
18505 +            set _emtstp_tmpmap;
18506 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
18507 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
18508 +        run;
18510 +        * get the names for the new variables;
18511 +        proc sql noprint;
18512 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
18513 +            ;
18514 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
18515 +            ;
18516 +        quit;
18518 +        * data must be sorted before transposed;
18519 +        proc sort data=_emtstp_tmpDat;
18520 +            by &timeIDvar;
18521 +        run;
18523 +        %do i = 1 %to &num_TSVar;
18524 +            %let i = &i;
18525 +            * transpose one cross-type time series data by TSID;
18526 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
18527 +                id _NAMEID_;
18528 +                by &timeIDVar;
18529 +                var &&&TSVar&i;
18530 +            run;
18531 +        %end;
18533 +        * merge all vertical time series, rename and label them;
18534 +        data &outDS;
18535 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
18536 +            by &timeIDVar;
18537 +            rename
18538 +                %do i = 1 %to &num_TSVar;
18539 +                    %do j = 1 %to &num_TSID;
18540 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
18541 +                        /* %put &i &j &num1 &num_TSID; */
18542 +                        _V_&i._TS_&j = &&&tsname&num1
18543 +                    %end;
18544 +                %end;
18545 +            ;
18546 +            label
18547 +                %do i = 1 %to &num_TSVar;
18548 +                    %do j = 1 %to &num_TSID;
18549 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
18550 +                        /* %put &i &j &num1 &num_TSID; */
18551 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
18552 +                    %end;
18553 +                %end;
18554 +            ;
18555 +        run;
18556 +    %end;
18557 +    %else %do;
18559 +        * update the ID maps;
18560 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
18561 +            by _NAMEID_ _TSID_;
18562 +        data &outIDMap;
18563 +            set _emtstp_tmpmap;
18564 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
18565 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
18566 +        run;
18568 +        proc sql noprint;
18569 +            * get the roles for the new variables;
18570 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
18571 +                from &inIDMap
18572 +                order by _NAMEID_
18573 +            ;
18574 +            * get the length of the time series;
18575 +            select count(distinct &timeIDvar) into :num_T
18576 +                from _emtstp_tmpDat
18577 +            ;
18578 +        quit;
18580 +        * data must be sorted before transposed;
18581 +        proc sort data=_emtstp_tmpDat;
18582 +            by _TSID_ &crossIDVar &timeIDvar;
18583 +        run;
18585 +        %do i = 1 %to &num_TSVar;
18586 +            %let i = &i;
18587 +            * transpose one cross-type time series data by TIMEID;
18588 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
18589 +                by _TSID_ &crossIDVar;
18590 +                var &&&TSVar&i;
18591 +            run;
18592 +        %end;
18594 +        * stack all horizontal time series;
18595 +        data &outDS;
18596 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
18597 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
18598 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
18599 +            %do i=1 %to &num_TSVar;
18600 +                if in&i then do;
18601 +                    _NAMEID_ ="&&&TSVar&i";
18602 +                    _ROLE_   ="&&&TSRole&i";
18603 +                end;
18604 +            %end;
18605 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
18606 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
18607 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
18608 +        run;
18609 +    %end;
18610 +%end;
18611 +%else %do;
18613 +    proc sql noprint;
18614 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
18615 +            order by _NAMEID_
18616 +        ;
18617 +    quit;
18619 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
18620 +        * transpose the panel-type time series data by TSID;
18621 +        proc sort data=&inDS out=_emtstp_tmpDat;
18622 +            by &timeIDvar;
18623 +        proc transpose data=_emtstp_tmpDat
18624 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
18625 +            by &timeIDVar;
18626 +            var &panelTSVar;
18627 +        run;
18628 +        proc datasets lib=work nolist;
18629 +            modify _emtstp_tmpDat2;
18630 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
18631 +            run; quit;
18632 +    %end;
18633 +    %else %do;
18634 +        * transpose the panel-type time series data by TIMEID;
18635 +        proc sort data=&inDS out=_emtstp_tmpDat;
18636 +            by &timeIDvar;
18637 +        data _emtstp_tmpDat;
18638 +            set _emtstp_tmpDat;
18639 +            _tmp_ind=_n_;
18640 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
18641 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
18642 +            ID _tmp_ind;
18643 +            var &panelTSVar;
18644 +        run;
18645 +    %end;
18647 +      * merge ID maps to the transpose data set;
18648 +      proc sql noprint;
18649 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
18650 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
18651 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
18652 +          ;
18653 +      quit;
18655 +      * update the TS ID map;
18656 +      data &outIDMap;
18657 +          set &inIDMap;
18658 +      run;
18659 +%end;
18661 +proc datasets lib=work nolist;
18662 +    delete _emtstp:;
18663 +run; quit;
18665 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_SCORE.SOURCE.
18667 +/*----------------------------------------------------------------------------------+
18668 + |
18669 + |   Title :  TS DP Score
18670 + |
18671 + |
18672 + |  Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
18673 + |
18674 + +-----------------------------------------------------------------------------------*/
18675 +%macro EM_TSDP_SCORE;
18677 +%if &EM_IMPORT_DATA ne  %then %do;
18678 +    %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
18679 +    %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
18680 +%end;
18681 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
18682 +    %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
18683 +    %let _FILE_CDELTA  = &EM_FILE_CDELTA_TRANSACTION;
18684 +%end;
18686 +%EM_GETNAME(KEY=OUTSEASON, TYPE=DATA);
18687 +%EM_GETNAME(KEY=TSMETA,    TYPE=DATA);
18688 +%EM_GETNAME(KEY=OUTDS,     TYPE=DATA);
18689 +%EM_GETNAME(KEY=TSIDMAP,   TYPE=DATA);
18691 +%let _seasonlength = ;
18692 +data &EM_USER_TSMETA;
18693 +    set &EM_USER_TSMETA;
18694 +    call symput('_seasonlength', userSeasonality);
18695 +run;
18697 +%if &EM_PROPERTY_EXPORTSEASONSTAT eq Y and &_seasonlength gt 1
18698 +%then %do;
18699 +    data  &_EXPORT_DATA;
18700 +        set &EM_USER_OUTSEASON;
18701 +        keep  _NAMEID_ _SEASON_ _TSID_ %EM_CROSSID
18702 +        %if  &EM_PROPERTY_SEASONSTAT eq ALL %then %do;
18703 +            SUM MAX MIN MEAN MEDIAN
18704 +        %end;
18705 +        %else %do;
18706 +            &EM_PROPERTY_SEASONSTAT
18707 +        %end;
18708 +        ;
18709 +    run;
18711 +    %if  &EM_PROPERTY_SEASONSTAT ne ALL %then %do;
18712 +        proc sort data =&_EXPORT_DATA out= &_EXPORT_DATA;
18713 +            by _TSID_ _NAMEID_ %EM_CROSSID  ;
18714 +        run;
18715 +        proc transpose data =&_EXPORT_DATA out= &_EXPORT_DATA prefix= SEASON ;
18716 +            by _TSID_ _NAMEID_ %EM_CROSSID  ;
18717 +        run;
18719 +        data &_EXPORT_DATA;
18720 +            set &_EXPORT_DATA;
18721 +            if _NAME_ ="_SEASON_" then delete;
18722 +            drop _NAME_ _LABEL_;
18723 +         run;
18724 +    %end;
18725 +%end;
18726 +%else %do;
18727 +    data  &_EXPORT_DATA;
18728 +        set &EM_USER_OUTDS;
18729 +    run;
18730 +%end;
18732 +data _null_;
18733 +    filename X "&_FILE_CDELTA";
18734 +    FILE X;
18735 +    put 'if upcase(NAME) eq "_TSID_"   then role="ID" ;' ;
18736 +    put 'if upcase(NAME) eq "_NAMEID_" then role="ID" ;' ;
18737 +    put 'if upcase(NAME) eq "_TSNAME_" then role="CROSSID" ;' ;
18738 +    put 'if upcase(NAME) eq "_TSVALUE_" then role="TARGET" ;' ;
18739 +    put 'if upcase(NAME) eq "_ROLE_"   then role="REJECTED" ;' ;
18740 +    %if &EM_PROPERTY_KEEPVARROLE eq Y %then %do;
18741 +       %if &EM_PROPERTY_TRANSBYVAR eq BYTSID %then %do;
18742 +           %let dsid=%sysfunc(open(&EM_USER_TSIDMAP(where=(strip(_ROLE_)="TARGET"))));
18743 +           %if &dsid > 0 %then %do;
18744 +               %let vn_nameid =%sysfunc(varnum(&dsid, _NAMEID_));
18745 +               %do %while(^%sysfunc(fetch(&dsid)));
18746 +                   %let _nameid  = %sysfunc(getvarc(&dsid, &vn_nameid));
18747 +                   put "if upcase(NAME) eq upcase(strip('&_nameid')) then role='TARGET' ;" ;
18748 +               %end;
18749 +               %let dsid = %sysfunc(close(&dsid));
18750 +           %end;
18751 +       %end;
18752 +    %end;
18753 +run;
18755 +%mend EM_TSDP_SCORE;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      16:140
NOTE: There were 1 observations read from the data set EMWS2.TSDP_TSMETA.
NOTE: The data set EMWS2.TSDP_TSMETA has 1 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_OUTDS.
NOTE: The data set EMWS2.TSDP_TRAIN has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file X is:
      Filename=C:\Users\Oscar\Documents\Document\File need to backup\UM\Y4S1\Data Mining and Warehousing\GroupAssignment\GroupAssignment_2023\Workspaces\EMWS2\TSDP\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=06Jan2024:00:17:43,
      Create Time=03Jan2024:16:50:54
 
NOTE: 5 records were written to the file X.
      The minimum record length was 46.
      The maximum record length was 52.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
18756
18757
18758  *------------------------------------------------------------*;
18759  * End SCORE: TSDP;
18760  *------------------------------------------------------------*;
 
18762  *------------------------------------------------------------*;
18763  * TSDP: Computing metadata for TRAIN data;
18764  *------------------------------------------------------------*;
 
*------------------------------------------------------------*
* Report Log
Date:                January 06, 2024
Time:                00:17:44
*------------------------------------------------------------*
19138  %let EMEXCEPTIONSTRING=;
19139  *------------------------------------------------------------*;
19140  * REPORT: TSDP;
19141  *------------------------------------------------------------*;
19142  %let EM_ACTION = REPORT;
19143  %let syscc = 0;
19144
19145  %macro EM_TSDP_MAIN;
19146
19147     filename temp catalog 'sashelp.emtsdm.tsdp_macros.source';
19148     %include temp;
19149     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
19150     %include temp;
19151     filename temp;
19152
19153     %if %upcase(&EM_ACTION) = CREATE %then %do;
19154         filename temp catalog 'sashelp.emtsdm.tsdp_create.source';
19155         %include temp;
19156         filename temp;
19157         %EM_TSDP_CREATE;
19158     %end;
19159     %else
19160     %if %upcase(&EM_ACTION) = TRAIN %then %do;
19161          filename temp catalog 'sashelp.emtsdm.tsdp_train.source';
19162             %include temp;
19163             filename temp;
19164         %EM_TSDP_TRAIN;
19165     %end;
19166     %else
19167     %if %upcase(&EM_ACTION) = SCORE %then %do;
19168          filename temp catalog 'sashelp.emtsdm.tsdp_score.source';
19169             %include temp;
19170             filename temp;
19171         %EM_TSDP_SCORE;
19172     %end;
19173     %else
19174     %if %upcase(&EM_ACTION) = REPORT %then %do;
19175             filename temp catalog 'sashelp.emtsdm.tsdp_report.source';
19176             %include temp;
19177             filename temp;
19178          %EM_TSDP_REPORT;
19179     %end;
19180     %else
19181       %if %upcase(&EM_ACTION) = OPENTIMETABLEACTION  %then %do;
19182             filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
19183             %include temp;
19184             filename temp;
19185          %EM_TSDP_OpenTimeTable ;
19186     %end;
19187     %else
19188     %if %upcase(&EM_ACTION) = CLOSETABLEACTION  %then %do;
19189            filename temp catalog 'sashelp.emtsdm.tsdp_actions.source';
19190             %include temp;
19191             filename temp;
19192          %EM_TSDP_closeTimeTable ;
19193     %end;
19194
19195  %mend EM_TSDP_MAIN;
19196  %EM_TSDP_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_MACROS.SOURCE.
19197 +/*----------------------------------------------------------------------------------+
19198 + |
19199 + |   Title :
19200 + |   TS Data Preparation Node for Time Series Data Mining
19201 + |
19202 + |   Support : Taiyeong Lee( Taiyeong.Lee@sas.com)
19203 + |
19204 + |   Notes:
19205 + |
19206 + |----------------------------------------------------------------------------------*/
19209 +%Macro EM_TSDP_Timeseries(
19210 +    /*--- input data set and variables ----*/
19211 +    inds            = ,
19212 +    crossid         = ,
19213 +    timeid          = ,
19215 +      /*--- time ID variable ----------------*/
19216 +    interval        = ,
19217 +    accumulation    = ,
19218 +    timeidfmttype   = ,
19219 +    timeidformat    = ,
19220 +    start           = ,
19221 +    end             = ,
19222 +    seasonlength    = ,
19224 +      /*--- transformation ------------------*/
19225 +    transform       = ,
19226 +    boxcoxpara      = ,
19228 +      /*--- differencing --------------------*/
19229 +    applydif        = ,
19230 +    dif             = ,
19231 +    applysdif       = ,
19232 +    sdif            = ,
19234 +      /*--- missing intepretation------------*/
19235 +    missing         = ,
19236 +    missingconstant = ,
19237 +    zeromiss        = ,
19239 +      /*--- output data sets ----------------*/
19240 +    outds           = ,
19241 +    outsum          = ,
19242 +    outseason       =
19243 +);
19245 +/*%if &interval eq Hour or &interval eq Minute or &interval eq Second
19246 +    or &EM_PROPERTY_TIMEOFDAY eq Y or &timeidfmttype eq DATETIME   */
19247 +%if &timeidfmttype eq DATETIME
19248 +%then %do;
19249 +    %let _dtTag=DT;
19250 +%end;
19251 +%else %if &timeidfmttype eq TIME
19252 +%then %do;
19253 +    %let _dtTag=T;
19254 +%end;
19255 +%else %do;
19256 +    %let _dtTag=D;
19257 +%end;
19259 +proc sort data=&inds(keep = &crossid &timeid %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED)
19260 +     out=_tmpinds;
19261 +     by &crossid &timeid;
19262 +run;
19264 +proc timeseries data=_tmpinds out=&outds
19265 +    %if "&crossid" eq " "
19266 +        %then %do; outsum=&outsum(rename=(_NAME_=_NAMEID_)) %end;
19267 +        %else %do; outsum=&outsum %end;
19268 +    %if &seasonlength gt 1
19269 +    %then %do;
19270 +        outseason = &outseason seasonality= &seasonlength
19271 +    %end;
19272 +    ;
19274 +    %if &seasonlength gt 1
19275 +    %then %do;
19276 +        season SUM MEAN MIN MAX MEDIAN;
19277 +    %end;
19279 +    %if &crossid ne  %then %do;
19280 +        by &crossid;
19281 +    %end;
19283 +    id &timeid
19284 +        interval   = &interval
19285 +        accumulate = &accumulation
19286 +        %if &missing eq CONSTANT %then %do;
19287 +            setmissing = &missingconstant
19288 +        %end;
19289 +        %else %do;
19290 +            setmissing = &missing
19291 +        %end;
19292 +        %if &zeromiss ne NONE  %then %do;
19293 +            zeromiss = &zeromiss
19294 +        %end;
19295 +        %if &start ne  %then %do;
19296 +            %let  _start = "&start" ;
19297 +            start = &_start.&_dtTag
19298 +        %end;
19299 +        %if &end ne  %then %do;
19300 +            %let  _end = "&end";
19301 +            end = &_end.&_dtTag
19302 +        %end;
19303 +    ;
19305 +    var %EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED /
19306 +        %if &zeromiss ne NONE  %then %do;
19307 +            zeromiss = &zeromiss
19308 +        %end;
19309 +        %if &transform ne NONE  %then %do;
19310 +            %if &transform eq BOXCOX  %then %do;
19311 +                transform = BOXCOX(&boxcoxpara)
19312 +            %end;
19313 +            %else %do;
19314 +                transform = &transform
19315 +            %end;
19316 +        %end;
19317 +        %if &applydif eq Y  %then %do;
19318 +            dif = (&dif)
19319 +        %end;
19320 +        %if &applysdif eq Y %then %do;
19321 +            sdif = (&sdif)
19322 +        %end;
19323 +    ;
19324 +run;
19325 +quit;
19327 +%mend EM_TSDP_TimeSeries;
19330 +/*-----------------------------------------------------------------
19332 +    MERGE AFTER CLUSTERING
19334 ++------------------------------------------------------------------*/
19336 +%macro EM_TSDP_MergeAfterClustering();
19338 +/*--- need to fix the code based on data Role (train or transaction) ---*/
19340 +%EM_REGISTER(KEY=CLUSTS, TYPE=DATA);
19341 +%EM_GETNAME(KEY=CLUSTS, TYPE=DATA);
19343 +%let _train = ;
19344 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19345 +%if &dsid > 0 %then %do;
19346 + %let vn_data =%sysfunc(varnum(&dsid, DATA));
19347 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19348 +%do %while(^ %sysfunc(fetch(&dsid)));
19349 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19350 +     %if &_key eq TSDRTRAIN %then %do;
19351 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
19352 +     %end;
19353 +     %else %if &_key eq TSDCTRAIN %then %do;
19354 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
19355 +     %end;
19356 +     %else %if &_key eq TSDPTRAINDS %then %do;
19357 +          %let _train  = %sysfunc(getvarc(&dsid, &vn_data));
19358 +     %end;
19359 +%end;
19360 +%end;
19361 +%let dsid = %sysfunc(close(&dsid));
19363 +proc sort data =&_train out=_inds;
19364 +     by %EM_CROSSID;
19365 +run;
19366 +proc sort data=&EM_IMPORT_DATA out=_outclus(KEEP= %EM_CROSSID _SEGMENT_);
19367 +      by %EM_CROSSID;
19368 +run;
19369 +data &EM_USER_CLUSTS;
19370 +     merge _inds _outclus;
19371 +     by %EM_CROSSID;
19372 +run;
19374 +proc sort data =&EM_USER_TSIDMAP;
19375 +     by %EM_CROSSID;
19376 +run;
19378 +data &EM_USER_TSIDMAP;
19379 +     merge &EM_USER_TSIDMAP _outclus;
19380 +     by %EM_CROSSID;
19381 +run;
19383 +data &EM_USER_CLUSTS ;
19384 +    merge  &EM_USER_TSIDMAP &EM_USER_CLUSTS;
19385 +     by %EM_CROSSID;
19386 +run;
19387 +quit;
19389 +%mend EM_TSDP_MergeAfterClustering;
19391 +%macro EM_TSDP_MergeTSID(inds=, tsidds=, byvar=, outds=);
19393 +    proc sort data =&inds out=_tmp_inds;
19394 +        by &byvar;
19395 +    proc sort data=&tsidds out=_tmp_tsidds;
19396 +        by &byvar;
19397 +    run;
19398 +    %if &outds eq %then %do;
19399 +        data &inds;
19400 +    %end;
19401 +    %else %do;
19402 +        data &outds;
19403 +    %end;
19404 +            merge _tmp_tsidds _tmp_inds;
19405 +            by &byvar;
19406 +        run;
19408 +    %EM_TS_DELETE_DATA(dsname=_tmp_inds);
19409 +    %EM_TS_DELETE_DATA(dsname=_tmp_tsidds);
19411 +%mend EM_TSDP_MergeTSID;
19413 +%macro EM_TS_SummaryDS(inDS=, crossid=);
19414 +    %let j=1;
19415 +    %do %while(%scan(&crossid, &j) ne );
19416 +        %let _csvar=%scan(&crossid, &j);
19417 +        %EM_REGISTER(KEY=OUTSUM&j, TYPE=DATA);
19418 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
19419 +        %EM_TS_SummaryByCSID(inDS=&inDS, outDS=&EM_USER_OUTSUM&j,crossIDVar=&_csvar);
19420 +        %let j=%eval(&j+1);
19421 +    %end;
19422 +%mend EM_TS_SummaryDS;
19425 +%macro EM_TS_SummaryByCSID(inDS=, outDS=, RoleVar=_role_, TSVar=_varname_, crossIDVar=);
19426 +    proc sql noprint;
19427 +        create table &outDS as
19428 +            select distinct &RoleVar, &TSVar, &crossIDVAr,
19429 +                mean(mean1)  as mean      label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmean, noquote))",
19430 +                std(mean1)   as std_mean  label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smean, noquote))",
19431 +                mean(sum1)   as sum       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_msum, noquote))",
19432 +                std(sum1)    as std_sum   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_ssum, noquote))",
19433 +                mean(min1)   as min       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmin, noquote))",
19434 +                std(min1)    as std_min   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smin, noquote))",
19435 +                mean(max1)   as max       label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_mmax, noquote))",
19436 +                std(max1)    as std_max   label="%sysfunc(sasmsg(sashelp.dmine,rpt_timeseries_label_smax, noquote))"
19437 +            from &inDS(rename=(mean=mean1 sum=sum1 min=min1 max=max1))
19438 +                group by &TSVar, &crossIDVar
19439 +                order by &TSVar, &crossIDVar
19440 +        ;
19441 +    quit;
19442 +%mend;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
19443 +/*
19444 +       MACRO: TS Utility macros
19446 +       PURPOSE: TS Utility macros
19447 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
19449 +       HISTORY:
19450 +       NOTE:
19452 +*/
19454 +/*
19455 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
19456 +                          timeid=, timeformat=, timeinformat=);
19457 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
19459 +    %do;
19460 +    %let m_data      = &data;
19461 +    %let m_decdata   = &decdata;
19462 +    %let m_decmeta   = &decmeta;
19463 +    %let m_cmeta     = &cmeta;
19464 +    %let m_outfile   = &outfile;
19465 +    %let m_crossid   = &crossid;
19466 +    %let m_timeid    = &timeid;
19467 +    %let m_timeformat    = &timeformat;
19468 +    %let m_timeinformat    = &timeinformat;
19469 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
19470 +  %end;
19471 +%mend EM_TS_CreateTsMetaDs;
19472 +*/
19473 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
19474 +proc sql;
19475 +      create table _tmp_inds
19476 +      as select distinct &timeid from  &indata;
19477 +quit;
19478 +run;
19479 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
19480 +  id &timeid
19481 +%if &timeinterval ne %then %do;
19482 +    %if &timeformattype eq DATE %then %do;
19483 +        interval=&timeinterval
19484 +    %end;
19485 +    %else %if &timeformattype eq DATETIME  %then %do;
19486 +        %let dttimeinterval= DT&timeinterval;
19487 +         interval=&dttimeinterval
19488 +    %end;
19489 +%end;
19490 +;
19491 +run;
19493 +data &outds;
19494 +     set _tmp_tsmeta;
19495 +     format START &timeformat;
19496 +     format END &timeformat;
19497 +     length APPLY_START_END $8;
19498 +     APPLY_START_END ="No";
19499 +     FORMAT = "&timeformat";
19500 +     ROLE ="TIMEID";
19501 +     rename TIMEID = NAME;
19502 +     rename SEASONALITY= LengthOfCycle;
19503 +     rename INTERVAL = TIMEINTERVAL ;
19504 +     rename FORMAT = TIMEFORMAT;
19505 +     output;
19506 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
19507 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
19508 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
19509 +run;
19511 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
19512 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
19514 +%mend EM_TS_CreateTSMetaData;
19518 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
19520 +/* if updated = Y it will pass the TSMETA created by just the previous node */
19522 +%let _tsmetads = ;
19524 +%if &updated = Y %then %do;
19525 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
19526 +%if %sysfunc(exist(&_tsmetads)) %then %do;
19527 +%goto endline;
19528 +%end;
19529 +%end;
19531 +%if &eminfodata eq %then %do;
19532 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19533 +    data &EM_DATA_EMINFO;
19534 +         set &EM_IMPORT_DATA_EMINFO;
19535 +    run;
19536 +%end;
19537 +%else %do;
19538 +    %let dsid=%sysfunc(open(&eminfodata));
19539 +    data &EM_DATA_EMINFO;
19540 +         set &eminfodata;
19541 +    run;
19542 +%end;
19543 +%if &dsid > 0 %then %do;
19544 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
19545 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
19546 +    %do %while(^ %sysfunc(fetch(&dsid)));
19547 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19548 +         %if &_key eq TSMETA %then %do;
19549 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
19550 +         %end;
19551 +    %end;
19552 +    %let dsid = %sysfunc(close(&dsid));
19553 +%end; /* the end of %if &dsid > 0 %then %do; */
19555 +%endline:
19557 +%if &_tsmetads ne %then %do;
19558 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
19559 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19560 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
19561 +         data &EM_USER_TSMETA;
19562 +                   set &_tsmetads;
19563 +         run;
19564 +    %end;
19565 +%end;
19567 +*proc print data=&EM_DATA_EMINFO;
19568 +*proc print data=&EM_IMPORT_DATA_EMINFO;
19569 +*run;
19570 +%MEND EM_TS_GETTSMETA;
19573 +/*
19574 +%macro EM_GETTSMETAVARS(TimeInterval=);
19575 +%global &TimeInterval;
19576 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19577 +%if &dsid > 0 %then %do;
19578 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19579 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
19580 +%do %while(^ %sysfunc(fetch(&dsid)));
19581 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19582 +     %if &_role eq TIMEID %then %do;
19583 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19584 +     %end;
19585 +%end;
19586 +%let dsid = %sysfunc(close(&dsid));
19587 +%end;
19588 +%MEND EM_GETTSMETAVARS;
19589 +*/
19590 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
19591 +%global &TimeInterval;
19592 +%global &TimeId;
19593 +%global &EndTime;
19594 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19595 +proc print data=&EM_USER_TSMETA;
19596 +run;
19597 +%if &dsid > 0 %then %do;
19598 +%if &TimeInterval ne %then %do;
19599 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19600 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19601 +    %do %while(^ %sysfunc(fetch(&dsid)));
19602 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19603 +        %if &_role eq TIMEID %then %do;
19604 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19605 +        %end;
19606 +     %end;
19607 +%end;
19608 +%if &TimeId ne %then %do;
19609 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
19610 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19611 +    %do %while(^ %sysfunc(fetch(&dsid)));
19612 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19613 +        %if &_role eq TIMEID %then %do;
19614 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
19615 +        %end;
19616 +    %end;
19617 +%end;
19619 +%if &EndTime ne %then %do;
19620 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19621 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19622 +    %do %while(^ %sysfunc(fetch(&dsid)));
19623 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19624 +        %if &_role eq TIMEID %then %do;
19625 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19626 +        %end;
19627 +     %end;
19628 +%end;
19629 +%let dsid = %sysfunc(close(&dsid));
19630 +%end;
19631 +%MEND EM_TS_GETTSMETAVARS;
19635 +/*------------------------------------------------------------------
19637 +      Macro EM_GETTSIDMAP
19639 +------------------------------------------------------------------+*/
19642 +%macro EM_TS_GETTSIDMAP(updated=);
19644 +%let _tsidmap = ;
19646 +%if &updated = Y %then %do;
19647 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
19648 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19649 +%goto endline;
19650 +%end;
19651 +%end;
19653 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19654 +%if &dsid > 0 %then %do;
19655 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
19656 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19657 +%do %while(^ %sysfunc(fetch(&dsid)));
19658 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19659 +     %if &_key eq TSIDMAP %then %do;
19660 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
19661 +     %end;
19662 +%end;
19664 +%let dsid = %sysfunc(close(&dsid));
19665 +%end;
19667 +%endline:
19669 +%if &_tsidmap ne %then %do;
19671 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
19672 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19674 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19675 +         data &EM_USER_TSIDMAP;
19676 +               set &_tsidmap;
19677 +         run;
19678 +    %end;
19679 +%end;
19680 +%MEND EM_TS_GETTSIDMAP;
19682 +/*------------------------------------------------------------------*/
19687 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
19688 +%global &value;
19691 +%let dsid = %sysfunc(open(&data));
19692 +%if &dsid > 0 %then %do;
19693 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
19694 +    %if &vn_var < 1 %then %do;
19695 +        %let &value = 0;
19696 +        %let dsid = %sysfunc(close(&dsid));
19697 +        %goto endline;
19698 +    %end;
19699 +%let dsid = %sysfunc(close(&dsid));
19700 +%end;
19702 +%let _tmp=_tmpDS;
19703 +proc means data=&data &stat;
19704 +     var &var;
19705 +     output out=&_tmp;
19706 +run;
19708 +%let dsid = %sysfunc(open(&_tmp));
19709 +%if &dsid > 0 %then %do;
19710 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
19711 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
19712 +     %do %while(^%sysfunc(fetch(&dsid)));
19713 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
19714 +         %if &_stat eq &stat %then %do;
19715 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
19716 +          %end;
19717 +      %end;
19718 +%let dsid = %sysfunc(close(&dsid));
19719 +%end;
19720 +proc datasets lib=work nolist;
19721 + delete &_tmp;
19722 +run;
19723 +%endline:
19724 +%MEND EM_TS_GET_STAT;
19727 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
19728 +%global &format;
19729 +%global &informat;
19730 +%let dsid = %sysfunc(open(&data));
19731 +%if &dsid > 0 %then %do;
19732 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19733 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
19734 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
19735 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
19736 +%end;
19737 +%let dsid = %sysfunc(close(&dsid));
19738 +%end;
19739 +%MEND EM_TS_GET_VAR_FORMAT;
19741 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
19742 +      %if &lib eq %then %let lib=work;
19743 +       proc datasets lib=&lib nolist;
19744 +              delete &dsname;
19745 +       run;
19746 +%Mend  EM_TS_DELETE_DATA;
19749 +%macro EM_TS_GetNObs(inds=, nobs=);
19750 +    %global &nobs;
19751 +    %let &nobs=0;
19752 +    data _null_;
19753 +        set &inds end=eof;
19754 +        if eof then call symput("&nobs", _N_);
19755 +    run;
19756 +    quit;
19758 +    /*
19759 +    %let dsid=%sysfunc(open(&outdata));
19760 +    %if dsid > 0 %then %do;
19761 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
19762 +        %let dsid = %sysfunc(close(&dsid));
19763 +     %end;
19764 +    */
19765 +%mend  EM_TS_GetNObs;
19768 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
19769 +%global &time1;
19770 +%global &time2;
19771 +%if &default = Y %then %do;
19772 +   data _null_;
19773 +        set &data end=eof;
19774 +        if _N_ = 1 then  call symput("&time1", DATE);
19775 +        if eof then call symput("&time2", DATE);
19776 +    run;%end;
19777 +%else %do;
19778 +    %let dsid = %sysfunc(open(&data));
19779 +    %if &dsid > 0 %then %do;
19780 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
19781 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
19782 +        %do %while(^%sysfunc(fetch(&dsid)));
19783 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
19784 +             %if &_index eq 1 %then %do;
19785 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
19786 +             %end;
19787 +             %if &_index eq 2 %then %do;
19788 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
19789 +             %end;
19790 +        %end;
19791 +    %let dsid = %sysfunc(close(&dsid));
19792 +    %end;
19793 +%end;
19795 +%MEND EM_TS_GET_TIME_VALUES;
19797 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
19798 +%global &exist;
19799 + %let &exist = N;
19800 +%let dsid = %sysfunc(open(&data));
19801 +%if &dsid > 0 %then %do;
19802 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19803 +%if &vn_var > 0 %then %do;
19804 +    %let &exist = Y;
19805 +%end;
19806 +%let dsid = %sysfunc(close(&dsid));
19807 +%end;
19808 +%MEND EM_TS_GET_VAR_EXIST;
19811 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
19812 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
19813 +      set &intreedata;
19814 +        LENGTH NodeType $32;
19815 +      if _PARENT_ eq " " then delete;
19816 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
19817 +        else NodeType = "CLUSTER";
19818 +        LinkID = _N_;
19819 +run;
19820 +%Mend EM_TS_MakeConstellPlotData;
19825 +%macro EM_TS_CreateIDMap(
19826 +/*-------------------------------------------------------------------------*/
19827 +/*---   Written by Xiangxiang Meng                                         */
19828 +/*-------------------------------------------------------------------------*/
19829 +inDS          =,      /* imported data set in TS data mining               */
19830 +outIDMap      =,      /* output data set of TS ID map                      */
19831 +outDS         =,      /* output data set of TS and TS ID merged            */
19832 +variableSet   =,      /* EM variable set                                   */
19833 +TSIDbyCrossID =Y,
19834 +inEM          =Y
19835 +/*-------------------------------------------------------------------------*/
19836 +);
19838 +%global EM_TS_ERR;
19839 +%let EM_TS_ERR = 0;
19841 +%if &inEM eq Y %then %do;
19842 +    %let num_crossIDVar = &EM_NUM_CROSSID;
19843 +    proc sql noprint;
19844 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
19845 +    quit;
19846 +%end;
19847 +%else %do;
19848 +    proc sql noprint;
19849 +         select count(*) into :num_crossIDVar from &variableSet
19850 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19851 +         ;
19852 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
19853 +         ;
19854 +    quit;
19855 +    %let num_crossIDVar=&num_crossIDVar;
19856 +%end;
19858 +* see if _TSID_ exists;
19860 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
19861 +run;
19863 +proc sql noprint;
19864 +    select count(*) into :has_TSID
19865 +        from _emtscm_contents
19866 +        where upcase(strip(name)) eq '_TSID_'
19867 +    ;
19868 +quit;
19870 +/*-------------------------------------------------------------------------*/
19871 +* Creating TSID map..;
19872 +/*-------------------------------------------------------------------------*/
19874 +%if (&num_crossIDVar gt 0) %then %do;
19876 +    data _emtscm_tmpIDMap;
19877 +        set &variableSet;
19878 +        where  (upcase(strip(level)) eq 'INTERVAL')
19879 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19880 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19881 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19882 +          );
19883 +        _emts_dummy=1;
19884 +        keep name label role _emts_dummy;
19885 +    run;
19887 +    proc sql noprint;
19888 +        * create a string of crossID variable like A,B,C,D..;
19889 +        select distinct name into :crossIDVar separated by ','
19890 +            from &variableSet
19891 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19892 +            order by name
19893 +        ;
19894 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
19895 +            from &variableSet
19896 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19897 +            order by name
19898 +        ;
19899 +        * create the TSID map data set;
19900 +        create table _emtscm_tmp1 as
19901 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
19902 +        ;
19903 +        * create a level list of cross ID variables and time series variables;
19904 +        create table &outIDMap as
19905 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
19906 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
19907 +            where a._emts_dummy eq b._emts_dummy
19908 +            order by a.name, &crossIDVar
19909 +        ;
19910 +    quit;
19912 +    %if &TSIDbyCrossID = Y %then %do;
19913 +        * create unique TSID only by Cross ID;
19914 +        data &outIDMap;
19915 +            length _TSID_ 8;
19916 +            set &outIDMap;
19917 +            by _NAMEID_;
19918 +            if first._NAMEID_
19919 +                then _TSID_=1;
19920 +                else _TSID_+1;
19921 +        run;
19922 +        %if "&outDS" ne "" %then %do;
19923 +            * merge TSID into &inDS;
19924 +            proc sql noprint;
19925 +                create table &outDS as
19926 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
19927 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
19928 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
19929 +                        where %do i = 1 %to &num_crossIDVar;
19930 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
19931 +                              %end;
19932 +                             b._TSID_ is not missing
19933 +                    order by b._TSID_, a.&timeIDVar
19934 +                ;
19935 +            quit;
19936 +        %end;
19937 +    %end;
19938 +    %else %do;
19939 +        * create unique TSID by Cross ID and _NAMEID_;
19940 +        data &outIDMap;
19941 +            length _TSID_ 8;
19942 +            set &outIDMap;
19943 +            _TSID_=_n_;
19944 +        run;
19945 +        %if "&outDS" ne "" %then %do;
19946 +            *no merge in this output;
19947 +            data &outDS;
19948 +                set &inDS;
19949 +            run;
19950 +        %end;
19951 +    %end;
19953 +    proc sort data=&outIDMap;
19954 +        by _NAMEID_ _TSID_;
19955 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
19956 +        format _TSID_ best12. _NAMEID2_ $40.;
19957 +        set &outIDMap;
19958 +        by _NAMEID_;
19959 +        if first._NAMEID_
19960 +            then _emts_ind=1;
19961 +            else _emts_ind+1;
19962 +        drop _emts_ind;
19963 +        rename _NAMEID_=_VARNAME_;
19964 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
19965 +        if _labelID_ eq ' '
19966 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
19967 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
19968 +    run;
19970 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
19972 +%end;
19973 +%else %do; /* if no crossid's the nameid needs to be created */
19975 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
19976 +        length _TSID_ 8;
19977 +        set &variableSet;
19978 +        where  (upcase(strip(level)) eq 'INTERVAL')
19979 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19980 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19981 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19982 +          );
19983 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
19984 +        rename ROLE = _ROLE_;
19985 +        _NAMEID_=strip(name);
19986 +        _VARNAME_=strip(name);
19987 +        if label eq ' '
19988 +            then _LABELID_ = strip(name);
19989 +            else _LABELID_ = strip(label);
19990 +        _TSID_=_n_;
19991 +    run;
19993 +    %if "&outDS" ne "" %then %do;
19994 +        *no merge in this output;
19995 +        data &outDS;
19996 +            set &inDS;
19997 +        run;
19998 +    %end;
19999 +%end;
20001 +data &outIDMap;
20002 +    set &outIDMap;
20003 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
20004 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
20005 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
20006 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
20007 +run;
20009 +proc datasets lib=work nolist;
20010 +    delete _emtscm_:;
20011 +run; quit;
20013 +%mend EM_TS_createIDMap;
20015 +%macro EM_TS_CreateMetaData(
20016 +/*-------------------------------------------------------------------------*/
20017 +  inDS          =,      /* imported data set in TS data mining             */
20018 +  outDS         =,      /* output data set of TS metadata                  */
20019 +  variableSet   =,      /* EM variable set                                 */
20020 +  timeInterval  =,      /* time interval                                   */
20021 +  rc            =       /* return code                                     */
20022 +/*-------------------------------------------------------------------------*/
20023 +);
20025 +%if %eval(
20026 +      &EM_NUM_BINARY_INPUT   +
20027 +      &EM_NUM_ORDINAL_INPUT  +
20028 +      &EM_NUM_NOMINAL_INPUT  +
20029 +      &EM_NUM_BINARY_REJECTED   +
20030 +      &EM_NUM_ORDINAL_REJECTED  +
20031 +      &EM_NUM_NOMINAL_REJECTED  +
20032 +      &EM_NUM_ORDINAL_TARGET  +
20033 +      &EM_NUM_NOMINAL_TARGET +
20034 +      &EM_NUM_BINARY_TARGET
20035 +      ) > 0
20036 +%then %do;
20037 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
20038 +        %put &em_codebar;
20039 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
20040 +        %put &errormsg;
20041 +        %put &em_codebar;
20042 +        %goto ENDLINE;
20043 +%end;
20045 +%global EM_TS_ERR;
20046 +%let EM_TS_ERR = 0;
20048 +%if &timeInterval eq AUTO
20049 +    %then %let timeInterval  = ;
20050 +    %else %let timeInterval  = %upcase(&timeInterval);
20052 +/*-------------------------------------------------------------------------*/
20053 +* check time ID variable;
20054 +/*-------------------------------------------------------------------------*/
20056 +* number of variables in the Variableset with ROLE=TIMEID;
20057 +proc sql noprint;
20058 +    select count(*) into :num_timeID from &variableset
20059 +        where upcase(role) eq 'TIMEID';
20060 +quit;
20062 +/*-------------------------------------------------------------------------*/
20063 +* process only when there is one Time ID, otherwise exception message;
20064 +/*-------------------------------------------------------------------------*/
20066 +%if &num_timeID eq 0 %then %do;
20068 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
20069 +    %let EM_TS_ERR = 11;
20070 +    %put &em_codebar;
20071 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
20072 +    %put &errormsg;
20073 +    %put &em_codebar;
20074 +    %goto tscm_endline;
20076 +%end;
20077 +%else %if &num_timeID gt 1 %then %do;
20079 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
20080 +    %let EM_TS_ERR = 12;
20081 +    %put &em_codebar;
20082 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
20083 +    %put &errormsg;
20084 +    %put &em_codebar;
20085 +    %goto tscm_endline;
20087 +%end;
20088 +%else %do;
20089 +    *** proceed when there is one Time ID;
20091 +    data _null_;
20092 +        set &variableset(where=(upcase(role)='TIMEID'));
20093 +        call symput('timeIDFormat',     strip(format));
20094 +        call symput('timeID',           strip(upcase(name)      ));
20095 +        call symput('timeIDLevel',      strip(upcase(level))     );
20096 +        call symput('timeIDFormatType', strip(upcase(formattype)));
20097 +    run;
20099 +    *** exception message if the time ID is not an interval variable;
20100 +    %if &timeIDLevel ne INTERVAL %then %do;
20101 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
20102 +        %let EM_TS_ERR = 13;
20103 +        %put &em_codebar;
20104 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
20105 +        %put &errormsg;
20106 +        %put &em_codebar;
20107 +        %goto tscm_endline;
20108 +    %end;
20110 +    %if (&timeIDFormatType ne DATETIME) and
20111 +        (&timeIDFormatType ne DATE) and
20112 +        (&timeIDFormatType ne TIME) and
20113 +        (&timeIDFormatType ne USER)
20114 +    %then %do;
20115 +        *** sequential format-type of time ID;
20117 +        %let timeInterval = DAY;
20118 +        %let timeIDFormatType = SEQ;
20120 +        proc sql noprint;
20121 +            create table _emtscm_inds as
20122 +                 select distinct &timeID from &inDS(keep=&timeID)
20123 +                 where &timeID is not missing;
20124 +            select count(*) into :num_nonInteger from _emtscm_inds
20125 +                where &timeID ne int(&timeID);
20126 +        quit;
20128 +        %if &num_nonInteger gt 0 %then %do;
20129 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
20130 +            %let EM_TS_ERR = 14;
20131 +            %put &em_codebar;
20132 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
20133 +            %put &errormsg;
20134 +            %put &em_codebar;
20135 +            %goto tscm_endline;
20136 +        %end;
20137 +    %end;
20138 +    %else %do;
20139 +        *** date, datetime, time format-type of time ID;
20141 +        *** must have a format;
20142 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
20143 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
20144 +            %let EM_TS_ERR = 15;
20145 +            %put &em_codebar;
20146 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
20147 +            %put &errormsg;
20148 +            %put &em_codebar;
20149 +            %goto tscm_endline;
20150 +        %end;
20152 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
20153 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
20154 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
20155 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
20156 +                %let EM_TS_ERR = 16;
20157 +                %put &em_codebar;
20158 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
20159 +                %put &errormsg;
20160 +                %put &em_codebar;
20161 +                %goto tscm_endline;
20162 +            %end;
20163 +        %end;
20165 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
20166 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
20167 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
20168 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
20169 +                %let EM_TS_ERR = 17;
20170 +                %put &em_codebar;
20171 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
20172 +                %put &errormsg;
20173 +                %put &em_codebar;
20174 +                %goto tscm_endline;
20175 +            %end;
20176 +        %end;
20178 +        *** the AUTO function is currently turned off for TIME timeID variable;
20179 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
20180 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
20181 +            %let EM_TS_ERR = 18;
20182 +            %put &em_codebar;
20183 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
20184 +            %put &errormsg;
20185 +            %put &em_codebar;
20186 +            %goto tscm_endline;
20187 +        %end;
20189 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
20190 +            %then %let timeInterval =DT&timeInterval;
20192 +        proc sql noprint;
20193 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
20194 +                where &timeID is not missing;
20195 +        quit;
20196 +    %end;
20198 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
20199 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
20200 +    run;
20202 +    %let hasValidInterval = 0;
20203 +    %let hasLengthOne     = 0;
20205 +    proc sql noprint;
20206 +        create table _emtscm_label as
20207 +            select name,label
20208 +            from dictionary.columns
20209 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
20210 +        ;
20211 +        create table _emtscm_meta2 as
20212 +            select a.*, b.label
20213 +            from _emtscm_meta as a, _emtscm_label as b
20214 +            where upcase(a.timeID) eq upcase(b.name)
20215 +        ;
20216 +    quit;
20218 +    data &outDS;
20219 +        set _emtscm_meta2;
20220 +        format
20221 +            timeformat      $30.
20222 +            role            $10.
20223 +            start           &timeIDformat
20224 +            end             &timeIDformat
20225 +            apply_start_end $8.
20226 +        ;
20227 +        rename
20228 +            timeID      = name
20229 +            seasonality = lengthOfCycle
20230 +            interval    = timeinterval
20231 +        ;
20232 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
20234 +        role            = "TIMEID";
20235 +        apply_start_end = 'N';
20236 +        timeformat      = symget('timeIDformat');
20237 +        timeformattype  = symget('timeIDformatType');
20239 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
20240 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
20241 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
20242 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
20243 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
20244 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
20245 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
20246 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
20247 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
20248 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
20250 +        if timeformattype eq 'SEQ' then do;
20251 +            timeformat='BEST12.';
20252 +            seasonality=1;
20253 +        end;
20255 +        call symput('_tinterval',interval);
20257 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
20259 +        if upcase(timeformattype) eq 'DATE' and
20260 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
20261 +            then call symput('hasValidInterval',1);
20263 +        if upcase(timeformattype) eq 'DATETIME' and
20264 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
20265 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
20266 +            then call symput('hasValidInterval',1);
20268 +        if upcase(timeformattype) eq 'TIME' and
20269 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
20270 +            then call symput('hasValidInterval',1);
20272 +        if upcase(timeformattype) eq 'SEQ'
20273 +            then call symput('hasValidInterval',1);
20275 +        if upcase(timeformattype) eq 'USER'
20276 +            then call symput('hasValidInterval',1);
20278 +        if start eq end
20279 +            then call symput('hasLengthOne',1);
20280 +    run;
20282 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
20284 +    *** detect any missing time interval after running PROC TIMEID;
20285 +    %if &_tinterval eq %then %do;
20286 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
20287 +        %let EM_TS_ERR = 19;
20288 +        %put &em_codebar;
20289 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
20290 +        %put &errormsg;
20291 +        %put &em_codebar;
20292 +        %goto tscm_endline;
20293 +    %end;
20295 +    *** detect any missing time interval after running PROC TIMEID;
20296 +    %if &hasValidInterval eq 0 %then %do;
20297 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
20298 +        %let EM_TS_ERR = 20;
20299 +        %put &em_codebar;
20300 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
20301 +        %put &errormsg;
20302 +        %put &em_codebar;
20303 +        %goto tscm_endline;
20304 +    %end;
20306 +    %if &hasLengthOne eq 1 %then %do;
20307 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
20308 +        %let EM_TS_ERR = 21;
20309 +        %put &em_codebar;
20310 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
20311 +        %put &errormsg;
20312 +        %put &em_codebar;
20313 +        %goto tscm_endline;
20314 +    %end;
20316 +%end;
20318 +%tscm_endline:;
20320 +%mend EM_TS_CreateMetaData;
20323 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
20325 +data _null_;
20326 +    set &tsmeta;
20327 +    call symput('_timeidFormatType', timeformattype);
20328 +    call symput('_timeid', strip(name));
20329 +    call symput('_seqstartnum',strip(put(start,best12.)));
20330 +run;
20332 +proc contents data=&inDS noprint
20333 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20334 +run; quit;
20336 +data _null_;
20337 +    set _emts_tmpp1;
20338 +    call symput('_timeIDlabel',label);
20339 +run;
20341 +%if &_timeidFormatType eq SEQ
20342 +%then %do;
20343 +    proc sql noprint;
20344 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
20345 +    quit;
20346 +    %let _dummystarttime=&_dummystarttime;
20348 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20349 +        set &inDS;
20350 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
20351 +        drop &_timeid;
20352 +        label _tsdp_tmpID = "&_timeIDlabel";
20354 +    run;
20355 +%end;
20357 +%mend;
20359 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
20361 +data _null_;
20362 +    set &tsmeta;
20363 +    call symput('_timeidFormatType', timeformattype);
20364 +    call symput('_timeidFormat', timeformat);
20365 +    call symput('_timeid', strip(name));
20366 +    call symput('_timeinterval',strip(upcase(timeinterval)));
20367 +run;
20369 +/* manually change time ID format to a longer enough time format */
20370 +/* because proc timeid returns time5. for second time interval */
20371 +/* which is not long enough for transpose with time unit as seconds */
20372 +%if &_timeinterval eq SECOND
20373 +%then %do;
20374 +    %let _timeIDformat = %str(time8.);
20375 +%end;
20377 +proc contents data=&inDS noprint
20378 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20379 +run; quit;
20381 +data _null_;
20382 +    set _emts_tmpp1;
20383 +    call symput('_timeIDlabel',label);
20384 +run;
20386 +%if &_timeidFormatType eq TIME
20387 +%then %do;
20388 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20389 +        set &inDS;
20390 +        _tsdp_tmpID = timepart(&_timeID);
20391 +        format _tsdp_tmpID &_timeidFormat;
20392 +        label  _tsdp_tmpID = "&_timeIDlabel";
20393 +        drop &_timeid;
20394 +    run;
20395 +%end;
20397 +%mend;
20399 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
20401 + proc sql noprint;
20402 +     create table _tmptimetable as
20403 +         select distinct &timeidvar as DATE from &inDS
20404 +         where &timeIDVar is not missing
20405 +         order by &timeIDVar;
20406 + quit;
20408 +%if &compare eq Y %then %do;
20409 +    * compare with the existing time table;
20410 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
20411 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
20412 +    run;
20414 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
20416 +    %if &_diffobs > 0 %then %do; /* create it again */
20417 +        data &outDS(keep=DATE _INDEX_);
20418 +            set _tmptimetable end = _eof_;
20419 +            if _N_ = 1
20420 +                then _INDEX_ = 1;
20421 +                else _INDEX_ = 0;
20422 +            if _eof_ then _INDEX_= 2;
20423 +        run;
20424 +    %end;
20426 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
20427 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20428 +%end;
20429 +%else %do;
20430 +    * create a new time table directly;
20431 +    data &outDS(keep=DATE _INDEX_);
20432 +        set _tmptimetable end = _eof_;
20433 +        if _N_ = 1
20434 +            then _INDEX_ = 1;
20435 +            else _INDEX_ = 0;
20436 +        if _eof_ then _INDEX_= 2;
20437 +    run;
20439 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20440 +%end;
20442 +* assign a defult format BEST12. for sequential time ID;
20444 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
20446 +%let _nodatefmt=N;
20448 +data _null_;
20449 +    set _tmpcontents;
20450 +    where upcase(name) eq 'DATE';
20451 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
20452 +run;
20454 +%if "&_nodatefmt" eq "Y" %then %do;
20455 +    data &outDS;
20456 +        set &outDS;
20457 +        format date best12.;
20458 +    run;
20459 +%end;
20461 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
20463 +%mend;
20467 +%macro EM_TS_Transpose(
20468 +/*-------------------------------------------------------------------------*/
20469 +  inDS          =,      /* imported data set in TS data mining             */
20470 +  inIDMap       =,      /* input TS ID map                                 */
20471 +  variableSet   =,      /* variable set                                    */
20472 +  transposeBy   =,      /* byTSID or byTimeID                              */
20473 +  outDS         =,      /* output transposed data set                      */
20474 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
20475 +  inEM          =Y,
20476 +  timePrefix    =_T
20477 +/*-------------------------------------------------------------------------*/
20478 +);
20480 +%let timePrefix = &timePrefix;
20482 +%if  &EM_NUM_CROSSID > 0 %then %do;
20484 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
20485 +    set &inIDMap;
20486 +    drop _NAMEID_;
20487 +    run;
20488 +%let inIDMap=_emtstp_map0;
20490 +%end;
20492 +proc sql noprint;
20493 +    * number of TS Variables to be transposed;
20494 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
20495 +    ;
20496 +    * number of TS Variables to be transposed;
20497 +    select max(_TSID_) into :num_TSID from &inIDMap
20498 +    ;
20499 +    * name list of TS Variables;
20500 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
20501 +        from &inIDMap
20502 +        order by _NAMEID_
20503 +    ;
20504 +    * total number of time series =max(_TSID_)*&num_TSVar;
20505 +    * and the number of digits of this variable is &num_digits;
20506 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
20507 +        from &inIDMap
20508 +    ;
20509 +      * Time ID variable;
20510 +    select name into:timeIDVar from &variableset
20511 +        where upcase(role) eq 'TIMEID'
20512 +    ;
20513 +quit;
20514 +%let num_digits = &num_digits;
20515 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
20517 +/*-------------------------------------------------------------------------*/
20519 +* get number of cross IDs and also the TIME ID variable name;
20520 +%if &inEM eq Y %then %do;
20521 +    %let num_crossIDVar = &EM_NUM_CROSSID;
20522 +    %let crossIDVar     = %EM_CROSSID;
20523 +%end;
20524 +%else %do;
20525 +    proc sql noprint;
20526 +        * number of cross ID;
20527 +        select count(*) into :num_crossIDVar
20528 +            from &variableSet
20529 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20530 +        ;
20531 +        * create a string of crossID variable like A B C D..;
20532 +        select distinct name into :crossIDVar separated by ' '
20533 +            from &variableSet
20534 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20535 +            order by name
20536 +        ;
20537 +    quit;
20538 +    %let num_crossIDVar=&num_crossIDVar;
20539 +%end;
20541 +/*-------------------------------------------------------------------------*/
20543 +%if (&num_crossIDVar gt 0) %then %do;
20545 +    data _emtstp_tmpDat;
20546 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
20547 +        _NAMEID_ = cats("_TS_",_TSID_);
20548 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
20549 +    run;
20551 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20553 +        * update the ID maps;
20554 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20555 +            by _NAMEID_ _TSID_;
20556 +        data &outIDMap;
20557 +            set _emtstp_tmpmap;
20558 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20559 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20560 +        run;
20562 +        * get the names for the new variables;
20563 +        proc sql noprint;
20564 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
20565 +            ;
20566 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
20567 +            ;
20568 +        quit;
20570 +        * data must be sorted before transposed;
20571 +        proc sort data=_emtstp_tmpDat;
20572 +            by &timeIDvar;
20573 +        run;
20575 +        %do i = 1 %to &num_TSVar;
20576 +            %let i = &i;
20577 +            * transpose one cross-type time series data by TSID;
20578 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
20579 +                id _NAMEID_;
20580 +                by &timeIDVar;
20581 +                var &&&TSVar&i;
20582 +            run;
20583 +        %end;
20585 +        * merge all vertical time series, rename and label them;
20586 +        data &outDS;
20587 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
20588 +            by &timeIDVar;
20589 +            rename
20590 +                %do i = 1 %to &num_TSVar;
20591 +                    %do j = 1 %to &num_TSID;
20592 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20593 +                        /* %put &i &j &num1 &num_TSID; */
20594 +                        _V_&i._TS_&j = &&&tsname&num1
20595 +                    %end;
20596 +                %end;
20597 +            ;
20598 +            label
20599 +                %do i = 1 %to &num_TSVar;
20600 +                    %do j = 1 %to &num_TSID;
20601 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20602 +                        /* %put &i &j &num1 &num_TSID; */
20603 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
20604 +                    %end;
20605 +                %end;
20606 +            ;
20607 +        run;
20608 +    %end;
20609 +    %else %do;
20611 +        * update the ID maps;
20612 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20613 +            by _NAMEID_ _TSID_;
20614 +        data &outIDMap;
20615 +            set _emtstp_tmpmap;
20616 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20617 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20618 +        run;
20620 +        proc sql noprint;
20621 +            * get the roles for the new variables;
20622 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
20623 +                from &inIDMap
20624 +                order by _NAMEID_
20625 +            ;
20626 +            * get the length of the time series;
20627 +            select count(distinct &timeIDvar) into :num_T
20628 +                from _emtstp_tmpDat
20629 +            ;
20630 +        quit;
20632 +        * data must be sorted before transposed;
20633 +        proc sort data=_emtstp_tmpDat;
20634 +            by _TSID_ &crossIDVar &timeIDvar;
20635 +        run;
20637 +        %do i = 1 %to &num_TSVar;
20638 +            %let i = &i;
20639 +            * transpose one cross-type time series data by TIMEID;
20640 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
20641 +                by _TSID_ &crossIDVar;
20642 +                var &&&TSVar&i;
20643 +            run;
20644 +        %end;
20646 +        * stack all horizontal time series;
20647 +        data &outDS;
20648 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
20649 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
20650 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
20651 +            %do i=1 %to &num_TSVar;
20652 +                if in&i then do;
20653 +                    _NAMEID_ ="&&&TSVar&i";
20654 +                    _ROLE_   ="&&&TSRole&i";
20655 +                end;
20656 +            %end;
20657 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
20658 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
20659 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
20660 +        run;
20661 +    %end;
20662 +%end;
20663 +%else %do;
20665 +    proc sql noprint;
20666 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
20667 +            order by _NAMEID_
20668 +        ;
20669 +    quit;
20671 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20672 +        * transpose the panel-type time series data by TSID;
20673 +        proc sort data=&inDS out=_emtstp_tmpDat;
20674 +            by &timeIDvar;
20675 +        proc transpose data=_emtstp_tmpDat
20676 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
20677 +            by &timeIDVar;
20678 +            var &panelTSVar;
20679 +        run;
20680 +        proc datasets lib=work nolist;
20681 +            modify _emtstp_tmpDat2;
20682 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
20683 +            run; quit;
20684 +    %end;
20685 +    %else %do;
20686 +        * transpose the panel-type time series data by TIMEID;
20687 +        proc sort data=&inDS out=_emtstp_tmpDat;
20688 +            by &timeIDvar;
20689 +        data _emtstp_tmpDat;
20690 +            set _emtstp_tmpDat;
20691 +            _tmp_ind=_n_;
20692 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
20693 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
20694 +            ID _tmp_ind;
20695 +            var &panelTSVar;
20696 +        run;
20697 +    %end;
20699 +      * merge ID maps to the transpose data set;
20700 +      proc sql noprint;
20701 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
20702 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
20703 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
20704 +          ;
20705 +      quit;
20707 +      * update the TS ID map;
20708 +      data &outIDMap;
20709 +          set &inIDMap;
20710 +      run;
20711 +%end;
20713 +proc datasets lib=work nolist;
20714 +    delete _emtstp:;
20715 +run; quit;
20717 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSDP_REPORT.SOURCE.
20718 +%macro EM_TSDP_REPORT;
20720 +%EM_GETNAME(KEY=TSIDMAPSUM, TYPE=DATA);
20721 +%EM_GETNAME(KEY=TSIDMAP,    TYPE=DATA);
20722 +%EM_GETNAME(KEY=TSMETA,     TYPE=DATA);
20723 +%EM_GETNAME(KEY=OUTSUMMARY, TYPE=DATA);
20724 +%EM_GETNAME(KEY=OUTSEASON,  TYPE=DATA);
20725 +%EM_GETNAME(KEY=OUTDS,      TYPE=DATA);
20727 +%let _EXPORT_DATA  = &EM_USER_OUTDS;
20728 +%let _EXPORT_DSKEY = OUTDS;
20729 +%let n_max_tsplot  = &EM_PROPERTY_NMaxTSPlot;
20730 +%let _crossidvar   = %EM_CROSSID;
20732 +%let viewnum=1;
20734 +%EM_REPORT(key=TSMETA,  view=&viewnum, viewtype=DATA, block=Model, Autodisplay=Y, description=tsmetatable) ;
20735 +%let viewnum=%eval(&viewnum+1);
20737 +%EM_REPORT(key=TSIDMAP, view=&viewnum, viewtype=DATA, block=Model, Autodisplay=Y, description=tsidmaptable) ;
20738 +%let viewnum=%eval(&viewnum+1);
20740 +%EM_TS_GetNObs(inds=&EM_USER_TSIDMAP, nobs=_tsdp_tsidmap_n);
20743 +%let _str_mean   = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_mean, noquote));
20744 +%let _str_min    = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_min, noquote));
20745 +%let _str_max    = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_max, noquote));
20746 +%let _str_sum    = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_sum, noquote));
20747 +%let _str_median = %sysfunc(sasmsg(sashelp.dmine, rpt_timeseries_label_median, noquote));
20749 +/*--------------------------------------------------------------------
20751 +%if (&_crossidvar ne ) %then %do;
20753 +  %if (&_tsdp_tsidmap_n > 0 ) %then %do;
20754 +    proc dmdb data=&EM_USER_TSIDMAP classout=&EM_USER_TSIDMAPSUM;
20755 +      class &_crossidvar ;
20756 +    run;
20757 +    data _tmp_a;
20758 +       NAME = "TSID";
20759 +       FREQUENCY = &_tsdp_tsidmap_n;
20760 +       FREQPERCENT = 100;
20761 +       output;
20762 +    run;
20763 +    data &EM_USER_TSIDMAPSUM;
20764 +       set &EM_USER_TSIDMAPSUM _tmp_a;
20765 +    rename NAME=VARIABLE;
20766 +    rename FREQUENCY=COUNT;
20767 +    rename FREQPERCENT=PERCENT;
20768 +    Label  NAME  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name, noquote))";
20769 +    Label  FREQUENCY  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_count, noquote))";
20770 +    Label  FREQPERCENT = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
20771 +    Label  LEVEL  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_level, noquote))";
20772 +    keep NAME LEVEL FREQUENCY FREQPERCENT;
20773 +    run;
20774 +    %EM_TS_DELETE_DATA(dsname=_tmp_a);
20775 +    %EM_REPORT(key=TSIDMAPSUM,  viewtype=DATA, block=Model,  Autodisplay=Y, description=sumtsidmap) ;
20779 +    %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUMMARY, tsidds=&EM_USER_TSIDMAP, byvar=%EM_CROSSID, outds=);
20780 +    %let j=1;
20781 +    %do %while(%scan(&_crossidVar, &j) ne );
20782 +       %let _csvar=%scan(&_crossidVar, &j);
20783 +           %let TitleOutSumPlot = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsdp_outsumplot, noquote, &_csvar));
20784 +           %EM_REPORT(key=OUTSUMMARY,  viewtype=BAR, view=&j, block=Plot, Autodisplay=Y, x=_TSID_, FREQ=MEAN, group=&_csvar, description=&TitleOutSumPlot) ;
20785 +           %EM_REPORT(VIEW=&j, Freq=SUM);
20786 +           %EM_REPORT(VIEW=&j, Freq=MAX);
20787 +           %EM_REPORT(VIEW=&j, Freq=MIN);
20788 +           %EM_REPORT(VIEW=&j, Freq=STDDEV);
20789 +           %EM_REPORT(VIEW=&j, Freq=N);
20790 +           %EM_REPORT(VIEW=&j, Freq=NMISS);
20791 +           %EM_REPORT(VIEW=&j, Freq=NOBS);
20792 +       %let j=%eval(&j+1);
20793 +     %end;
20796 +  %end;
20797 +%end;
20799 +------------------------------------------------------------------------------*/
20801 +%if (&_crossidvar ne ) %then %do;
20803 +    *** TSID Map Summary Table;
20804 +    %if (&_tsdp_tsidmap_n > 0 ) %then %do;
20805 +        proc dmdb data=&EM_USER_TSIDMAP classout=_tmp_idmapsum;
20806 +            class &_crossidvar ;
20807 +        run;
20809 +        proc sql noprint;
20810 +            create table &EM_USER_TSIDMAPSUM as
20811 +                select a.*, b.label
20812 +                from _tmp_idmapsum as a left join &EM_DATA_VARIABLESET as b
20813 +                    on upcase(a.name) eq upcase(b.name)
20814 +                ;
20815 +        quit;
20817 +        data _tmp_a;
20818 +            NAME = "TSID";
20819 +            FREQUENCY = &_tsdp_tsidmap_n;
20820 +            FREQPERCENT = 100;
20821 +        run;
20823 +        data &EM_USER_TSIDMAPSUM;
20824 +            set &EM_USER_TSIDMAPSUM _tmp_a;
20825 +            rename NAME=VARIABLE;
20826 +            rename FREQUENCY=COUNT;
20827 +            rename FREQPERCENT=PERCENT;
20828 +            label  NAME        = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name, noquote))";
20829 +            label  FREQUENCY   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_count, noquote))";
20830 +            label  FREQPERCENT = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_percent, noquote))";
20831 +            label  LEVEL       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_level, noquote))";
20832 +            label  label       = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel, noquote))";
20834 +            keep NAME LEVEL FREQUENCY FREQPERCENT label;
20835 +        run;
20836 +        %EM_TS_DELETE_DATA(dsname=_tmp_a);
20837 +        %EM_TS_DELETE_DATA(dsname=_tmp_idmapsum);
20839 +        %EM_REPORT(key=TSIDMAPSUM, view=&viewnum, viewtype=DATA, block=Model,  Autodisplay=Y, description=sumtsidmap);
20840 +        %let viewnum=%eval(&viewnum+1);
20842 +    %end;
20844 +    *** Time Series Summary Tables for each Cross-ID;
20845 +    %let j=1;
20846 +    %do %while(%scan(&_crossidvar, &j) ne );
20847 +        %let _csvar=%scan(&_crossidvar, &j);
20848 +        %let j=&j;
20849 +        %EM_GETNAME(KEY=OUTSUM&j, TYPE=DATA);
20850 +        %let _csvarlabel=  ;
20851 +        %let dsid=%sysfunc(open(&EM_USER_OUTSUMMARY));
20852 +        %if &dsid %then %do;
20853 +            %let _csvarlabel=%sysfunc(varlabel(&dsid, %sysfunc(varnum(&dsid,&_csvar))));
20854 +            %let rc=%sysfunc(close(&dsid));
20855 +        %end;
20856 +        %if &_csvarlabel eq  %then %do;
20857 +            %let tssummaryplotname = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsdp_outsumplot, noquote, &_csvar ));
20858 +        %end;
20859 +        %else %do;
20860 +            %let tssummaryplotname = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsdp_outsumplot, noquote, &_csvarlabel ));
20861 +        %end;
20863 +        %EM_REPORT(key=OUTSUM&j, viewtype=lattice, block=PLOT, autodisplay=Y, latticetype=bar, latticex=_varname_,
20864 +                   view=&viewnum, X=&_csvar, freq=mean,  choicetext=&_str_mean, Description=&tssummaryplotname);
20865 +        /*
20866 +        %EM_REPORT(key=OUTSUM&j, viewtype=lattice, block=PLOT, autodisplay=Y, latticetype=bar, latticex=_varname_,
20867 +                   view=&viewnum, X=&_csvar, freq=mean,  choicetext=&_str_mean, Description=tssummary);
20868 +        */
20869 +        %EM_REPORT(view=&viewnum, freq=max, choicetext=&_str_max);
20870 +        %EM_REPORT(view=&viewnum, freq=min, choicetext=&_str_min);
20871 +        %EM_REPORT(view=&viewnum, freq=sum, choicetext=&_str_sum);
20873 +        %let viewnum=%eval(&viewnum+1);
20874 +        %let j=%eval(&j+1);
20875 +    %end;
20876 +%end;
20877 +%else %do;
20878 +    *** for panel data;
20879 +    data &EM_USER_OUTSUMMARY;
20880 +        set &EM_USER_OUTSUMMARY;
20881 +        rename _name_=_nameid_;
20882 +    run;
20884 +    %EM_TSDP_MergeTSID(inds=&EM_USER_OUTSUMMARY, tsidds=&EM_USER_TSIDMAP, byvar=_NAMEID_, outds=);
20885 +    %EM_REPORT(key=OUTSUMMARY,  viewtype=BAR, view=&viewnum, Autodisplay=Y, x=_TSID_,
20886 +               block=PLOT, FREQ=MEAN, description=tssummary, choicetext=&_str_mean) ;
20887 +        %EM_REPORT(view=&viewnum, freq=max, choicetext=&_str_max);
20888 +        %EM_REPORT(view=&viewnum, freq=min, choicetext=&_str_min);
20889 +        %EM_REPORT(view=&viewnum, freq=sum, choicetext=&_str_sum);
20890 +    %let viewnum=%eval(&viewnum+1);
20891 +%end;
20893 +/*----------------------------------------------------------------------------*/
20894 +/* Time Series Plots                                                          */
20895 +/*----------------------------------------------------------------------------*/
20897 +%let _timeidVar = %EM_TIMEID;
20898 +%let _targetVar = %EM_TARGET;
20899 +%let _inputVars  = %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
20901 +%EM_TS_GET_STAT(data=&EM_USER_TSIDMAP, var=_TSID_, stat=MAX, value=n_tsid);
20903 +%let dsid=%sysfunc(open(&_EXPORT_DATA));
20904 +%let vn_tsid =%sysfunc(varnum(&dsid, _TSID_));
20905 +%let vn_timeid =%sysfunc(varnum(&dsid, &_timeidVar));
20906 +%let dsid = %sysfunc(close(&dsid));
20908 +%if (&_crossidvar ne ) %then %do;
20910 +    %if (&vn_tsid  > 0) %then %do;
20912 +        *** identify the right data set for plot;
20913 +        *** set limit to the maximum number of TSID;
20914 +        %if (&vn_timeid  > 0) %then %do;
20915 +            %if (&n_tsid  > &n_max_tsplot)
20916 +            %then %do;
20917 +                %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
20918 +                data &EM_USER_PLOTSUBDS;
20919 +                    set &_EXPORT_DATA(where=(_TSID_ <= &n_max_tsplot)) ;
20920 +                run;
20921 +                %let _PLOTDSKEY = PLOTSUBDS ;
20922 +            %end;
20923 +            %else %do;
20924 +                %let _PLOTDSKEY = &_EXPORT_DSKEY;
20925 +            %end;
20926 +        %end;
20927 +        %else %do;
20928 +            /* ----- For the case of Transposed by TimeID -------------- */
20929 +            %EM_GETNAME(KEY=TRANS_IMPORTDS, TYPE=DATA);
20930 +            %if (&n_tsid  > &n_max_tsplot)
20931 +            %then %do;
20932 +                %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
20933 +                data &EM_USER_PLOTSUBDS;
20934 +                    set &EM_USER_TRANS_IMPORTDS(where=(_TSID_ <= &n_max_tsplot)) ;
20935 +                run;
20936 +                %let _PLOTDSKEY = PLOTSUBDS ;
20937 +            %end;
20938 +            %else %do;
20939 +                %let _PLOTDSKEY = TRANS_IMPORTDS;
20940 +            %end;
20941 +        %end;
20943 +        *** for target time series;
20944 +        %let j=1;
20945 +        %do %while(%scan(&_targetVar, &j) ne );
20946 +            %let _tgvar=%scan(&_targetVar, &j);
20947 +            %if &j eq 1 %then %do;
20948 +                %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, VIEW=&viewnum, X=&_timeidVar, Y=&_tgvar, block=PLOT,
20949 +                           GROUP=_TSID_, AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=targettsplot);
20950 +            %end;
20951 +            %else %do;
20952 +                %EM_REPORT(VIEW=&viewnum, Y=&_tgvar);
20953 +            %end;
20954 +            %let j=%eval(&j+1);
20955 +        %end;
20956 +        %let viewnum=%eval(&viewnum+1);
20958 +        *** for input time series;
20959 +        %let j=1;
20960 +        %do %while(%scan(&_inputVars, &j) ne );
20961 +            %let _iptvar=%scan(&_inputVars, &j);
20962 +            %if &j eq 1 %then %do;
20963 +                %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=&_iptvar, block=PLOT,
20964 +                           GROUP=_TSID_, AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=inputtsplot);
20965 +            %end;
20966 +            %else %do;
20967 +                %EM_REPORT(VIEW=&viewnum, Y=&_iptvar);
20968 +            %end;
20969 +            %let j=%eval(&j+1);
20970 +        %end;
20971 +        %let viewnum=%eval(&viewnum+1);
20972 +    %end;
20973 +    %else %do;
20975 +        %let nvar=1;
20976 +        %let _yvars=;
20977 +        %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
20978 +        %if &dsid > 0 %then %do;
20979 +            %let vn_name =%sysfunc(varnum(&dsid, _NAMEID_));
20980 +            %do %while((^ %sysfunc(fetch(&dsid))) and (&nvar <= &n_max_tsplot));
20981 +                %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
20982 +                %let _yvars = &_yvars &_varname ;
20983 +                %let nvar=%eval(&nvar+1);
20984 +            %end;
20985 +            %let dsid = %sysfunc(close(&dsid));
20986 +        %end;
20988 +        %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
20989 +        data &EM_USER_PLOTSUBDS;
20990 +            set &&&EM_USER_&_EXPORT_DSKEY;
20991 +            keep &_timeidvar &_yvars;
20992 +        run;
20994 +        %EM_REPORT(KEY=PLOTSUBDS, VIEWTYPE=LINEPLOT, view=&viewnum,  block=PLOT, X=&_timeidVar,  Y=_ANYNUMERIC_,
20995 +                   AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=timeseriesplot);
20996 +        %let viewnum=%eval(&viewnum+1);
20998 +        %EM_REPORT(Key=PLOTSUBDS, ViewType=LINEPLOT, view=&viewnum, block=PLOT, X=&_timeidvar, Y=&_yvars,
20999 +                   autodisplay=Y, description=multipletsplot);
21000 +        %let viewnum=%eval(&viewnum+1);
21001 +   %end;
21002 +%end;
21003 +%else %do;
21005 +    %if (&n_tsid  > &n_max_tsplot) %then %do;
21006 +        %EM_REGISTER(KEY=PLOTSUBDS, TYPE=DATA);
21007 +        data &EM_USER_PLOTSUBDS;
21008 +            %if &EM_PROPERTY_TRANSPOSE eq Y %then %do;
21009 +                %EM_GETNAME(KEY=TRANS_IMPORTDS, TYPE=DATA);
21010 +                set &EM_USER_TRANS_IMPORTDS;
21011 +            %end;
21012 +            %else %do;
21013 +               set &_EXPORT_DATA;
21014 +            %end;
21016 +           %let nvar=1;
21017 +           %let _yvars=;
21018 +           %let dsid=%sysfunc(open(&EM_USER_TSIDMAP));
21019 +           %if &dsid > 0 %then %do;
21020 +               %let vn_name =%sysfunc(varnum(&dsid, _NAMEID_));
21021 +               %do %while((^ %sysfunc(fetch(&dsid))) and (&nvar <= &n_max_tsplot));
21022 +                   %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
21023 +                   %let _yvars = &_yvars &_varname ;
21024 +                   %let nvar=%eval(&nvar+1);
21025 +               %end;
21026 +               %let dsid = %sysfunc(close(&dsid));
21027 +           %end;
21028 +           keep &_timeidVar &_yvars;
21029 +       run;
21030 +       %let _PLOTDSKEY = PLOTSUBDS ;
21032 +       %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=&_yvars, block=PLOT,
21033 +                  AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=multipletsplot);
21034 +       %let viewnum=%eval(&viewnum+1);
21035 +       %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=_ANYNUMERIC_, block=PLOT,
21036 +                  AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=timeseriesplot);
21037 +       %let viewnum=%eval(&viewnum+1);
21038 +    %end;
21039 +    %else %do;
21040 +        %if &EM_PROPERTY_TRANSPOSE ne N %then %do;
21041 +            %EM_GETNAME(KEY=TRANS_IMPORTDS, TYPE=DATA);
21042 +            %let _PLOTDSKEY = TRANS_IMPORTDS;
21043 +        %end;
21044 +        %else %do;
21045 +            %let _PLOTDSKEY = &_EXPORT_DSKEY;
21046 +        %end;
21048 +        %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, block=PLOT,
21049 +                   Y=%EM_TARGET %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED,
21050 +                   AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=multipletsplot);
21051 +        %let viewnum=%eval(&viewnum+1);
21052 +        %EM_REPORT(KEY=&_PLOTDSKEY, VIEWTYPE=LINEPLOT, view=&viewnum, X=&_timeidVar, Y=_ANYNUMERIC_, block=PLOT,
21053 +                   AUTODISPLAY=Y, COLOR=_SEGMENT_, DESCRIPTION=timeseriesplot);
21054 +        %let viewnum=%eval(&viewnum+1);
21055 +    %end;
21056 +%end;
21058 +/*----------------------------------------------------------------------------*/
21059 +/* Seasonality Summary Plots                                                  */
21060 +/*----------------------------------------------------------------------------*/
21062 +data _null_;
21063 +      set &EM_USER_TSMETA;
21064 +    call symput('_seasonlength',userSeasonality);
21065 +run;
21067 +%if &_seasonlength gt 1 %then %do;
21069 +    *%EM_REPORT(key=OUTSEASON,viewtype=DATA, block=Model, Autodisplay=Y, description=outseason) ;
21071 +    %if (&n_tsid  > &n_max_tsplot) %then %do;
21072 +        %EM_REGISTER(KEY=PLOTSEASONDS, TYPE=DATA);
21073 +        data &EM_USER_PLOTSEASONDS;
21074 +            set &EM_USER_OUTSEASON(where=(_TSID_ <= &n_max_tsplot)) ;
21075 +        run;
21076 +        %let _PLOTSEASONDS = PLOTSEASONDS ;
21077 +    %end;
21078 +    %else %do;
21079 +        %let _PLOTSEASONDS = OUTSEASON ;
21080 +    %end;
21082 +    %EM_REPORT(KEY=&_PLOTSEASONDS, VIEWTYPE=LINEPLOT, View=&viewnum,  X=_SEASON_, Y=MEAN, block=PLOT,
21083 +               AUTODISPLAY=Y, group=_NAMEID_, DESCRIPTION=SeasonStatPlot, choicetext=&_str_mean);
21084 +    %EM_REPORT(VIEW=&viewnum, Y=SUM, choicetext=&_str_sum);
21085 +    %EM_REPORT(VIEW=&viewnum, Y=MIN, choicetext=&_str_min);
21086 +    %EM_REPORT(VIEW=&viewnum, Y=MAX, choicetext=&_str_max);
21087 +    %EM_REPORT(VIEW=&viewnum, Y=MEDIAN, choicetext=&_str_median);
21088 +    %let viewnum=%eval(&viewnum+1);
21089 +%end;
21091 +%Mend EM_TSDP_REPORT;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      11:146
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Records processed = 12   Memory used = 511K.
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set WORK._TMP_IDMAPSUM has 8 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table EMWS2.TSDP_TSIDMAPSUM created, with 8 rows and 10 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._TMP_A has 1 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 8 observations read from the data set EMWS2.TSDP_TSIDMAPSUM.
NOTE: There were 1 observations read from the data set WORK._TMP_A.
NOTE: The data set EMWS2.TSDP_TSIDMAPSUM has 9 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_A (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_IDMAPSUM (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 396 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 396 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 528 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 528 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 660 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 660 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 792 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 792 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 924 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 924 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1056 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1056 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1188 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1188 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1320 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1320 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1452 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSDP_TSIDMAP.
NOTE: The data set WORK._TMPDS has 5 observations and 4 variables.
NOTE: The PROCEDURE MEANS printed page 2.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK.EM_USER_KEY has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_OUTDS.
NOTE: The data set EMWS2.TSDP_PLOTSUBDS has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1452 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1585 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1585 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1729 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      244:137
NOTE: There were 1 observations read from the data set EMWS2.TSDP_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1729 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1862 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1862 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1995 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1995 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2128 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2128 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2261 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2261 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2394 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
21092
21093
21094  *------------------------------------------------------------*;
21095  * End REPORT: TSDP;
21096  *------------------------------------------------------------*;
 
21097  /* Reset EM Options */
21098  options formchar="|----|+|---+=|-/\<>*";
21099  options nocenter ls=256 ps=10000;
21100  goptions reset=all device=GIF NODISPLAY;
 
21101  proc sort data=WORK.EM_USER_REPORT;
21102  by ID VIEW;
21103  run;
 
NOTE: There were 2394 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 2394 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
