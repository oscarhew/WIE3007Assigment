*------------------------------------------------------------*
User:                Oscar
Date:                January 06, 2024
Time:                00:17:52
Site:                12601940
Platform:            W32_8HOME
Maintenance Release: 9.04.01M3P062415
EM Version:          14.1
* 
*------------------------------------------------------------*
* Training Log
Date:                January 06, 2024
Time:                00:17:50
*------------------------------------------------------------*
14716  proc freq data=EMWS2.TSSIM_VariableSet noprint;
14717  table ROLE*LEVEL/out=WORK.TSSIMMETA;
14718  run;
 
NOTE: There were 13 observations read from the data set EMWS2.TSSIM_VARIABLESET.
NOTE: The data set WORK.TSSIMMETA has 3 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
 
 
14719  proc print data=WORK.TSSIMMETA label noobs;
14720  var ROLE LEVEL COUNT;
14721  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
14722  title9 ' ';
14723  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
14724  run;
 
NOTE: There were 3 observations read from the data set WORK.TSSIMMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
14725  title10;
 
14726  %let EMEXCEPTIONSTRING=;
PERFORMANCE  DETAILS
15084  *------------------------------------------------------------*;
15085  * TSSIM: Generation of macros and macro variables;
15086  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15087  *------------------------------------------------------------*;
 
15088  %let EMEXCEPTIONSTRING=;
15089  *------------------------------------------------------------*;
15090  * TRAIN: TSSIM;
15091  *------------------------------------------------------------*;
15092  %let EM_ACTION = TRAIN;
15093  %let syscc = 0;
15094
15095  %macro EM_TSSIM_MAIN;
15096
15097     filename temp catalog 'sashelp.emtsdm.tssim_macros.source';
15098     %include temp;
15099     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
15100     %include temp;
15101     filename temp;
15102
15103     %if %upcase(&EM_ACTION) = CREATE %then %do;
15104         filename temp catalog 'sashelp.emtsdm.tssim_create.source';
15105         %include temp;
15106         filename temp;
15107         %EM_TSSIM_CREATE;
15108     %end;
15109     %else
15110     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15111          filename temp catalog 'sashelp.emtsdm.tssim_train.source';
15112             %include temp;
15113             filename temp;
15114          %EM_TSSIM_TRAIN;
15115     %end;
15116     %else
15117     %if %upcase(&EM_ACTION) = SCORE %then %do;
15118             filename temp catalog 'sashelp.emtsdm.tssim_score.source';
15119             %include temp;
15120             filename temp;
15121          %EM_TSSIM_SCORE;
15122     %end;
15123     %else
15124     %if %upcase(&EM_ACTION) = REPORT %then %do;
15125             filename temp catalog 'sashelp.emtsdm.tssim_report.source';
15126             %include temp;
15127             filename temp;
15128          %EM_TSSIM_REPORT;
15129     %end;
15130
15131  %mend EM_TSSIM_MAIN;
15132  %EM_TSSIM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSSIM_MACROS.SOURCE.
15133 +/*----------------------------------------------------------------------------------+
15134 + |
15135 + |   Title :
15136 + |   TS Similarity Search Macros for Time Series Data Mining
15137 + |
15138 + |
15139 + |   Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
15140 + |
15141 + |   Notes:
15142 + |
15143 + |----------------------------------------------------------------------------------*/
15145 +%macro EM_TSSIM_Similarity(inds=,
15146 +                  outds=,
15147 +                  outsum=,
15148 +                  outmeasure=,
15149 +                  outpath=,
15150 +                  outsequence = ,
15151 +                  out= ,
15152 +                  exportdistancematrix=,
15153 +                  crossid=,
15154 +                  timeid=,
15155 +                  measure=,
15156 +                  interval=,
15157 +                  accumulation=,
15158 +                  missing=,
15159 +                  slide=,
15160 +                  normalization=,
15161 +                  clustering =,
15162 +                  inctargetindist=,
15163 +                  scale=,
15164 +                  compress=,
15165 +                  compglobalabs=,
15166 +                  compglobalpct=,
15167 +                  complocalabs=,
15168 +                  complocalpct=,
15169 +                  expand=,
15170 +                  expglobalabs=,
15171 +                  expglobalpct=,
15172 +                  explocalabs=,
15173 +                  explocalpct=
15174 +                  );
15176 +data _tmpinds(KEEP = &crossid &timeid %EM_TARGET  %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED);
15177 +     set &inds;
15178 +proc sort data=_tmpinds out=_tmpinds;
15179 +     by  &crossid &timeid;
15180 +run;
15182 +proc similarity data=_tmpinds
15183 +/*
15184 +%if ( &exportdistancematrix eq Y ) %then %do;
15185 +               outsum=&outds
15186 +               out=&out
15187 +%end;
15188 +%else %do;
15189 +               out=&outds
15190 +               outsum=&outsum
15191 +%end;
15192 +*/
15193 +               out=&EM_USER_OUT
15194 +               outsum=&EM_USER_OUTSUMMARY
15196 +              /* outmeasure=&outmeasure
15197 +                 outpath=&outpath
15198 +                 outsequence =&outsequence
15199 +               */
15200 +              /* print = summary*/
15202 +;
15203 +by &crossid;
15204 +id &timeid interval=&interval accumulate=&accumulation
15205 +%if &missing eq ZERO %then %do;
15206 +    setmissing= 0
15207 +%end;
15208 +%else %do;
15209 +    setmissing=&missing
15210 +%end;
15211 +;
15212 +%if (&clustering eq Y) or ( %EM_TARGET eq )  %then %do;
15213 +        target
15214 +        %if &inctargetindist eq Y %then %do;
15215 +          %EM_TARGET
15216 +        %end;
15217 +        %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED / measure=&measure normalize=&normalization slide=&slide TRIMMISSING=none
15218 +            %if &compress eq ABS %then %do;
15219 +               compress=(localabs=&complocalabs globalabs=&compglobalabs)
15220 +            %end;
15221 +            %else %if &compress eq PERCENT %then %do;
15222 +                compress=(localpct=&complocalpct globalpct=&compglobalpct)
15223 +            %end;
15225 +            %if &expand eq ABS %then %do;
15226 +            expand=(localabs=&explocalabs globalabs=&expglobalabs)
15227 +            %end;
15228 +            %else %if &expand eq PERCENT %then %do;
15229 +             expand=(localpct=&explocalpct globalpct=&expglobalpct)
15230 +            %end;
15231 +        ;
15232 +%end;
15233 +%else %do;
15234 +        target %EM_TARGET / measure=&measure normalize=&normalization slide=&slide TRIMMISSING=none
15235 +            %if &compress eq ABS %then %do;
15236 +               compress=(localabs=&complocalabs globalabs=&compglobalabs)
15237 +            %end;
15238 +            %else %if &compress eq PERCENT %then %do;
15239 +                compress=(localpct=&complocalpct globalpct=&compglobalpct)
15240 +            %end;
15242 +            %if &expand eq ABS %then %do;
15243 +            expand=(localabs=&explocalabs globalabs=&expglobalabs)
15244 +            %end;
15245 +            %else %if &expand eq PERCENT %then %do;
15246 +             expand=(localpct=&explocalpct globalpct=&expglobalpct)
15247 +            %end;
15248 +        ;
15249 +        input  %EM_INTERVAL_INPUT  %EM_INTERVAL_REJECTED /  normalize=&normalization scale=&scale TRIMMISSING=none ;
15250 +%end;
15252 +run;
15255 +/*
15257 +%if ( &exportdistancematrix eq Y ) %then %do;
15259 +        data &EM_USER_OUTSUMMARY;
15260 +             set &outds;
15261 +        run;
15262 +        data &outds;
15263 +             set &outds;
15264 +             DROP _STATUS_;
15265 +             rename _INPUT_ = _NAMEID_;
15266 +        run;
15267 +        *------ Merge TSIDMAP ---------;
15268 +        proc sort data = &EM_USER_TSIDMAP;
15269 +              by _NAMEID_;
15270 +        run;
15271 +        proc sort data = &outds;
15272 +              by _NAMEID_;
15273 +         run;
15274 +        data &outds;
15275 +             merge &EM_USER_TSIDMAP &outds;
15276 +              by _NAMEID_;
15277 +        run;
15279 +        %if &inctargetindist eq N %then %do;
15281 +       %let target = %EM_TARGET; * need to fix ;
15283 +        data &outds;
15284 +             merge &outds;
15285 +             if upcase(_NAMEID_) eq upcase("&target") then delete;
15286 +             drop _TSID_;
15287 +        run;
15289 +        %end;
15290 +%end;
15291 +  ---*/
15293 +/*%if ( (&EM_PROPERTY_EXPORTDISTANCEMATRIX eq Y ) or (%EM_TARGET eq ) ) and (&clustering eq Y ) %then %do;  */
15294 +  %if (&clustering eq Y ) %then %do;
15295 +     %EM_GETNAME(KEY=OUTTREE, TYPE=DATA);
15296 +     %EM_GETNAME(KEY=OUTLINK, TYPE=DATA);
15297 +     %EM_GETNAME(KEY=OUTNODE, TYPE=DATA);
15299 +     proc cluster data=&EM_USER_OUTSUMMARY(type=Distance drop=_STATUS_) method=Ward outtree=&EM_USER_OUTTREE;
15300 +         id _INPUT_;
15301 +         *by &crossid;
15302 +     run;
15304 +     %EM_TS_MakeConstellPlotData(intreedata=&EM_USER_OUTTREE, outnode=&EM_USER_OUTNODE, outlink=&EM_USER_OUTLINK);
15305 +%end;
15307 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpinds);
15308 +quit;
15310 +%mend EM_TSSIM_Similarity;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
15321 +/*
15322 +       MACRO: TS Utility macros
15324 +       PURPOSE: TS Utility macros
15325 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
15327 +       HISTORY:
15328 +       NOTE:
15330 +*/
15332 +/*
15333 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
15334 +                          timeid=, timeformat=, timeinformat=);
15335 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
15337 +    %do;
15338 +    %let m_data      = &data;
15339 +    %let m_decdata   = &decdata;
15340 +    %let m_decmeta   = &decmeta;
15341 +    %let m_cmeta     = &cmeta;
15342 +    %let m_outfile   = &outfile;
15343 +    %let m_crossid   = &crossid;
15344 +    %let m_timeid    = &timeid;
15345 +    %let m_timeformat    = &timeformat;
15346 +    %let m_timeinformat    = &timeinformat;
15347 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
15348 +  %end;
15349 +%mend EM_TS_CreateTsMetaDs;
15350 +*/
15351 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
15352 +proc sql;
15353 +      create table _tmp_inds
15354 +      as select distinct &timeid from  &indata;
15355 +quit;
15356 +run;
15357 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
15358 +  id &timeid
15359 +%if &timeinterval ne %then %do;
15360 +    %if &timeformattype eq DATE %then %do;
15361 +        interval=&timeinterval
15362 +    %end;
15363 +    %else %if &timeformattype eq DATETIME  %then %do;
15364 +        %let dttimeinterval= DT&timeinterval;
15365 +         interval=&dttimeinterval
15366 +    %end;
15367 +%end;
15368 +;
15369 +run;
15371 +data &outds;
15372 +     set _tmp_tsmeta;
15373 +     format START &timeformat;
15374 +     format END &timeformat;
15375 +     length APPLY_START_END $8;
15376 +     APPLY_START_END ="No";
15377 +     FORMAT = "&timeformat";
15378 +     ROLE ="TIMEID";
15379 +     rename TIMEID = NAME;
15380 +     rename SEASONALITY= LengthOfCycle;
15381 +     rename INTERVAL = TIMEINTERVAL ;
15382 +     rename FORMAT = TIMEFORMAT;
15383 +     output;
15384 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
15385 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
15386 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
15387 +run;
15389 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
15390 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
15392 +%mend EM_TS_CreateTSMetaData;
15396 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
15398 +/* if updated = Y it will pass the TSMETA created by just the previous node */
15400 +%let _tsmetads = ;
15402 +%if &updated = Y %then %do;
15403 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
15404 +%if %sysfunc(exist(&_tsmetads)) %then %do;
15405 +%goto endline;
15406 +%end;
15407 +%end;
15409 +%if &eminfodata eq %then %do;
15410 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15411 +    data &EM_DATA_EMINFO;
15412 +         set &EM_IMPORT_DATA_EMINFO;
15413 +    run;
15414 +%end;
15415 +%else %do;
15416 +    %let dsid=%sysfunc(open(&eminfodata));
15417 +    data &EM_DATA_EMINFO;
15418 +         set &eminfodata;
15419 +    run;
15420 +%end;
15421 +%if &dsid > 0 %then %do;
15422 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
15423 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
15424 +    %do %while(^ %sysfunc(fetch(&dsid)));
15425 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15426 +         %if &_key eq TSMETA %then %do;
15427 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
15428 +         %end;
15429 +    %end;
15430 +    %let dsid = %sysfunc(close(&dsid));
15431 +%end; /* the end of %if &dsid > 0 %then %do; */
15433 +%endline:
15435 +%if &_tsmetads ne %then %do;
15436 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
15437 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
15438 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
15439 +         data &EM_USER_TSMETA;
15440 +                   set &_tsmetads;
15441 +         run;
15442 +    %end;
15443 +%end;
15445 +*proc print data=&EM_DATA_EMINFO;
15446 +*proc print data=&EM_IMPORT_DATA_EMINFO;
15447 +*run;
15448 +%MEND EM_TS_GETTSMETA;
15451 +/*
15452 +%macro EM_GETTSMETAVARS(TimeInterval=);
15453 +%global &TimeInterval;
15454 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
15455 +%if &dsid > 0 %then %do;
15456 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
15457 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
15458 +%do %while(^ %sysfunc(fetch(&dsid)));
15459 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15460 +     %if &_role eq TIMEID %then %do;
15461 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
15462 +     %end;
15463 +%end;
15464 +%let dsid = %sysfunc(close(&dsid));
15465 +%end;
15466 +%MEND EM_GETTSMETAVARS;
15467 +*/
15468 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
15469 +%global &TimeInterval;
15470 +%global &TimeId;
15471 +%global &EndTime;
15472 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
15473 +proc print data=&EM_USER_TSMETA;
15474 +run;
15475 +%if &dsid > 0 %then %do;
15476 +%if &TimeInterval ne %then %do;
15477 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
15478 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15479 +    %do %while(^ %sysfunc(fetch(&dsid)));
15480 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15481 +        %if &_role eq TIMEID %then %do;
15482 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
15483 +        %end;
15484 +     %end;
15485 +%end;
15486 +%if &TimeId ne %then %do;
15487 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
15488 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15489 +    %do %while(^ %sysfunc(fetch(&dsid)));
15490 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15491 +        %if &_role eq TIMEID %then %do;
15492 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
15493 +        %end;
15494 +    %end;
15495 +%end;
15497 +%if &EndTime ne %then %do;
15498 +    %let vn_end =%sysfunc(varnum(&dsid, END));
15499 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
15500 +    %do %while(^ %sysfunc(fetch(&dsid)));
15501 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
15502 +        %if &_role eq TIMEID %then %do;
15503 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
15504 +        %end;
15505 +     %end;
15506 +%end;
15507 +%let dsid = %sysfunc(close(&dsid));
15508 +%end;
15509 +%MEND EM_TS_GETTSMETAVARS;
15513 +/*------------------------------------------------------------------
15515 +      Macro EM_GETTSIDMAP
15517 +------------------------------------------------------------------+*/
15520 +%macro EM_TS_GETTSIDMAP(updated=);
15522 +%let _tsidmap = ;
15524 +%if &updated = Y %then %do;
15525 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
15526 +%if %sysfunc(exist(&_tsidmap)) %then %do;
15527 +%goto endline;
15528 +%end;
15529 +%end;
15531 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
15532 +%if &dsid > 0 %then %do;
15533 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
15534 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
15535 +%do %while(^ %sysfunc(fetch(&dsid)));
15536 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
15537 +     %if &_key eq TSIDMAP %then %do;
15538 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
15539 +     %end;
15540 +%end;
15542 +%let dsid = %sysfunc(close(&dsid));
15543 +%end;
15545 +%endline:
15547 +%if &_tsidmap ne %then %do;
15549 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
15550 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
15552 +%if %sysfunc(exist(&_tsidmap)) %then %do;
15553 +         data &EM_USER_TSIDMAP;
15554 +               set &_tsidmap;
15555 +         run;
15556 +    %end;
15557 +%end;
15558 +%MEND EM_TS_GETTSIDMAP;
15560 +/*------------------------------------------------------------------*/
15565 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
15566 +%global &value;
15569 +%let dsid = %sysfunc(open(&data));
15570 +%if &dsid > 0 %then %do;
15571 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
15572 +    %if &vn_var < 1 %then %do;
15573 +        %let &value = 0;
15574 +        %let dsid = %sysfunc(close(&dsid));
15575 +        %goto endline;
15576 +    %end;
15577 +%let dsid = %sysfunc(close(&dsid));
15578 +%end;
15580 +%let _tmp=_tmpDS;
15581 +proc means data=&data &stat;
15582 +     var &var;
15583 +     output out=&_tmp;
15584 +run;
15586 +%let dsid = %sysfunc(open(&_tmp));
15587 +%if &dsid > 0 %then %do;
15588 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
15589 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
15590 +     %do %while(^%sysfunc(fetch(&dsid)));
15591 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
15592 +         %if &_stat eq &stat %then %do;
15593 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
15594 +          %end;
15595 +      %end;
15596 +%let dsid = %sysfunc(close(&dsid));
15597 +%end;
15598 +proc datasets lib=work nolist;
15599 + delete &_tmp;
15600 +run;
15601 +%endline:
15602 +%MEND EM_TS_GET_STAT;
15605 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
15606 +%global &format;
15607 +%global &informat;
15608 +%let dsid = %sysfunc(open(&data));
15609 +%if &dsid > 0 %then %do;
15610 +%let vn_var =%sysfunc(varnum(&dsid, &var));
15611 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
15612 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
15613 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
15614 +%end;
15615 +%let dsid = %sysfunc(close(&dsid));
15616 +%end;
15617 +%MEND EM_TS_GET_VAR_FORMAT;
15619 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
15620 +      %if &lib eq %then %let lib=work;
15621 +       proc datasets lib=&lib nolist;
15622 +              delete &dsname;
15623 +       run;
15624 +%Mend  EM_TS_DELETE_DATA;
15627 +%macro EM_TS_GetNObs(inds=, nobs=);
15628 +    %global &nobs;
15629 +    %let &nobs=0;
15630 +    data _null_;
15631 +        set &inds end=eof;
15632 +        if eof then call symput("&nobs", _N_);
15633 +    run;
15634 +    quit;
15636 +    /*
15637 +    %let dsid=%sysfunc(open(&outdata));
15638 +    %if dsid > 0 %then %do;
15639 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
15640 +        %let dsid = %sysfunc(close(&dsid));
15641 +     %end;
15642 +    */
15643 +%mend  EM_TS_GetNObs;
15646 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
15647 +%global &time1;
15648 +%global &time2;
15649 +%if &default = Y %then %do;
15650 +   data _null_;
15651 +        set &data end=eof;
15652 +        if _N_ = 1 then  call symput("&time1", DATE);
15653 +        if eof then call symput("&time2", DATE);
15654 +    run;%end;
15655 +%else %do;
15656 +    %let dsid = %sysfunc(open(&data));
15657 +    %if &dsid > 0 %then %do;
15658 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
15659 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
15660 +        %do %while(^%sysfunc(fetch(&dsid)));
15661 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
15662 +             %if &_index eq 1 %then %do;
15663 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
15664 +             %end;
15665 +             %if &_index eq 2 %then %do;
15666 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
15667 +             %end;
15668 +        %end;
15669 +    %let dsid = %sysfunc(close(&dsid));
15670 +    %end;
15671 +%end;
15673 +%MEND EM_TS_GET_TIME_VALUES;
15675 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
15676 +%global &exist;
15677 + %let &exist = N;
15678 +%let dsid = %sysfunc(open(&data));
15679 +%if &dsid > 0 %then %do;
15680 +%let vn_var =%sysfunc(varnum(&dsid, &var));
15681 +%if &vn_var > 0 %then %do;
15682 +    %let &exist = Y;
15683 +%end;
15684 +%let dsid = %sysfunc(close(&dsid));
15685 +%end;
15686 +%MEND EM_TS_GET_VAR_EXIST;
15689 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
15690 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
15691 +      set &intreedata;
15692 +        LENGTH NodeType $32;
15693 +      if _PARENT_ eq " " then delete;
15694 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
15695 +        else NodeType = "CLUSTER";
15696 +        LinkID = _N_;
15697 +run;
15698 +%Mend EM_TS_MakeConstellPlotData;
15703 +%macro EM_TS_CreateIDMap(
15704 +/*-------------------------------------------------------------------------*/
15705 +/*---   Written by Xiangxiang Meng                                         */
15706 +/*-------------------------------------------------------------------------*/
15707 +inDS          =,      /* imported data set in TS data mining               */
15708 +outIDMap      =,      /* output data set of TS ID map                      */
15709 +outDS         =,      /* output data set of TS and TS ID merged            */
15710 +variableSet   =,      /* EM variable set                                   */
15711 +TSIDbyCrossID =Y,
15712 +inEM          =Y
15713 +/*-------------------------------------------------------------------------*/
15714 +);
15716 +%global EM_TS_ERR;
15717 +%let EM_TS_ERR = 0;
15719 +%if &inEM eq Y %then %do;
15720 +    %let num_crossIDVar = &EM_NUM_CROSSID;
15721 +    proc sql noprint;
15722 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
15723 +    quit;
15724 +%end;
15725 +%else %do;
15726 +    proc sql noprint;
15727 +         select count(*) into :num_crossIDVar from &variableSet
15728 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15729 +         ;
15730 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
15731 +         ;
15732 +    quit;
15733 +    %let num_crossIDVar=&num_crossIDVar;
15734 +%end;
15736 +* see if _TSID_ exists;
15738 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
15739 +run;
15741 +proc sql noprint;
15742 +    select count(*) into :has_TSID
15743 +        from _emtscm_contents
15744 +        where upcase(strip(name)) eq '_TSID_'
15745 +    ;
15746 +quit;
15748 +/*-------------------------------------------------------------------------*/
15749 +* Creating TSID map..;
15750 +/*-------------------------------------------------------------------------*/
15752 +%if (&num_crossIDVar gt 0) %then %do;
15754 +    data _emtscm_tmpIDMap;
15755 +        set &variableSet;
15756 +        where  (upcase(strip(level)) eq 'INTERVAL')
15757 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
15758 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
15759 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
15760 +          );
15761 +        _emts_dummy=1;
15762 +        keep name label role _emts_dummy;
15763 +    run;
15765 +    proc sql noprint;
15766 +        * create a string of crossID variable like A,B,C,D..;
15767 +        select distinct name into :crossIDVar separated by ','
15768 +            from &variableSet
15769 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15770 +            order by name
15771 +        ;
15772 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
15773 +            from &variableSet
15774 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
15775 +            order by name
15776 +        ;
15777 +        * create the TSID map data set;
15778 +        create table _emtscm_tmp1 as
15779 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
15780 +        ;
15781 +        * create a level list of cross ID variables and time series variables;
15782 +        create table &outIDMap as
15783 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
15784 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
15785 +            where a._emts_dummy eq b._emts_dummy
15786 +            order by a.name, &crossIDVar
15787 +        ;
15788 +    quit;
15790 +    %if &TSIDbyCrossID = Y %then %do;
15791 +        * create unique TSID only by Cross ID;
15792 +        data &outIDMap;
15793 +            length _TSID_ 8;
15794 +            set &outIDMap;
15795 +            by _NAMEID_;
15796 +            if first._NAMEID_
15797 +                then _TSID_=1;
15798 +                else _TSID_+1;
15799 +        run;
15800 +        %if "&outDS" ne "" %then %do;
15801 +            * merge TSID into &inDS;
15802 +            proc sql noprint;
15803 +                create table &outDS as
15804 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
15805 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
15806 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
15807 +                        where %do i = 1 %to &num_crossIDVar;
15808 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
15809 +                              %end;
15810 +                             b._TSID_ is not missing
15811 +                    order by b._TSID_, a.&timeIDVar
15812 +                ;
15813 +            quit;
15814 +        %end;
15815 +    %end;
15816 +    %else %do;
15817 +        * create unique TSID by Cross ID and _NAMEID_;
15818 +        data &outIDMap;
15819 +            length _TSID_ 8;
15820 +            set &outIDMap;
15821 +            _TSID_=_n_;
15822 +        run;
15823 +        %if "&outDS" ne "" %then %do;
15824 +            *no merge in this output;
15825 +            data &outDS;
15826 +                set &inDS;
15827 +            run;
15828 +        %end;
15829 +    %end;
15831 +    proc sort data=&outIDMap;
15832 +        by _NAMEID_ _TSID_;
15833 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
15834 +        format _TSID_ best12. _NAMEID2_ $40.;
15835 +        set &outIDMap;
15836 +        by _NAMEID_;
15837 +        if first._NAMEID_
15838 +            then _emts_ind=1;
15839 +            else _emts_ind+1;
15840 +        drop _emts_ind;
15841 +        rename _NAMEID_=_VARNAME_;
15842 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
15843 +        if _labelID_ eq ' '
15844 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
15845 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
15846 +    run;
15848 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
15850 +%end;
15851 +%else %do; /* if no crossid's the nameid needs to be created */
15853 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
15854 +        length _TSID_ 8;
15855 +        set &variableSet;
15856 +        where  (upcase(strip(level)) eq 'INTERVAL')
15857 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
15858 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
15859 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
15860 +          );
15861 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
15862 +        rename ROLE = _ROLE_;
15863 +        _NAMEID_=strip(name);
15864 +        _VARNAME_=strip(name);
15865 +        if label eq ' '
15866 +            then _LABELID_ = strip(name);
15867 +            else _LABELID_ = strip(label);
15868 +        _TSID_=_n_;
15869 +    run;
15871 +    %if "&outDS" ne "" %then %do;
15872 +        *no merge in this output;
15873 +        data &outDS;
15874 +            set &inDS;
15875 +        run;
15876 +    %end;
15877 +%end;
15879 +data &outIDMap;
15880 +    set &outIDMap;
15881 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
15882 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
15883 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
15884 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
15885 +run;
15887 +proc datasets lib=work nolist;
15888 +    delete _emtscm_:;
15889 +run; quit;
15891 +%mend EM_TS_createIDMap;
15893 +%macro EM_TS_CreateMetaData(
15894 +/*-------------------------------------------------------------------------*/
15895 +  inDS          =,      /* imported data set in TS data mining             */
15896 +  outDS         =,      /* output data set of TS metadata                  */
15897 +  variableSet   =,      /* EM variable set                                 */
15898 +  timeInterval  =,      /* time interval                                   */
15899 +  rc            =       /* return code                                     */
15900 +/*-------------------------------------------------------------------------*/
15901 +);
15903 +%if %eval(
15904 +      &EM_NUM_BINARY_INPUT   +
15905 +      &EM_NUM_ORDINAL_INPUT  +
15906 +      &EM_NUM_NOMINAL_INPUT  +
15907 +      &EM_NUM_BINARY_REJECTED   +
15908 +      &EM_NUM_ORDINAL_REJECTED  +
15909 +      &EM_NUM_NOMINAL_REJECTED  +
15910 +      &EM_NUM_ORDINAL_TARGET  +
15911 +      &EM_NUM_NOMINAL_TARGET +
15912 +      &EM_NUM_BINARY_TARGET
15913 +      ) > 0
15914 +%then %do;
15915 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
15916 +        %put &em_codebar;
15917 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
15918 +        %put &errormsg;
15919 +        %put &em_codebar;
15920 +        %goto ENDLINE;
15921 +%end;
15923 +%global EM_TS_ERR;
15924 +%let EM_TS_ERR = 0;
15926 +%if &timeInterval eq AUTO
15927 +    %then %let timeInterval  = ;
15928 +    %else %let timeInterval  = %upcase(&timeInterval);
15930 +/*-------------------------------------------------------------------------*/
15931 +* check time ID variable;
15932 +/*-------------------------------------------------------------------------*/
15934 +* number of variables in the Variableset with ROLE=TIMEID;
15935 +proc sql noprint;
15936 +    select count(*) into :num_timeID from &variableset
15937 +        where upcase(role) eq 'TIMEID';
15938 +quit;
15940 +/*-------------------------------------------------------------------------*/
15941 +* process only when there is one Time ID, otherwise exception message;
15942 +/*-------------------------------------------------------------------------*/
15944 +%if &num_timeID eq 0 %then %do;
15946 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
15947 +    %let EM_TS_ERR = 11;
15948 +    %put &em_codebar;
15949 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
15950 +    %put &errormsg;
15951 +    %put &em_codebar;
15952 +    %goto tscm_endline;
15954 +%end;
15955 +%else %if &num_timeID gt 1 %then %do;
15957 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
15958 +    %let EM_TS_ERR = 12;
15959 +    %put &em_codebar;
15960 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
15961 +    %put &errormsg;
15962 +    %put &em_codebar;
15963 +    %goto tscm_endline;
15965 +%end;
15966 +%else %do;
15967 +    *** proceed when there is one Time ID;
15969 +    data _null_;
15970 +        set &variableset(where=(upcase(role)='TIMEID'));
15971 +        call symput('timeIDFormat',     strip(format));
15972 +        call symput('timeID',           strip(upcase(name)      ));
15973 +        call symput('timeIDLevel',      strip(upcase(level))     );
15974 +        call symput('timeIDFormatType', strip(upcase(formattype)));
15975 +    run;
15977 +    *** exception message if the time ID is not an interval variable;
15978 +    %if &timeIDLevel ne INTERVAL %then %do;
15979 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
15980 +        %let EM_TS_ERR = 13;
15981 +        %put &em_codebar;
15982 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
15983 +        %put &errormsg;
15984 +        %put &em_codebar;
15985 +        %goto tscm_endline;
15986 +    %end;
15988 +    %if (&timeIDFormatType ne DATETIME) and
15989 +        (&timeIDFormatType ne DATE) and
15990 +        (&timeIDFormatType ne TIME) and
15991 +        (&timeIDFormatType ne USER)
15992 +    %then %do;
15993 +        *** sequential format-type of time ID;
15995 +        %let timeInterval = DAY;
15996 +        %let timeIDFormatType = SEQ;
15998 +        proc sql noprint;
15999 +            create table _emtscm_inds as
16000 +                 select distinct &timeID from &inDS(keep=&timeID)
16001 +                 where &timeID is not missing;
16002 +            select count(*) into :num_nonInteger from _emtscm_inds
16003 +                where &timeID ne int(&timeID);
16004 +        quit;
16006 +        %if &num_nonInteger gt 0 %then %do;
16007 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
16008 +            %let EM_TS_ERR = 14;
16009 +            %put &em_codebar;
16010 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
16011 +            %put &errormsg;
16012 +            %put &em_codebar;
16013 +            %goto tscm_endline;
16014 +        %end;
16015 +    %end;
16016 +    %else %do;
16017 +        *** date, datetime, time format-type of time ID;
16019 +        *** must have a format;
16020 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
16021 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
16022 +            %let EM_TS_ERR = 15;
16023 +            %put &em_codebar;
16024 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
16025 +            %put &errormsg;
16026 +            %put &em_codebar;
16027 +            %goto tscm_endline;
16028 +        %end;
16030 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
16031 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
16032 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
16033 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
16034 +                %let EM_TS_ERR = 16;
16035 +                %put &em_codebar;
16036 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
16037 +                %put &errormsg;
16038 +                %put &em_codebar;
16039 +                %goto tscm_endline;
16040 +            %end;
16041 +        %end;
16043 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
16044 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
16045 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
16046 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
16047 +                %let EM_TS_ERR = 17;
16048 +                %put &em_codebar;
16049 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
16050 +                %put &errormsg;
16051 +                %put &em_codebar;
16052 +                %goto tscm_endline;
16053 +            %end;
16054 +        %end;
16056 +        *** the AUTO function is currently turned off for TIME timeID variable;
16057 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
16058 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
16059 +            %let EM_TS_ERR = 18;
16060 +            %put &em_codebar;
16061 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
16062 +            %put &errormsg;
16063 +            %put &em_codebar;
16064 +            %goto tscm_endline;
16065 +        %end;
16067 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
16068 +            %then %let timeInterval =DT&timeInterval;
16070 +        proc sql noprint;
16071 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
16072 +                where &timeID is not missing;
16073 +        quit;
16074 +    %end;
16076 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
16077 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
16078 +    run;
16080 +    %let hasValidInterval = 0;
16081 +    %let hasLengthOne     = 0;
16083 +    proc sql noprint;
16084 +        create table _emtscm_label as
16085 +            select name,label
16086 +            from dictionary.columns
16087 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
16088 +        ;
16089 +        create table _emtscm_meta2 as
16090 +            select a.*, b.label
16091 +            from _emtscm_meta as a, _emtscm_label as b
16092 +            where upcase(a.timeID) eq upcase(b.name)
16093 +        ;
16094 +    quit;
16096 +    data &outDS;
16097 +        set _emtscm_meta2;
16098 +        format
16099 +            timeformat      $30.
16100 +            role            $10.
16101 +            start           &timeIDformat
16102 +            end             &timeIDformat
16103 +            apply_start_end $8.
16104 +        ;
16105 +        rename
16106 +            timeID      = name
16107 +            seasonality = lengthOfCycle
16108 +            interval    = timeinterval
16109 +        ;
16110 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
16112 +        role            = "TIMEID";
16113 +        apply_start_end = 'N';
16114 +        timeformat      = symget('timeIDformat');
16115 +        timeformattype  = symget('timeIDformatType');
16117 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
16118 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
16119 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
16120 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
16121 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
16122 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
16123 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
16124 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
16125 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
16126 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
16128 +        if timeformattype eq 'SEQ' then do;
16129 +            timeformat='BEST12.';
16130 +            seasonality=1;
16131 +        end;
16133 +        call symput('_tinterval',interval);
16135 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
16137 +        if upcase(timeformattype) eq 'DATE' and
16138 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
16139 +            then call symput('hasValidInterval',1);
16141 +        if upcase(timeformattype) eq 'DATETIME' and
16142 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
16143 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
16144 +            then call symput('hasValidInterval',1);
16146 +        if upcase(timeformattype) eq 'TIME' and
16147 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
16148 +            then call symput('hasValidInterval',1);
16150 +        if upcase(timeformattype) eq 'SEQ'
16151 +            then call symput('hasValidInterval',1);
16153 +        if upcase(timeformattype) eq 'USER'
16154 +            then call symput('hasValidInterval',1);
16156 +        if start eq end
16157 +            then call symput('hasLengthOne',1);
16158 +    run;
16160 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
16162 +    *** detect any missing time interval after running PROC TIMEID;
16163 +    %if &_tinterval eq %then %do;
16164 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
16165 +        %let EM_TS_ERR = 19;
16166 +        %put &em_codebar;
16167 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
16168 +        %put &errormsg;
16169 +        %put &em_codebar;
16170 +        %goto tscm_endline;
16171 +    %end;
16173 +    *** detect any missing time interval after running PROC TIMEID;
16174 +    %if &hasValidInterval eq 0 %then %do;
16175 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
16176 +        %let EM_TS_ERR = 20;
16177 +        %put &em_codebar;
16178 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
16179 +        %put &errormsg;
16180 +        %put &em_codebar;
16181 +        %goto tscm_endline;
16182 +    %end;
16184 +    %if &hasLengthOne eq 1 %then %do;
16185 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
16186 +        %let EM_TS_ERR = 21;
16187 +        %put &em_codebar;
16188 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
16189 +        %put &errormsg;
16190 +        %put &em_codebar;
16191 +        %goto tscm_endline;
16192 +    %end;
16194 +%end;
16196 +%tscm_endline:;
16198 +%mend EM_TS_CreateMetaData;
16201 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
16203 +data _null_;
16204 +    set &tsmeta;
16205 +    call symput('_timeidFormatType', timeformattype);
16206 +    call symput('_timeid', strip(name));
16207 +    call symput('_seqstartnum',strip(put(start,best12.)));
16208 +run;
16210 +proc contents data=&inDS noprint
16211 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
16212 +run; quit;
16214 +data _null_;
16215 +    set _emts_tmpp1;
16216 +    call symput('_timeIDlabel',label);
16217 +run;
16219 +%if &_timeidFormatType eq SEQ
16220 +%then %do;
16221 +    proc sql noprint;
16222 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
16223 +    quit;
16224 +    %let _dummystarttime=&_dummystarttime;
16226 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
16227 +        set &inDS;
16228 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
16229 +        drop &_timeid;
16230 +        label _tsdp_tmpID = "&_timeIDlabel";
16232 +    run;
16233 +%end;
16235 +%mend;
16237 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
16239 +data _null_;
16240 +    set &tsmeta;
16241 +    call symput('_timeidFormatType', timeformattype);
16242 +    call symput('_timeidFormat', timeformat);
16243 +    call symput('_timeid', strip(name));
16244 +    call symput('_timeinterval',strip(upcase(timeinterval)));
16245 +run;
16247 +/* manually change time ID format to a longer enough time format */
16248 +/* because proc timeid returns time5. for second time interval */
16249 +/* which is not long enough for transpose with time unit as seconds */
16250 +%if &_timeinterval eq SECOND
16251 +%then %do;
16252 +    %let _timeIDformat = %str(time8.);
16253 +%end;
16255 +proc contents data=&inDS noprint
16256 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
16257 +run; quit;
16259 +data _null_;
16260 +    set _emts_tmpp1;
16261 +    call symput('_timeIDlabel',label);
16262 +run;
16264 +%if &_timeidFormatType eq TIME
16265 +%then %do;
16266 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
16267 +        set &inDS;
16268 +        _tsdp_tmpID = timepart(&_timeID);
16269 +        format _tsdp_tmpID &_timeidFormat;
16270 +        label  _tsdp_tmpID = "&_timeIDlabel";
16271 +        drop &_timeid;
16272 +    run;
16273 +%end;
16275 +%mend;
16277 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
16279 + proc sql noprint;
16280 +     create table _tmptimetable as
16281 +         select distinct &timeidvar as DATE from &inDS
16282 +         where &timeIDVar is not missing
16283 +         order by &timeIDVar;
16284 + quit;
16286 +%if &compare eq Y %then %do;
16287 +    * compare with the existing time table;
16288 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
16289 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
16290 +    run;
16292 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
16294 +    %if &_diffobs > 0 %then %do; /* create it again */
16295 +        data &outDS(keep=DATE _INDEX_);
16296 +            set _tmptimetable end = _eof_;
16297 +            if _N_ = 1
16298 +                then _INDEX_ = 1;
16299 +                else _INDEX_ = 0;
16300 +            if _eof_ then _INDEX_= 2;
16301 +        run;
16302 +    %end;
16304 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
16305 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
16306 +%end;
16307 +%else %do;
16308 +    * create a new time table directly;
16309 +    data &outDS(keep=DATE _INDEX_);
16310 +        set _tmptimetable end = _eof_;
16311 +        if _N_ = 1
16312 +            then _INDEX_ = 1;
16313 +            else _INDEX_ = 0;
16314 +        if _eof_ then _INDEX_= 2;
16315 +    run;
16317 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
16318 +%end;
16320 +* assign a defult format BEST12. for sequential time ID;
16322 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
16324 +%let _nodatefmt=N;
16326 +data _null_;
16327 +    set _tmpcontents;
16328 +    where upcase(name) eq 'DATE';
16329 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
16330 +run;
16332 +%if "&_nodatefmt" eq "Y" %then %do;
16333 +    data &outDS;
16334 +        set &outDS;
16335 +        format date best12.;
16336 +    run;
16337 +%end;
16339 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
16341 +%mend;
16345 +%macro EM_TS_Transpose(
16346 +/*-------------------------------------------------------------------------*/
16347 +  inDS          =,      /* imported data set in TS data mining             */
16348 +  inIDMap       =,      /* input TS ID map                                 */
16349 +  variableSet   =,      /* variable set                                    */
16350 +  transposeBy   =,      /* byTSID or byTimeID                              */
16351 +  outDS         =,      /* output transposed data set                      */
16352 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
16353 +  inEM          =Y,
16354 +  timePrefix    =_T
16355 +/*-------------------------------------------------------------------------*/
16356 +);
16358 +%let timePrefix = &timePrefix;
16360 +%if  &EM_NUM_CROSSID > 0 %then %do;
16362 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
16363 +    set &inIDMap;
16364 +    drop _NAMEID_;
16365 +    run;
16366 +%let inIDMap=_emtstp_map0;
16368 +%end;
16370 +proc sql noprint;
16371 +    * number of TS Variables to be transposed;
16372 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
16373 +    ;
16374 +    * number of TS Variables to be transposed;
16375 +    select max(_TSID_) into :num_TSID from &inIDMap
16376 +    ;
16377 +    * name list of TS Variables;
16378 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
16379 +        from &inIDMap
16380 +        order by _NAMEID_
16381 +    ;
16382 +    * total number of time series =max(_TSID_)*&num_TSVar;
16383 +    * and the number of digits of this variable is &num_digits;
16384 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
16385 +        from &inIDMap
16386 +    ;
16387 +      * Time ID variable;
16388 +    select name into:timeIDVar from &variableset
16389 +        where upcase(role) eq 'TIMEID'
16390 +    ;
16391 +quit;
16392 +%let num_digits = &num_digits;
16393 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
16395 +/*-------------------------------------------------------------------------*/
16397 +* get number of cross IDs and also the TIME ID variable name;
16398 +%if &inEM eq Y %then %do;
16399 +    %let num_crossIDVar = &EM_NUM_CROSSID;
16400 +    %let crossIDVar     = %EM_CROSSID;
16401 +%end;
16402 +%else %do;
16403 +    proc sql noprint;
16404 +        * number of cross ID;
16405 +        select count(*) into :num_crossIDVar
16406 +            from &variableSet
16407 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16408 +        ;
16409 +        * create a string of crossID variable like A B C D..;
16410 +        select distinct name into :crossIDVar separated by ' '
16411 +            from &variableSet
16412 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
16413 +            order by name
16414 +        ;
16415 +    quit;
16416 +    %let num_crossIDVar=&num_crossIDVar;
16417 +%end;
16419 +/*-------------------------------------------------------------------------*/
16421 +%if (&num_crossIDVar gt 0) %then %do;
16423 +    data _emtstp_tmpDat;
16424 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
16425 +        _NAMEID_ = cats("_TS_",_TSID_);
16426 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
16427 +    run;
16429 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
16431 +        * update the ID maps;
16432 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
16433 +            by _NAMEID_ _TSID_;
16434 +        data &outIDMap;
16435 +            set _emtstp_tmpmap;
16436 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
16437 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
16438 +        run;
16440 +        * get the names for the new variables;
16441 +        proc sql noprint;
16442 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
16443 +            ;
16444 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
16445 +            ;
16446 +        quit;
16448 +        * data must be sorted before transposed;
16449 +        proc sort data=_emtstp_tmpDat;
16450 +            by &timeIDvar;
16451 +        run;
16453 +        %do i = 1 %to &num_TSVar;
16454 +            %let i = &i;
16455 +            * transpose one cross-type time series data by TSID;
16456 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
16457 +                id _NAMEID_;
16458 +                by &timeIDVar;
16459 +                var &&&TSVar&i;
16460 +            run;
16461 +        %end;
16463 +        * merge all vertical time series, rename and label them;
16464 +        data &outDS;
16465 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
16466 +            by &timeIDVar;
16467 +            rename
16468 +                %do i = 1 %to &num_TSVar;
16469 +                    %do j = 1 %to &num_TSID;
16470 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
16471 +                        /* %put &i &j &num1 &num_TSID; */
16472 +                        _V_&i._TS_&j = &&&tsname&num1
16473 +                    %end;
16474 +                %end;
16475 +            ;
16476 +            label
16477 +                %do i = 1 %to &num_TSVar;
16478 +                    %do j = 1 %to &num_TSID;
16479 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
16480 +                        /* %put &i &j &num1 &num_TSID; */
16481 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
16482 +                    %end;
16483 +                %end;
16484 +            ;
16485 +        run;
16486 +    %end;
16487 +    %else %do;
16489 +        * update the ID maps;
16490 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
16491 +            by _NAMEID_ _TSID_;
16492 +        data &outIDMap;
16493 +            set _emtstp_tmpmap;
16494 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
16495 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
16496 +        run;
16498 +        proc sql noprint;
16499 +            * get the roles for the new variables;
16500 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
16501 +                from &inIDMap
16502 +                order by _NAMEID_
16503 +            ;
16504 +            * get the length of the time series;
16505 +            select count(distinct &timeIDvar) into :num_T
16506 +                from _emtstp_tmpDat
16507 +            ;
16508 +        quit;
16510 +        * data must be sorted before transposed;
16511 +        proc sort data=_emtstp_tmpDat;
16512 +            by _TSID_ &crossIDVar &timeIDvar;
16513 +        run;
16515 +        %do i = 1 %to &num_TSVar;
16516 +            %let i = &i;
16517 +            * transpose one cross-type time series data by TIMEID;
16518 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
16519 +                by _TSID_ &crossIDVar;
16520 +                var &&&TSVar&i;
16521 +            run;
16522 +        %end;
16524 +        * stack all horizontal time series;
16525 +        data &outDS;
16526 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
16527 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
16528 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
16529 +            %do i=1 %to &num_TSVar;
16530 +                if in&i then do;
16531 +                    _NAMEID_ ="&&&TSVar&i";
16532 +                    _ROLE_   ="&&&TSRole&i";
16533 +                end;
16534 +            %end;
16535 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
16536 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
16537 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
16538 +        run;
16539 +    %end;
16540 +%end;
16541 +%else %do;
16543 +    proc sql noprint;
16544 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
16545 +            order by _NAMEID_
16546 +        ;
16547 +    quit;
16549 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
16550 +        * transpose the panel-type time series data by TSID;
16551 +        proc sort data=&inDS out=_emtstp_tmpDat;
16552 +            by &timeIDvar;
16553 +        proc transpose data=_emtstp_tmpDat
16554 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
16555 +            by &timeIDVar;
16556 +            var &panelTSVar;
16557 +        run;
16558 +        proc datasets lib=work nolist;
16559 +            modify _emtstp_tmpDat2;
16560 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
16561 +            run; quit;
16562 +    %end;
16563 +    %else %do;
16564 +        * transpose the panel-type time series data by TIMEID;
16565 +        proc sort data=&inDS out=_emtstp_tmpDat;
16566 +            by &timeIDvar;
16567 +        data _emtstp_tmpDat;
16568 +            set _emtstp_tmpDat;
16569 +            _tmp_ind=_n_;
16570 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
16571 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
16572 +            ID _tmp_ind;
16573 +            var &panelTSVar;
16574 +        run;
16575 +    %end;
16577 +      * merge ID maps to the transpose data set;
16578 +      proc sql noprint;
16579 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
16580 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
16581 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
16582 +          ;
16583 +      quit;
16585 +      * update the TS ID map;
16586 +      data &outIDMap;
16587 +          set &inIDMap;
16588 +      run;
16589 +%end;
16591 +proc datasets lib=work nolist;
16592 +    delete _emtstp:;
16593 +run; quit;
16595 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSSIM_TRAIN.SOURCE.
16596 +/*----------------------------------------------------------------------------------+
16597 + |
16598 + |   Title :
16599 + |   Similarity Search for Time Series Data Mining
16600 + |
16601 + |
16602 + |
16603 + |   Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
16604 + |
16605 + |   Notes:
16606 + +-----------------------------------------------------------------------------------*/
16609 +%macro EM_TSSIM_TRAIN;
16611 +/*---------- Check and assign the input data set --------------------------*/
16612 +%let _IMPORT_DATA  = ;
16613 +%let _IMPORT_CMETA = ;
16614 +%let _DATA_EMINFO  = ;
16615 +%let _EXPORT_DATA  = ;
16616 +%let _FILE_CDELTA  = ;
16618 +%if &EM_IMPORT_DATA ne  %then %do;
16619 +       %let _IMPORT_DATA   = &EM_IMPORT_DATA;
16620 +       %let _IMPORT_CMETA  = &EM_IMPORT_DATA_CMETA;
16621 +       %let _DATA_EMINFO   = &EM_IMPORT_DATA_EMINFO;
16622 +       %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
16623 +       %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRAIN;
16624 +%end;
16625 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
16626 +       %let _IMPORT_DATA   = &EM_IMPORT_TRANSACTION;
16627 +       %let _IMPORT_CMETA  = &EM_IMPORT_TRANSACTION_CMETA;
16628 +       %let _DATA_EMINFO   = &EM_IMPORT_TRANSACTION_EMINFO;
16629 +       %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
16630 +       %let _FILE_CDELTA  =  &EM_FILE_CDELTA_TRANSACTION;
16631 +%end;
16632 +%else %do;
16633 +       %let  EMEXCEPTIONSTRING = exception.server.tsdm.noinputdata;
16634 +       %goto ENDLINE;
16635 +%end;
16638 +/*-------------  check time id variable -----------------------------*/
16639 +%local _numTimeIDs;
16640 +%let _numTimeIDs=0;
16642 +proc sql noprint;
16643 +    select count(*) into :_numTimeIDs
16644 +    from &EM_DATA_VARIABLESET
16645 +    where upcase(role) eq 'TIMEID' and upcase(strip(level)) eq 'INTERVAL' and upcase(strip(use)) in ('Y' 'D');
16646 +quit;
16648 +%if &_numTimeIDs eq 0 %then %do;
16650 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
16651 +    %put &em_codebar;
16652 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
16653 +    %put &errormsg;
16654 +    %put &em_codebar;
16655 +    %goto ENDLINE;
16657 +%end;
16658 +%else %if &_numTimeIDs gt 1 %then %do;
16660 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
16661 +    %put &em_codebar;
16662 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
16663 +    %put &errormsg;
16664 +    %put &em_codebar;
16665 +    %goto ENDLINE;
16667 +%end;
16668 +/*------------------------------------------------------------------------
16669 +    May provide an automatic transpose in a future version
16670 +--------------------------------------------------------------------------*/
16673 +%EM_GETNAME(KEY=MAPDS, TYPE=DATA);
16674 +%EM_GETNAME(KEY=MULTBARDS, TYPE=DATA);
16675 +%EM_GETNAME(KEY=OUTSUMMARY, TYPE=DATA);
16676 +%EM_GETNAME(KEY=INPUTMAPDS, TYPE=DATA);
16677 +%EM_GETNAME(KEY=OUT, TYPE=DATA);
16678 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
16679 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
16681 +%EM_GETNAME(KEY=OUTMEASURE, TYPE=DATA);
16682 +%EM_GETNAME(KEY=OUTPATH, TYPE=DATA) ;
16683 +%EM_GETNAME(KEY=OUTSEQUENCE, TYPE=DATA);
16684 +%EM_GETNAME(KEY=GRAPH, TYPE=FOLDER);
16687 +%EM_TS_CreateMetadata(inDS=&_IMPORT_DATA, outDS =&EM_USER_TSMETA, variableSet =&EM_DATA_VARIABLESET, timeInterval=&EM_PROPERTY_TIMEINTERVAL, rc=);
16689 +%if &EM_TS_ERR gt 0 %then %do;
16690 +%goto endline;
16691 +%end;
16692 +%let EM_TS_ERR = 0;
16694 +%if &EM_NUM_CROSSID > 0 %then %do;
16695 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.needtranspose;
16696 +        %put &em_codebar;
16697 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.needtranspose_ERR, NOQUOTE));
16698 +        %put &errormsg;
16699 +        %put &em_codebar;
16700 +        %goto ENDLINE;
16701 +%end;
16704 +%EM_TS_CreateIDMap(inDS=&_IMPORT_DATA, outIDMap =&EM_USER_TSIDMAP, outDS =_tmp_DATA, variableSet =&EM_DATA_VARIABLESET, TSIDbyCrossID =Y);
16706 +%EM_TS_GETTSMETAVARS(TimeInterval=_timeinterval);
16708 +/*----------- Check variables  -----------------------*/
16710 +%let _clustering = &EM_PROPERTY_CLUSTERING ;
16712 +%if &_clustering eq  DEFAULT %then %do;
16713 +     %if  (&EM_NUM_INTERVAL_TARGET <1)  %then %let _clustering = Y ;
16714 +     %else %let _clustering = N;
16715 +%end;
16717 +%if (&_clustering eq N ) %then %do;
16719 +      %if (&EM_PROPERTY_OUTPUTDS eq CLUSTSEGMENT) %then %do;
16720 +           %put &em_codebar;
16721 +           %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.noclustering_ERR, NOQUOTE));
16722 +           %put &errormsg;
16723 +           %put &em_codebar;
16724 +       %end;
16726 +     %if (&EM_NUM_INTERVAL_TARGET < 1) %then %do;
16727 +        %if (&EM_NUM_INTERVAL_INPUT < 2) %then %do;
16728 +           %let EMEXCEPTIONSTRING = exception.server.tsdm.need2intervalinput;
16729 +           %put &em_codebar;
16730 +           %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.needtwoinput_ERR, NOQUOTE));
16731 +           %put &errormsg;
16732 +           %put &em_codebar;
16734 +           %goto ENDLINE;
16735 +        %end;
16736 +    %end;
16737 +    %else %do;
16739 +        %if (&EM_NUM_INTERVAL_INPUT < 1)  %then %do;
16740 +           %let EMEXCEPTIONSTRING = exception.server.tsdm.need1intervalinput;
16741 +           %put &em_codebar;
16742 +           %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.needoneinput_ERR, NOQUOTE));
16743 +           %put &errormsg;
16744 +           %put &em_codebar;
16746 +           %goto ENDLINE;
16747 +        %end;
16748 +    %end;
16749 +%end;
16750 +%else %do;
16751 +    %if &EM_PROPERTY_INCTARGETINDIST eq N %then  %do;
16752 +       /*changed by ruzhan */
16753 +       /* %if (&EM_NUM_INTERVAL_INPUT < 1) %then %do; */
16754 +            %if (&EM_NUM_INTERVAL_INPUT < 2) %then %do;
16755 +            %let EMEXCEPTIONSTRING =exception.server.tsdm.need2intervalinput;
16756 +            %put &em_codebar;
16757 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.needtwoinput_ERR, NOQUOTE));
16758 +            %put &errormsg;
16759 +            %put &em_codebar;
16761 +            %goto ENDLINE;
16762 +        %end;
16763 +    %end;
16764 +    %else %do;
16765 +        %let _nvar = %eval(&EM_NUM_INTERVAL_INPUT + &EM_NUM_INTERVAL_TARGET);
16766 +         /*changed by ruzhan */
16767 +         /* %if &_nvar < 1 %then %do; */
16768 +             %if &_nvar < 2 %then %do;
16769 +             /*----  need change this message like : need at least one input or target variable */
16770 +             %put "Need at least one input or target variable";
16771 +             %let EMEXCEPTIONSTRING = exception.server.tsdm.need1intervalinputtarget;   /* I18N */
16772 +             %put &em_codebar;
16773 +             %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.needoneinputtarget_ERR, NOQUOTE));
16774 +             %put &errormsg;
16775 +             %put &em_codebar;
16777 +             %goto ENDLINE;
16778 +         %end;
16779 +    %end;
16780 +%end;
16782 +/*------------ Train Code ---------------------------------------*/
16784 +%EM_TSSIM_Similarity(inds=&_IMPORT_DATA,
16785 +            outds=&_EXPORT_DATA,
16786 +            outsum=&EM_USER_OUTSUMMARY,
16787 +            outmeasure=&EM_USER_OUTMEASURE,
16788 +            outpath=&EM_USER_OUTPATH,
16789 +            outsequence = &EM_USER_OUTSEQUENCE,
16790 +            out=&EM_USER_OUT,
16791 +            exportdistancematrix =&EM_PROPERTY_EXPORTDISTANCEMATRIX,
16792 +            crossid=%EM_CROSSID,
16793 +            timeid=%EM_TIMEID,
16794 +            measure=&EM_PROPERTY_MEASURE,
16795 +            interval = &_timeinterval,
16796 +            accumulation = &EM_PROPERTY_ACCUMULATION,
16797 +            missing = &EM_PROPERTY_MISSING,
16798 +            slide = &EM_PROPERTY_SLIDE,
16799 +            normalization = &EM_PROPERTY_NORMALIZATION,
16800 +            clustering = &_clustering,
16801 +            inctargetindist = &EM_PROPERTY_INCTARGETINDIST,
16802 +            scale=&EM_PROPERTY_SCALE,
16803 +            compress=&EM_PROPERTY_COMPRESS,
16804 +            compglobalabs=&EM_PROPERTY_COMPGLOBALABS,
16805 +            compglobalpct=&EM_PROPERTY_COMPGLOBALPCT,
16806 +            complocalabs=&EM_PROPERTY_COMPLOCALABS,
16807 +            complocalpct=&EM_PROPERTY_COMPLOCALPCT,
16808 +            expand=&EM_PROPERTY_EXPAND,
16809 +            expglobalabs=&EM_PROPERTY_EXPGLOBALABS,
16810 +            expglobalpct=&EM_PROPERTY_EXPGLOBALPCT,
16811 +            explocalabs=&EM_PROPERTY_EXPLOCALABS,
16812 +            explocalpct=&EM_PROPERTY_EXPLOCALPCT
16813 +            );
16818 +%let _tsdpvarset = ;
16819 +%let dsid=%sysfunc(open(&_DATA_EMINFO));
16820 +%if &dsid > 0 %then %do;
16821 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
16822 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
16823 +    %do %while(^ %sysfunc(fetch(&dsid)));
16824 +        %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
16825 +        %if &_key eq TSDPVARSET %then %do;
16826 +            %let _tsdpvarset  = %sysfunc(getvarc(&dsid, &vn_data));
16827 +        %end;
16828 +    %end;
16829 +%end;
16830 +%let dsid = %sysfunc(close(&dsid));
16832 +data _null_;
16833 +     filename X "&_FILE_CDELTA";
16834 +     FILE X;
16835 +     %let dsid = %sysfunc(open(&EM_USER_SIMREJVAR));
16836 +     %if &dsid > 0 %then %do;
16837 +         %do %while(^ %sysfunc(fetch(&dsid)));
16838 +            %let rejvar = %sysfunc(getvarc(&dsid, 2));
16839 +            put "if upcase(NAME) eq upcase(""&rejvar"") then role=""REJECTED"" ;" ;
16840 +         %end;
16841 +         %let dsid = %sysfunc(close(&dsid));
16842 +     %end;
16844 +     %if &EM_PROPERTY_OUTPUTDS eq CLUSTSEGMENT  %then %do;
16845 +         put 'if upcase(strip(NAME)) eq "_NAMEID_" then role="ID" ;' ;
16846 +         put 'if upcase(strip(NAME)) eq "_TSID_" then role="ID" ;' ;
16847 +         put 'if upcase(strip(NAME)) eq "_ROLE_" then role="REJECTED" ;' ;
16848 +         put 'if upcase(strip(NAME)) eq "_SEGMENT_" then role="CROSSID" ;' ;
16849 +     %end;
16851 +     %if &EM_PROPERTY_OUTPUTDS eq DISTMATRIX %then %do;
16852 +         put 'if upcase(NAME) eq "_NAMEID_" then role="ID" ;' ;
16853 +         put 'if upcase(NAME) eq "_TSID_" then role="ID" ;' ;
16854 +         put 'if upcase(strip(NAME)) eq "_ROLE_" then role="REJECTED" ;' ;
16856 +         %let dsid=%sysfunc(open(&_tsdpvarset));
16857 +         %if &dsid > 0 %then %do;
16858 +             %let vn_name =%sysfunc(varnum(&dsid, NAME));
16859 +             %let vn_role =%sysfunc(varnum(&dsid, ROLE));
16860 +             %let vn_level =%sysfunc(varnum(&dsid, LEVEL));
16861 +             %do %while(^ %sysfunc(fetch(&dsid)));
16862 +                 %let _name  = %upcase(%sysfunc(getvarc(&dsid, &vn_name)));
16863 +                 %let _role  =  %upcase(%sysfunc(getvarc(&dsid, &vn_role)));
16864 +                 %let _level  = %upcase(%sysfunc(getvarc(&dsid, &vn_level)));
16865 +                 %if &_role eq CROSSID %then %do;
16866 +                     put "if upcase(NAME) eq ""&_name"" then ROLE=""CROSSID"" ;" ;
16867 +                 %end;
16868 +             %end;
16869 +         %end;
16870 +         %let dsid = %sysfunc(close(&dsid));
16871 +     %end;
16872 +  run;
16873 +%ENDLINE:
16874 +%mend EM_TSSIM_TRAIN;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.TSSIM_VARIABLESET.
      WHERE UPCASE(role)='TIMEID';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: View EMWS2.META_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_TRAIN.
NOTE: Table WORK._EMTSCM_INDS created, with 1096 rows and 1 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Number of time vectors processed: 1
NOTE: There were 1096 observations read from the data set WORK._EMTSCM_INDS.
NOTE: The data set WORK._EMTSCM_META has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table WORK._EMTSCM_LABEL created, with 1 rows and 2 columns.
 
NOTE: Table WORK._EMTSCM_META2 created, with 1 rows and 25 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      378:48    398:62    414:122   424:137   434:136   444:152
NOTE: There were 1 observations read from the data set WORK._EMTSCM_META2.
NOTE: The data set EMWS2.TSSIM_TSMETA has 1 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file WORK._EM_TSCM: (memtype=DATA) was not found, but appears on a DELETE statement.
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 13 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSSIM_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set EMWS2.TSSIM_TSIDMAP has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: View EMWS2.META_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_TRAIN.
NOTE: There were 1096 observations read from the data set EMWS2.META_TRAIN.
NOTE: The data set WORK._TMP_DATA has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Variable _varname_ is uninitialized.
NOTE: There were 12 observations read from the data set EMWS2.TSSIM_TSIDMAP.
NOTE: The data set EMWS2.TSSIM_TSIDMAP has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_INDS (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_LABEL (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META (memtype=DATA).
NOTE: Deleting WORK._EMTSCM_META2 (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.TSSIM_TSMETA.
NOTE: The PROCEDURE PRINT printed page 2.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
WARNING: Apparent symbolic reference EM_PROPERTY_EXPORTDISTANCEMATRIX not resolved.
 
NOTE: View EMWS2.META_TRAIN.VIEW used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
NOTE: There were 1096 observations read from the data set EMWS2.TSDP_TRAIN.
NOTE: There were 1096 observations read from the data set EMWS2.META_TRAIN.
NOTE: The data set WORK._TMPINDS has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1096 observations read from the data set WORK._TMPINDS.
NOTE: The data set WORK._TMPINDS has 1096 observations and 13 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Number of series processed:          12
NOTE: Number of input series processed:    11
NOTE: Number of target series processed:   1
NOTE: Number of analysis requested:        11
NOTE: Number of analysis failed:           0
NOTE: Number of slides requested:          11
NOTE: Number of slides failed:             0
NOTE: Number of measures requested:        11
NOTE: Number of measures failed:           0
NOTE: There were 1096 observations read from the data set WORK._TMPINDS.
NOTE: The data set EMWS2.TSSIM_OUT has 1096 observations and 13 variables.
NOTE: The data set EMWS2.TSSIM_OUTSUMMARY has 11 observations and 3 variables.
NOTE: PROCEDURE SIMILARITY used (Total process time):
      real time           0.10 seconds
      cpu time            0.06 seconds
 
 
 
NOTE: Deleting WORK._TMPINDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
WARNING: Apparent symbolic reference EM_USER_SIMREJVAR not resolved.
 
NOTE: The file X is:
      Filename=C:\Users\Oscar\Documents\Document\File need to backup\UM\Y4S1\Data Mining and Warehousing\GroupAssignment\GroupAssignment_2023\Workspaces\EMWS2\TSSIM\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=06Jan2024:00:17:50,
      Create Time=03Jan2024:17:03:19
 
NOTE: 0 records were written to the file X.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
16876
16877
16878  *------------------------------------------------------------*;
16879  * End TRAIN: TSSIM;
16880  *------------------------------------------------------------*;
 
16881  *------------------------------------------------------------*;
16882  * Close any missing semi colons;
16883  *------------------------------------------------------------*;
16884  ;
16885  ;
16886  ;
16887  ;
16888  quit;
16889  *------------------------------------------------------------*;
16890  * Close any unbalanced quotes;
16891  *------------------------------------------------------------*;
16892  /*; *"; *'; */
16893  ;
16894  run;
16895  quit;
16896  /* Reset EM Options */
16897  options formchar="|----|+|---+=|-/\<>*";
16898  options nocenter ls=256 ps=10000;
16899  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                January 06, 2024
Time:                00:17:51
*------------------------------------------------------------*
17001  %let EMEXCEPTIONSTRING=;
17002  *------------------------------------------------------------*;
17003  * SCORE: TSSIM;
17004  *------------------------------------------------------------*;
17005  %let EM_ACTION = SCORE;
17006  %let syscc = 0;
17007
17008  %macro EM_TSSIM_MAIN;
17009
17010     filename temp catalog 'sashelp.emtsdm.tssim_macros.source';
17011     %include temp;
17012     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
17013     %include temp;
17014     filename temp;
17015
17016     %if %upcase(&EM_ACTION) = CREATE %then %do;
17017         filename temp catalog 'sashelp.emtsdm.tssim_create.source';
17018         %include temp;
17019         filename temp;
17020         %EM_TSSIM_CREATE;
17021     %end;
17022     %else
17023     %if %upcase(&EM_ACTION) = TRAIN %then %do;
17024          filename temp catalog 'sashelp.emtsdm.tssim_train.source';
17025             %include temp;
17026             filename temp;
17027          %EM_TSSIM_TRAIN;
17028     %end;
17029     %else
17030     %if %upcase(&EM_ACTION) = SCORE %then %do;
17031             filename temp catalog 'sashelp.emtsdm.tssim_score.source';
17032             %include temp;
17033             filename temp;
17034          %EM_TSSIM_SCORE;
17035     %end;
17036     %else
17037     %if %upcase(&EM_ACTION) = REPORT %then %do;
17038             filename temp catalog 'sashelp.emtsdm.tssim_report.source';
17039             %include temp;
17040             filename temp;
17041          %EM_TSSIM_REPORT;
17042     %end;
17043
17044  %mend EM_TSSIM_MAIN;
17045  %EM_TSSIM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSSIM_MACROS.SOURCE.
17046 +/*----------------------------------------------------------------------------------+
17047 + |
17048 + |   Title :
17049 + |   TS Similarity Search Macros for Time Series Data Mining
17050 + |
17051 + |
17052 + |   Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
17053 + |
17054 + |   Notes:
17055 + |
17056 + |----------------------------------------------------------------------------------*/
17058 +%macro EM_TSSIM_Similarity(inds=,
17059 +                  outds=,
17060 +                  outsum=,
17061 +                  outmeasure=,
17062 +                  outpath=,
17063 +                  outsequence = ,
17064 +                  out= ,
17065 +                  exportdistancematrix=,
17066 +                  crossid=,
17067 +                  timeid=,
17068 +                  measure=,
17069 +                  interval=,
17070 +                  accumulation=,
17071 +                  missing=,
17072 +                  slide=,
17073 +                  normalization=,
17074 +                  clustering =,
17075 +                  inctargetindist=,
17076 +                  scale=,
17077 +                  compress=,
17078 +                  compglobalabs=,
17079 +                  compglobalpct=,
17080 +                  complocalabs=,
17081 +                  complocalpct=,
17082 +                  expand=,
17083 +                  expglobalabs=,
17084 +                  expglobalpct=,
17085 +                  explocalabs=,
17086 +                  explocalpct=
17087 +                  );
17089 +data _tmpinds(KEEP = &crossid &timeid %EM_TARGET  %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED);
17090 +     set &inds;
17091 +proc sort data=_tmpinds out=_tmpinds;
17092 +     by  &crossid &timeid;
17093 +run;
17095 +proc similarity data=_tmpinds
17096 +/*
17097 +%if ( &exportdistancematrix eq Y ) %then %do;
17098 +               outsum=&outds
17099 +               out=&out
17100 +%end;
17101 +%else %do;
17102 +               out=&outds
17103 +               outsum=&outsum
17104 +%end;
17105 +*/
17106 +               out=&EM_USER_OUT
17107 +               outsum=&EM_USER_OUTSUMMARY
17109 +              /* outmeasure=&outmeasure
17110 +                 outpath=&outpath
17111 +                 outsequence =&outsequence
17112 +               */
17113 +              /* print = summary*/
17115 +;
17116 +by &crossid;
17117 +id &timeid interval=&interval accumulate=&accumulation
17118 +%if &missing eq ZERO %then %do;
17119 +    setmissing= 0
17120 +%end;
17121 +%else %do;
17122 +    setmissing=&missing
17123 +%end;
17124 +;
17125 +%if (&clustering eq Y) or ( %EM_TARGET eq )  %then %do;
17126 +        target
17127 +        %if &inctargetindist eq Y %then %do;
17128 +          %EM_TARGET
17129 +        %end;
17130 +        %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED / measure=&measure normalize=&normalization slide=&slide TRIMMISSING=none
17131 +            %if &compress eq ABS %then %do;
17132 +               compress=(localabs=&complocalabs globalabs=&compglobalabs)
17133 +            %end;
17134 +            %else %if &compress eq PERCENT %then %do;
17135 +                compress=(localpct=&complocalpct globalpct=&compglobalpct)
17136 +            %end;
17138 +            %if &expand eq ABS %then %do;
17139 +            expand=(localabs=&explocalabs globalabs=&expglobalabs)
17140 +            %end;
17141 +            %else %if &expand eq PERCENT %then %do;
17142 +             expand=(localpct=&explocalpct globalpct=&expglobalpct)
17143 +            %end;
17144 +        ;
17145 +%end;
17146 +%else %do;
17147 +        target %EM_TARGET / measure=&measure normalize=&normalization slide=&slide TRIMMISSING=none
17148 +            %if &compress eq ABS %then %do;
17149 +               compress=(localabs=&complocalabs globalabs=&compglobalabs)
17150 +            %end;
17151 +            %else %if &compress eq PERCENT %then %do;
17152 +                compress=(localpct=&complocalpct globalpct=&compglobalpct)
17153 +            %end;
17155 +            %if &expand eq ABS %then %do;
17156 +            expand=(localabs=&explocalabs globalabs=&expglobalabs)
17157 +            %end;
17158 +            %else %if &expand eq PERCENT %then %do;
17159 +             expand=(localpct=&explocalpct globalpct=&expglobalpct)
17160 +            %end;
17161 +        ;
17162 +        input  %EM_INTERVAL_INPUT  %EM_INTERVAL_REJECTED /  normalize=&normalization scale=&scale TRIMMISSING=none ;
17163 +%end;
17165 +run;
17168 +/*
17170 +%if ( &exportdistancematrix eq Y ) %then %do;
17172 +        data &EM_USER_OUTSUMMARY;
17173 +             set &outds;
17174 +        run;
17175 +        data &outds;
17176 +             set &outds;
17177 +             DROP _STATUS_;
17178 +             rename _INPUT_ = _NAMEID_;
17179 +        run;
17180 +        *------ Merge TSIDMAP ---------;
17181 +        proc sort data = &EM_USER_TSIDMAP;
17182 +              by _NAMEID_;
17183 +        run;
17184 +        proc sort data = &outds;
17185 +              by _NAMEID_;
17186 +         run;
17187 +        data &outds;
17188 +             merge &EM_USER_TSIDMAP &outds;
17189 +              by _NAMEID_;
17190 +        run;
17192 +        %if &inctargetindist eq N %then %do;
17194 +       %let target = %EM_TARGET; * need to fix ;
17196 +        data &outds;
17197 +             merge &outds;
17198 +             if upcase(_NAMEID_) eq upcase("&target") then delete;
17199 +             drop _TSID_;
17200 +        run;
17202 +        %end;
17203 +%end;
17204 +  ---*/
17206 +/*%if ( (&EM_PROPERTY_EXPORTDISTANCEMATRIX eq Y ) or (%EM_TARGET eq ) ) and (&clustering eq Y ) %then %do;  */
17207 +  %if (&clustering eq Y ) %then %do;
17208 +     %EM_GETNAME(KEY=OUTTREE, TYPE=DATA);
17209 +     %EM_GETNAME(KEY=OUTLINK, TYPE=DATA);
17210 +     %EM_GETNAME(KEY=OUTNODE, TYPE=DATA);
17212 +     proc cluster data=&EM_USER_OUTSUMMARY(type=Distance drop=_STATUS_) method=Ward outtree=&EM_USER_OUTTREE;
17213 +         id _INPUT_;
17214 +         *by &crossid;
17215 +     run;
17217 +     %EM_TS_MakeConstellPlotData(intreedata=&EM_USER_OUTTREE, outnode=&EM_USER_OUTNODE, outlink=&EM_USER_OUTLINK);
17218 +%end;
17220 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpinds);
17221 +quit;
17223 +%mend EM_TSSIM_Similarity;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
17234 +/*
17235 +       MACRO: TS Utility macros
17237 +       PURPOSE: TS Utility macros
17238 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
17240 +       HISTORY:
17241 +       NOTE:
17243 +*/
17245 +/*
17246 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
17247 +                          timeid=, timeformat=, timeinformat=);
17248 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
17250 +    %do;
17251 +    %let m_data      = &data;
17252 +    %let m_decdata   = &decdata;
17253 +    %let m_decmeta   = &decmeta;
17254 +    %let m_cmeta     = &cmeta;
17255 +    %let m_outfile   = &outfile;
17256 +    %let m_crossid   = &crossid;
17257 +    %let m_timeid    = &timeid;
17258 +    %let m_timeformat    = &timeformat;
17259 +    %let m_timeinformat    = &timeinformat;
17260 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
17261 +  %end;
17262 +%mend EM_TS_CreateTsMetaDs;
17263 +*/
17264 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
17265 +proc sql;
17266 +      create table _tmp_inds
17267 +      as select distinct &timeid from  &indata;
17268 +quit;
17269 +run;
17270 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
17271 +  id &timeid
17272 +%if &timeinterval ne %then %do;
17273 +    %if &timeformattype eq DATE %then %do;
17274 +        interval=&timeinterval
17275 +    %end;
17276 +    %else %if &timeformattype eq DATETIME  %then %do;
17277 +        %let dttimeinterval= DT&timeinterval;
17278 +         interval=&dttimeinterval
17279 +    %end;
17280 +%end;
17281 +;
17282 +run;
17284 +data &outds;
17285 +     set _tmp_tsmeta;
17286 +     format START &timeformat;
17287 +     format END &timeformat;
17288 +     length APPLY_START_END $8;
17289 +     APPLY_START_END ="No";
17290 +     FORMAT = "&timeformat";
17291 +     ROLE ="TIMEID";
17292 +     rename TIMEID = NAME;
17293 +     rename SEASONALITY= LengthOfCycle;
17294 +     rename INTERVAL = TIMEINTERVAL ;
17295 +     rename FORMAT = TIMEFORMAT;
17296 +     output;
17297 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
17298 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
17299 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
17300 +run;
17302 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
17303 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
17305 +%mend EM_TS_CreateTSMetaData;
17309 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
17311 +/* if updated = Y it will pass the TSMETA created by just the previous node */
17313 +%let _tsmetads = ;
17315 +%if &updated = Y %then %do;
17316 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
17317 +%if %sysfunc(exist(&_tsmetads)) %then %do;
17318 +%goto endline;
17319 +%end;
17320 +%end;
17322 +%if &eminfodata eq %then %do;
17323 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17324 +    data &EM_DATA_EMINFO;
17325 +         set &EM_IMPORT_DATA_EMINFO;
17326 +    run;
17327 +%end;
17328 +%else %do;
17329 +    %let dsid=%sysfunc(open(&eminfodata));
17330 +    data &EM_DATA_EMINFO;
17331 +         set &eminfodata;
17332 +    run;
17333 +%end;
17334 +%if &dsid > 0 %then %do;
17335 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
17336 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
17337 +    %do %while(^ %sysfunc(fetch(&dsid)));
17338 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17339 +         %if &_key eq TSMETA %then %do;
17340 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
17341 +         %end;
17342 +    %end;
17343 +    %let dsid = %sysfunc(close(&dsid));
17344 +%end; /* the end of %if &dsid > 0 %then %do; */
17346 +%endline:
17348 +%if &_tsmetads ne %then %do;
17349 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
17350 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
17351 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
17352 +         data &EM_USER_TSMETA;
17353 +                   set &_tsmetads;
17354 +         run;
17355 +    %end;
17356 +%end;
17358 +*proc print data=&EM_DATA_EMINFO;
17359 +*proc print data=&EM_IMPORT_DATA_EMINFO;
17360 +*run;
17361 +%MEND EM_TS_GETTSMETA;
17364 +/*
17365 +%macro EM_GETTSMETAVARS(TimeInterval=);
17366 +%global &TimeInterval;
17367 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
17368 +%if &dsid > 0 %then %do;
17369 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
17370 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
17371 +%do %while(^ %sysfunc(fetch(&dsid)));
17372 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17373 +     %if &_role eq TIMEID %then %do;
17374 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
17375 +     %end;
17376 +%end;
17377 +%let dsid = %sysfunc(close(&dsid));
17378 +%end;
17379 +%MEND EM_GETTSMETAVARS;
17380 +*/
17381 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
17382 +%global &TimeInterval;
17383 +%global &TimeId;
17384 +%global &EndTime;
17385 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
17386 +proc print data=&EM_USER_TSMETA;
17387 +run;
17388 +%if &dsid > 0 %then %do;
17389 +%if &TimeInterval ne %then %do;
17390 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
17391 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17392 +    %do %while(^ %sysfunc(fetch(&dsid)));
17393 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17394 +        %if &_role eq TIMEID %then %do;
17395 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
17396 +        %end;
17397 +     %end;
17398 +%end;
17399 +%if &TimeId ne %then %do;
17400 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
17401 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17402 +    %do %while(^ %sysfunc(fetch(&dsid)));
17403 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17404 +        %if &_role eq TIMEID %then %do;
17405 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
17406 +        %end;
17407 +    %end;
17408 +%end;
17410 +%if &EndTime ne %then %do;
17411 +    %let vn_end =%sysfunc(varnum(&dsid, END));
17412 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
17413 +    %do %while(^ %sysfunc(fetch(&dsid)));
17414 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
17415 +        %if &_role eq TIMEID %then %do;
17416 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
17417 +        %end;
17418 +     %end;
17419 +%end;
17420 +%let dsid = %sysfunc(close(&dsid));
17421 +%end;
17422 +%MEND EM_TS_GETTSMETAVARS;
17426 +/*------------------------------------------------------------------
17428 +      Macro EM_GETTSIDMAP
17430 +------------------------------------------------------------------+*/
17433 +%macro EM_TS_GETTSIDMAP(updated=);
17435 +%let _tsidmap = ;
17437 +%if &updated = Y %then %do;
17438 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
17439 +%if %sysfunc(exist(&_tsidmap)) %then %do;
17440 +%goto endline;
17441 +%end;
17442 +%end;
17444 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
17445 +%if &dsid > 0 %then %do;
17446 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
17447 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
17448 +%do %while(^ %sysfunc(fetch(&dsid)));
17449 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
17450 +     %if &_key eq TSIDMAP %then %do;
17451 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
17452 +     %end;
17453 +%end;
17455 +%let dsid = %sysfunc(close(&dsid));
17456 +%end;
17458 +%endline:
17460 +%if &_tsidmap ne %then %do;
17462 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
17463 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
17465 +%if %sysfunc(exist(&_tsidmap)) %then %do;
17466 +         data &EM_USER_TSIDMAP;
17467 +               set &_tsidmap;
17468 +         run;
17469 +    %end;
17470 +%end;
17471 +%MEND EM_TS_GETTSIDMAP;
17473 +/*------------------------------------------------------------------*/
17478 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
17479 +%global &value;
17482 +%let dsid = %sysfunc(open(&data));
17483 +%if &dsid > 0 %then %do;
17484 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
17485 +    %if &vn_var < 1 %then %do;
17486 +        %let &value = 0;
17487 +        %let dsid = %sysfunc(close(&dsid));
17488 +        %goto endline;
17489 +    %end;
17490 +%let dsid = %sysfunc(close(&dsid));
17491 +%end;
17493 +%let _tmp=_tmpDS;
17494 +proc means data=&data &stat;
17495 +     var &var;
17496 +     output out=&_tmp;
17497 +run;
17499 +%let dsid = %sysfunc(open(&_tmp));
17500 +%if &dsid > 0 %then %do;
17501 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
17502 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
17503 +     %do %while(^%sysfunc(fetch(&dsid)));
17504 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
17505 +         %if &_stat eq &stat %then %do;
17506 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
17507 +          %end;
17508 +      %end;
17509 +%let dsid = %sysfunc(close(&dsid));
17510 +%end;
17511 +proc datasets lib=work nolist;
17512 + delete &_tmp;
17513 +run;
17514 +%endline:
17515 +%MEND EM_TS_GET_STAT;
17518 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
17519 +%global &format;
17520 +%global &informat;
17521 +%let dsid = %sysfunc(open(&data));
17522 +%if &dsid > 0 %then %do;
17523 +%let vn_var =%sysfunc(varnum(&dsid, &var));
17524 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
17525 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
17526 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
17527 +%end;
17528 +%let dsid = %sysfunc(close(&dsid));
17529 +%end;
17530 +%MEND EM_TS_GET_VAR_FORMAT;
17532 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
17533 +      %if &lib eq %then %let lib=work;
17534 +       proc datasets lib=&lib nolist;
17535 +              delete &dsname;
17536 +       run;
17537 +%Mend  EM_TS_DELETE_DATA;
17540 +%macro EM_TS_GetNObs(inds=, nobs=);
17541 +    %global &nobs;
17542 +    %let &nobs=0;
17543 +    data _null_;
17544 +        set &inds end=eof;
17545 +        if eof then call symput("&nobs", _N_);
17546 +    run;
17547 +    quit;
17549 +    /*
17550 +    %let dsid=%sysfunc(open(&outdata));
17551 +    %if dsid > 0 %then %do;
17552 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
17553 +        %let dsid = %sysfunc(close(&dsid));
17554 +     %end;
17555 +    */
17556 +%mend  EM_TS_GetNObs;
17559 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
17560 +%global &time1;
17561 +%global &time2;
17562 +%if &default = Y %then %do;
17563 +   data _null_;
17564 +        set &data end=eof;
17565 +        if _N_ = 1 then  call symput("&time1", DATE);
17566 +        if eof then call symput("&time2", DATE);
17567 +    run;%end;
17568 +%else %do;
17569 +    %let dsid = %sysfunc(open(&data));
17570 +    %if &dsid > 0 %then %do;
17571 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
17572 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
17573 +        %do %while(^%sysfunc(fetch(&dsid)));
17574 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
17575 +             %if &_index eq 1 %then %do;
17576 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
17577 +             %end;
17578 +             %if &_index eq 2 %then %do;
17579 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
17580 +             %end;
17581 +        %end;
17582 +    %let dsid = %sysfunc(close(&dsid));
17583 +    %end;
17584 +%end;
17586 +%MEND EM_TS_GET_TIME_VALUES;
17588 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
17589 +%global &exist;
17590 + %let &exist = N;
17591 +%let dsid = %sysfunc(open(&data));
17592 +%if &dsid > 0 %then %do;
17593 +%let vn_var =%sysfunc(varnum(&dsid, &var));
17594 +%if &vn_var > 0 %then %do;
17595 +    %let &exist = Y;
17596 +%end;
17597 +%let dsid = %sysfunc(close(&dsid));
17598 +%end;
17599 +%MEND EM_TS_GET_VAR_EXIST;
17602 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
17603 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
17604 +      set &intreedata;
17605 +        LENGTH NodeType $32;
17606 +      if _PARENT_ eq " " then delete;
17607 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
17608 +        else NodeType = "CLUSTER";
17609 +        LinkID = _N_;
17610 +run;
17611 +%Mend EM_TS_MakeConstellPlotData;
17616 +%macro EM_TS_CreateIDMap(
17617 +/*-------------------------------------------------------------------------*/
17618 +/*---   Written by Xiangxiang Meng                                         */
17619 +/*-------------------------------------------------------------------------*/
17620 +inDS          =,      /* imported data set in TS data mining               */
17621 +outIDMap      =,      /* output data set of TS ID map                      */
17622 +outDS         =,      /* output data set of TS and TS ID merged            */
17623 +variableSet   =,      /* EM variable set                                   */
17624 +TSIDbyCrossID =Y,
17625 +inEM          =Y
17626 +/*-------------------------------------------------------------------------*/
17627 +);
17629 +%global EM_TS_ERR;
17630 +%let EM_TS_ERR = 0;
17632 +%if &inEM eq Y %then %do;
17633 +    %let num_crossIDVar = &EM_NUM_CROSSID;
17634 +    proc sql noprint;
17635 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
17636 +    quit;
17637 +%end;
17638 +%else %do;
17639 +    proc sql noprint;
17640 +         select count(*) into :num_crossIDVar from &variableSet
17641 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17642 +         ;
17643 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
17644 +         ;
17645 +    quit;
17646 +    %let num_crossIDVar=&num_crossIDVar;
17647 +%end;
17649 +* see if _TSID_ exists;
17651 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
17652 +run;
17654 +proc sql noprint;
17655 +    select count(*) into :has_TSID
17656 +        from _emtscm_contents
17657 +        where upcase(strip(name)) eq '_TSID_'
17658 +    ;
17659 +quit;
17661 +/*-------------------------------------------------------------------------*/
17662 +* Creating TSID map..;
17663 +/*-------------------------------------------------------------------------*/
17665 +%if (&num_crossIDVar gt 0) %then %do;
17667 +    data _emtscm_tmpIDMap;
17668 +        set &variableSet;
17669 +        where  (upcase(strip(level)) eq 'INTERVAL')
17670 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
17671 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
17672 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
17673 +          );
17674 +        _emts_dummy=1;
17675 +        keep name label role _emts_dummy;
17676 +    run;
17678 +    proc sql noprint;
17679 +        * create a string of crossID variable like A,B,C,D..;
17680 +        select distinct name into :crossIDVar separated by ','
17681 +            from &variableSet
17682 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17683 +            order by name
17684 +        ;
17685 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
17686 +            from &variableSet
17687 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
17688 +            order by name
17689 +        ;
17690 +        * create the TSID map data set;
17691 +        create table _emtscm_tmp1 as
17692 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
17693 +        ;
17694 +        * create a level list of cross ID variables and time series variables;
17695 +        create table &outIDMap as
17696 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
17697 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
17698 +            where a._emts_dummy eq b._emts_dummy
17699 +            order by a.name, &crossIDVar
17700 +        ;
17701 +    quit;
17703 +    %if &TSIDbyCrossID = Y %then %do;
17704 +        * create unique TSID only by Cross ID;
17705 +        data &outIDMap;
17706 +            length _TSID_ 8;
17707 +            set &outIDMap;
17708 +            by _NAMEID_;
17709 +            if first._NAMEID_
17710 +                then _TSID_=1;
17711 +                else _TSID_+1;
17712 +        run;
17713 +        %if "&outDS" ne "" %then %do;
17714 +            * merge TSID into &inDS;
17715 +            proc sql noprint;
17716 +                create table &outDS as
17717 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
17718 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
17719 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
17720 +                        where %do i = 1 %to &num_crossIDVar;
17721 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
17722 +                              %end;
17723 +                             b._TSID_ is not missing
17724 +                    order by b._TSID_, a.&timeIDVar
17725 +                ;
17726 +            quit;
17727 +        %end;
17728 +    %end;
17729 +    %else %do;
17730 +        * create unique TSID by Cross ID and _NAMEID_;
17731 +        data &outIDMap;
17732 +            length _TSID_ 8;
17733 +            set &outIDMap;
17734 +            _TSID_=_n_;
17735 +        run;
17736 +        %if "&outDS" ne "" %then %do;
17737 +            *no merge in this output;
17738 +            data &outDS;
17739 +                set &inDS;
17740 +            run;
17741 +        %end;
17742 +    %end;
17744 +    proc sort data=&outIDMap;
17745 +        by _NAMEID_ _TSID_;
17746 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
17747 +        format _TSID_ best12. _NAMEID2_ $40.;
17748 +        set &outIDMap;
17749 +        by _NAMEID_;
17750 +        if first._NAMEID_
17751 +            then _emts_ind=1;
17752 +            else _emts_ind+1;
17753 +        drop _emts_ind;
17754 +        rename _NAMEID_=_VARNAME_;
17755 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
17756 +        if _labelID_ eq ' '
17757 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
17758 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
17759 +    run;
17761 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
17763 +%end;
17764 +%else %do; /* if no crossid's the nameid needs to be created */
17766 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
17767 +        length _TSID_ 8;
17768 +        set &variableSet;
17769 +        where  (upcase(strip(level)) eq 'INTERVAL')
17770 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
17771 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
17772 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
17773 +          );
17774 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
17775 +        rename ROLE = _ROLE_;
17776 +        _NAMEID_=strip(name);
17777 +        _VARNAME_=strip(name);
17778 +        if label eq ' '
17779 +            then _LABELID_ = strip(name);
17780 +            else _LABELID_ = strip(label);
17781 +        _TSID_=_n_;
17782 +    run;
17784 +    %if "&outDS" ne "" %then %do;
17785 +        *no merge in this output;
17786 +        data &outDS;
17787 +            set &inDS;
17788 +        run;
17789 +    %end;
17790 +%end;
17792 +data &outIDMap;
17793 +    set &outIDMap;
17794 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
17795 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
17796 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
17797 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
17798 +run;
17800 +proc datasets lib=work nolist;
17801 +    delete _emtscm_:;
17802 +run; quit;
17804 +%mend EM_TS_createIDMap;
17806 +%macro EM_TS_CreateMetaData(
17807 +/*-------------------------------------------------------------------------*/
17808 +  inDS          =,      /* imported data set in TS data mining             */
17809 +  outDS         =,      /* output data set of TS metadata                  */
17810 +  variableSet   =,      /* EM variable set                                 */
17811 +  timeInterval  =,      /* time interval                                   */
17812 +  rc            =       /* return code                                     */
17813 +/*-------------------------------------------------------------------------*/
17814 +);
17816 +%if %eval(
17817 +      &EM_NUM_BINARY_INPUT   +
17818 +      &EM_NUM_ORDINAL_INPUT  +
17819 +      &EM_NUM_NOMINAL_INPUT  +
17820 +      &EM_NUM_BINARY_REJECTED   +
17821 +      &EM_NUM_ORDINAL_REJECTED  +
17822 +      &EM_NUM_NOMINAL_REJECTED  +
17823 +      &EM_NUM_ORDINAL_TARGET  +
17824 +      &EM_NUM_NOMINAL_TARGET +
17825 +      &EM_NUM_BINARY_TARGET
17826 +      ) > 0
17827 +%then %do;
17828 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
17829 +        %put &em_codebar;
17830 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
17831 +        %put &errormsg;
17832 +        %put &em_codebar;
17833 +        %goto ENDLINE;
17834 +%end;
17836 +%global EM_TS_ERR;
17837 +%let EM_TS_ERR = 0;
17839 +%if &timeInterval eq AUTO
17840 +    %then %let timeInterval  = ;
17841 +    %else %let timeInterval  = %upcase(&timeInterval);
17843 +/*-------------------------------------------------------------------------*/
17844 +* check time ID variable;
17845 +/*-------------------------------------------------------------------------*/
17847 +* number of variables in the Variableset with ROLE=TIMEID;
17848 +proc sql noprint;
17849 +    select count(*) into :num_timeID from &variableset
17850 +        where upcase(role) eq 'TIMEID';
17851 +quit;
17853 +/*-------------------------------------------------------------------------*/
17854 +* process only when there is one Time ID, otherwise exception message;
17855 +/*-------------------------------------------------------------------------*/
17857 +%if &num_timeID eq 0 %then %do;
17859 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
17860 +    %let EM_TS_ERR = 11;
17861 +    %put &em_codebar;
17862 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
17863 +    %put &errormsg;
17864 +    %put &em_codebar;
17865 +    %goto tscm_endline;
17867 +%end;
17868 +%else %if &num_timeID gt 1 %then %do;
17870 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
17871 +    %let EM_TS_ERR = 12;
17872 +    %put &em_codebar;
17873 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
17874 +    %put &errormsg;
17875 +    %put &em_codebar;
17876 +    %goto tscm_endline;
17878 +%end;
17879 +%else %do;
17880 +    *** proceed when there is one Time ID;
17882 +    data _null_;
17883 +        set &variableset(where=(upcase(role)='TIMEID'));
17884 +        call symput('timeIDFormat',     strip(format));
17885 +        call symput('timeID',           strip(upcase(name)      ));
17886 +        call symput('timeIDLevel',      strip(upcase(level))     );
17887 +        call symput('timeIDFormatType', strip(upcase(formattype)));
17888 +    run;
17890 +    *** exception message if the time ID is not an interval variable;
17891 +    %if &timeIDLevel ne INTERVAL %then %do;
17892 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
17893 +        %let EM_TS_ERR = 13;
17894 +        %put &em_codebar;
17895 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
17896 +        %put &errormsg;
17897 +        %put &em_codebar;
17898 +        %goto tscm_endline;
17899 +    %end;
17901 +    %if (&timeIDFormatType ne DATETIME) and
17902 +        (&timeIDFormatType ne DATE) and
17903 +        (&timeIDFormatType ne TIME) and
17904 +        (&timeIDFormatType ne USER)
17905 +    %then %do;
17906 +        *** sequential format-type of time ID;
17908 +        %let timeInterval = DAY;
17909 +        %let timeIDFormatType = SEQ;
17911 +        proc sql noprint;
17912 +            create table _emtscm_inds as
17913 +                 select distinct &timeID from &inDS(keep=&timeID)
17914 +                 where &timeID is not missing;
17915 +            select count(*) into :num_nonInteger from _emtscm_inds
17916 +                where &timeID ne int(&timeID);
17917 +        quit;
17919 +        %if &num_nonInteger gt 0 %then %do;
17920 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
17921 +            %let EM_TS_ERR = 14;
17922 +            %put &em_codebar;
17923 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
17924 +            %put &errormsg;
17925 +            %put &em_codebar;
17926 +            %goto tscm_endline;
17927 +        %end;
17928 +    %end;
17929 +    %else %do;
17930 +        *** date, datetime, time format-type of time ID;
17932 +        *** must have a format;
17933 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
17934 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
17935 +            %let EM_TS_ERR = 15;
17936 +            %put &em_codebar;
17937 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
17938 +            %put &errormsg;
17939 +            %put &em_codebar;
17940 +            %goto tscm_endline;
17941 +        %end;
17943 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
17944 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
17945 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
17946 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
17947 +                %let EM_TS_ERR = 16;
17948 +                %put &em_codebar;
17949 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
17950 +                %put &errormsg;
17951 +                %put &em_codebar;
17952 +                %goto tscm_endline;
17953 +            %end;
17954 +        %end;
17956 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
17957 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
17958 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
17959 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
17960 +                %let EM_TS_ERR = 17;
17961 +                %put &em_codebar;
17962 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
17963 +                %put &errormsg;
17964 +                %put &em_codebar;
17965 +                %goto tscm_endline;
17966 +            %end;
17967 +        %end;
17969 +        *** the AUTO function is currently turned off for TIME timeID variable;
17970 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
17971 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
17972 +            %let EM_TS_ERR = 18;
17973 +            %put &em_codebar;
17974 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
17975 +            %put &errormsg;
17976 +            %put &em_codebar;
17977 +            %goto tscm_endline;
17978 +        %end;
17980 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
17981 +            %then %let timeInterval =DT&timeInterval;
17983 +        proc sql noprint;
17984 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
17985 +                where &timeID is not missing;
17986 +        quit;
17987 +    %end;
17989 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
17990 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
17991 +    run;
17993 +    %let hasValidInterval = 0;
17994 +    %let hasLengthOne     = 0;
17996 +    proc sql noprint;
17997 +        create table _emtscm_label as
17998 +            select name,label
17999 +            from dictionary.columns
18000 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
18001 +        ;
18002 +        create table _emtscm_meta2 as
18003 +            select a.*, b.label
18004 +            from _emtscm_meta as a, _emtscm_label as b
18005 +            where upcase(a.timeID) eq upcase(b.name)
18006 +        ;
18007 +    quit;
18009 +    data &outDS;
18010 +        set _emtscm_meta2;
18011 +        format
18012 +            timeformat      $30.
18013 +            role            $10.
18014 +            start           &timeIDformat
18015 +            end             &timeIDformat
18016 +            apply_start_end $8.
18017 +        ;
18018 +        rename
18019 +            timeID      = name
18020 +            seasonality = lengthOfCycle
18021 +            interval    = timeinterval
18022 +        ;
18023 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
18025 +        role            = "TIMEID";
18026 +        apply_start_end = 'N';
18027 +        timeformat      = symget('timeIDformat');
18028 +        timeformattype  = symget('timeIDformatType');
18030 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
18031 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
18032 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
18033 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
18034 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
18035 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
18036 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
18037 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
18038 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
18039 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
18041 +        if timeformattype eq 'SEQ' then do;
18042 +            timeformat='BEST12.';
18043 +            seasonality=1;
18044 +        end;
18046 +        call symput('_tinterval',interval);
18048 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
18050 +        if upcase(timeformattype) eq 'DATE' and
18051 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
18052 +            then call symput('hasValidInterval',1);
18054 +        if upcase(timeformattype) eq 'DATETIME' and
18055 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
18056 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
18057 +            then call symput('hasValidInterval',1);
18059 +        if upcase(timeformattype) eq 'TIME' and
18060 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
18061 +            then call symput('hasValidInterval',1);
18063 +        if upcase(timeformattype) eq 'SEQ'
18064 +            then call symput('hasValidInterval',1);
18066 +        if upcase(timeformattype) eq 'USER'
18067 +            then call symput('hasValidInterval',1);
18069 +        if start eq end
18070 +            then call symput('hasLengthOne',1);
18071 +    run;
18073 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
18075 +    *** detect any missing time interval after running PROC TIMEID;
18076 +    %if &_tinterval eq %then %do;
18077 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
18078 +        %let EM_TS_ERR = 19;
18079 +        %put &em_codebar;
18080 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
18081 +        %put &errormsg;
18082 +        %put &em_codebar;
18083 +        %goto tscm_endline;
18084 +    %end;
18086 +    *** detect any missing time interval after running PROC TIMEID;
18087 +    %if &hasValidInterval eq 0 %then %do;
18088 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
18089 +        %let EM_TS_ERR = 20;
18090 +        %put &em_codebar;
18091 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
18092 +        %put &errormsg;
18093 +        %put &em_codebar;
18094 +        %goto tscm_endline;
18095 +    %end;
18097 +    %if &hasLengthOne eq 1 %then %do;
18098 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
18099 +        %let EM_TS_ERR = 21;
18100 +        %put &em_codebar;
18101 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
18102 +        %put &errormsg;
18103 +        %put &em_codebar;
18104 +        %goto tscm_endline;
18105 +    %end;
18107 +%end;
18109 +%tscm_endline:;
18111 +%mend EM_TS_CreateMetaData;
18114 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
18116 +data _null_;
18117 +    set &tsmeta;
18118 +    call symput('_timeidFormatType', timeformattype);
18119 +    call symput('_timeid', strip(name));
18120 +    call symput('_seqstartnum',strip(put(start,best12.)));
18121 +run;
18123 +proc contents data=&inDS noprint
18124 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
18125 +run; quit;
18127 +data _null_;
18128 +    set _emts_tmpp1;
18129 +    call symput('_timeIDlabel',label);
18130 +run;
18132 +%if &_timeidFormatType eq SEQ
18133 +%then %do;
18134 +    proc sql noprint;
18135 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
18136 +    quit;
18137 +    %let _dummystarttime=&_dummystarttime;
18139 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
18140 +        set &inDS;
18141 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
18142 +        drop &_timeid;
18143 +        label _tsdp_tmpID = "&_timeIDlabel";
18145 +    run;
18146 +%end;
18148 +%mend;
18150 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
18152 +data _null_;
18153 +    set &tsmeta;
18154 +    call symput('_timeidFormatType', timeformattype);
18155 +    call symput('_timeidFormat', timeformat);
18156 +    call symput('_timeid', strip(name));
18157 +    call symput('_timeinterval',strip(upcase(timeinterval)));
18158 +run;
18160 +/* manually change time ID format to a longer enough time format */
18161 +/* because proc timeid returns time5. for second time interval */
18162 +/* which is not long enough for transpose with time unit as seconds */
18163 +%if &_timeinterval eq SECOND
18164 +%then %do;
18165 +    %let _timeIDformat = %str(time8.);
18166 +%end;
18168 +proc contents data=&inDS noprint
18169 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
18170 +run; quit;
18172 +data _null_;
18173 +    set _emts_tmpp1;
18174 +    call symput('_timeIDlabel',label);
18175 +run;
18177 +%if &_timeidFormatType eq TIME
18178 +%then %do;
18179 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
18180 +        set &inDS;
18181 +        _tsdp_tmpID = timepart(&_timeID);
18182 +        format _tsdp_tmpID &_timeidFormat;
18183 +        label  _tsdp_tmpID = "&_timeIDlabel";
18184 +        drop &_timeid;
18185 +    run;
18186 +%end;
18188 +%mend;
18190 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
18192 + proc sql noprint;
18193 +     create table _tmptimetable as
18194 +         select distinct &timeidvar as DATE from &inDS
18195 +         where &timeIDVar is not missing
18196 +         order by &timeIDVar;
18197 + quit;
18199 +%if &compare eq Y %then %do;
18200 +    * compare with the existing time table;
18201 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
18202 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
18203 +    run;
18205 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
18207 +    %if &_diffobs > 0 %then %do; /* create it again */
18208 +        data &outDS(keep=DATE _INDEX_);
18209 +            set _tmptimetable end = _eof_;
18210 +            if _N_ = 1
18211 +                then _INDEX_ = 1;
18212 +                else _INDEX_ = 0;
18213 +            if _eof_ then _INDEX_= 2;
18214 +        run;
18215 +    %end;
18217 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
18218 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
18219 +%end;
18220 +%else %do;
18221 +    * create a new time table directly;
18222 +    data &outDS(keep=DATE _INDEX_);
18223 +        set _tmptimetable end = _eof_;
18224 +        if _N_ = 1
18225 +            then _INDEX_ = 1;
18226 +            else _INDEX_ = 0;
18227 +        if _eof_ then _INDEX_= 2;
18228 +    run;
18230 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
18231 +%end;
18233 +* assign a defult format BEST12. for sequential time ID;
18235 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
18237 +%let _nodatefmt=N;
18239 +data _null_;
18240 +    set _tmpcontents;
18241 +    where upcase(name) eq 'DATE';
18242 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
18243 +run;
18245 +%if "&_nodatefmt" eq "Y" %then %do;
18246 +    data &outDS;
18247 +        set &outDS;
18248 +        format date best12.;
18249 +    run;
18250 +%end;
18252 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
18254 +%mend;
18258 +%macro EM_TS_Transpose(
18259 +/*-------------------------------------------------------------------------*/
18260 +  inDS          =,      /* imported data set in TS data mining             */
18261 +  inIDMap       =,      /* input TS ID map                                 */
18262 +  variableSet   =,      /* variable set                                    */
18263 +  transposeBy   =,      /* byTSID or byTimeID                              */
18264 +  outDS         =,      /* output transposed data set                      */
18265 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
18266 +  inEM          =Y,
18267 +  timePrefix    =_T
18268 +/*-------------------------------------------------------------------------*/
18269 +);
18271 +%let timePrefix = &timePrefix;
18273 +%if  &EM_NUM_CROSSID > 0 %then %do;
18275 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
18276 +    set &inIDMap;
18277 +    drop _NAMEID_;
18278 +    run;
18279 +%let inIDMap=_emtstp_map0;
18281 +%end;
18283 +proc sql noprint;
18284 +    * number of TS Variables to be transposed;
18285 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
18286 +    ;
18287 +    * number of TS Variables to be transposed;
18288 +    select max(_TSID_) into :num_TSID from &inIDMap
18289 +    ;
18290 +    * name list of TS Variables;
18291 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
18292 +        from &inIDMap
18293 +        order by _NAMEID_
18294 +    ;
18295 +    * total number of time series =max(_TSID_)*&num_TSVar;
18296 +    * and the number of digits of this variable is &num_digits;
18297 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
18298 +        from &inIDMap
18299 +    ;
18300 +      * Time ID variable;
18301 +    select name into:timeIDVar from &variableset
18302 +        where upcase(role) eq 'TIMEID'
18303 +    ;
18304 +quit;
18305 +%let num_digits = &num_digits;
18306 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
18308 +/*-------------------------------------------------------------------------*/
18310 +* get number of cross IDs and also the TIME ID variable name;
18311 +%if &inEM eq Y %then %do;
18312 +    %let num_crossIDVar = &EM_NUM_CROSSID;
18313 +    %let crossIDVar     = %EM_CROSSID;
18314 +%end;
18315 +%else %do;
18316 +    proc sql noprint;
18317 +        * number of cross ID;
18318 +        select count(*) into :num_crossIDVar
18319 +            from &variableSet
18320 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
18321 +        ;
18322 +        * create a string of crossID variable like A B C D..;
18323 +        select distinct name into :crossIDVar separated by ' '
18324 +            from &variableSet
18325 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
18326 +            order by name
18327 +        ;
18328 +    quit;
18329 +    %let num_crossIDVar=&num_crossIDVar;
18330 +%end;
18332 +/*-------------------------------------------------------------------------*/
18334 +%if (&num_crossIDVar gt 0) %then %do;
18336 +    data _emtstp_tmpDat;
18337 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
18338 +        _NAMEID_ = cats("_TS_",_TSID_);
18339 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
18340 +    run;
18342 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
18344 +        * update the ID maps;
18345 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
18346 +            by _NAMEID_ _TSID_;
18347 +        data &outIDMap;
18348 +            set _emtstp_tmpmap;
18349 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
18350 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
18351 +        run;
18353 +        * get the names for the new variables;
18354 +        proc sql noprint;
18355 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
18356 +            ;
18357 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
18358 +            ;
18359 +        quit;
18361 +        * data must be sorted before transposed;
18362 +        proc sort data=_emtstp_tmpDat;
18363 +            by &timeIDvar;
18364 +        run;
18366 +        %do i = 1 %to &num_TSVar;
18367 +            %let i = &i;
18368 +            * transpose one cross-type time series data by TSID;
18369 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
18370 +                id _NAMEID_;
18371 +                by &timeIDVar;
18372 +                var &&&TSVar&i;
18373 +            run;
18374 +        %end;
18376 +        * merge all vertical time series, rename and label them;
18377 +        data &outDS;
18378 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
18379 +            by &timeIDVar;
18380 +            rename
18381 +                %do i = 1 %to &num_TSVar;
18382 +                    %do j = 1 %to &num_TSID;
18383 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
18384 +                        /* %put &i &j &num1 &num_TSID; */
18385 +                        _V_&i._TS_&j = &&&tsname&num1
18386 +                    %end;
18387 +                %end;
18388 +            ;
18389 +            label
18390 +                %do i = 1 %to &num_TSVar;
18391 +                    %do j = 1 %to &num_TSID;
18392 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
18393 +                        /* %put &i &j &num1 &num_TSID; */
18394 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
18395 +                    %end;
18396 +                %end;
18397 +            ;
18398 +        run;
18399 +    %end;
18400 +    %else %do;
18402 +        * update the ID maps;
18403 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
18404 +            by _NAMEID_ _TSID_;
18405 +        data &outIDMap;
18406 +            set _emtstp_tmpmap;
18407 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
18408 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
18409 +        run;
18411 +        proc sql noprint;
18412 +            * get the roles for the new variables;
18413 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
18414 +                from &inIDMap
18415 +                order by _NAMEID_
18416 +            ;
18417 +            * get the length of the time series;
18418 +            select count(distinct &timeIDvar) into :num_T
18419 +                from _emtstp_tmpDat
18420 +            ;
18421 +        quit;
18423 +        * data must be sorted before transposed;
18424 +        proc sort data=_emtstp_tmpDat;
18425 +            by _TSID_ &crossIDVar &timeIDvar;
18426 +        run;
18428 +        %do i = 1 %to &num_TSVar;
18429 +            %let i = &i;
18430 +            * transpose one cross-type time series data by TIMEID;
18431 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
18432 +                by _TSID_ &crossIDVar;
18433 +                var &&&TSVar&i;
18434 +            run;
18435 +        %end;
18437 +        * stack all horizontal time series;
18438 +        data &outDS;
18439 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
18440 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
18441 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
18442 +            %do i=1 %to &num_TSVar;
18443 +                if in&i then do;
18444 +                    _NAMEID_ ="&&&TSVar&i";
18445 +                    _ROLE_   ="&&&TSRole&i";
18446 +                end;
18447 +            %end;
18448 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
18449 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
18450 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
18451 +        run;
18452 +    %end;
18453 +%end;
18454 +%else %do;
18456 +    proc sql noprint;
18457 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
18458 +            order by _NAMEID_
18459 +        ;
18460 +    quit;
18462 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
18463 +        * transpose the panel-type time series data by TSID;
18464 +        proc sort data=&inDS out=_emtstp_tmpDat;
18465 +            by &timeIDvar;
18466 +        proc transpose data=_emtstp_tmpDat
18467 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
18468 +            by &timeIDVar;
18469 +            var &panelTSVar;
18470 +        run;
18471 +        proc datasets lib=work nolist;
18472 +            modify _emtstp_tmpDat2;
18473 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
18474 +            run; quit;
18475 +    %end;
18476 +    %else %do;
18477 +        * transpose the panel-type time series data by TIMEID;
18478 +        proc sort data=&inDS out=_emtstp_tmpDat;
18479 +            by &timeIDvar;
18480 +        data _emtstp_tmpDat;
18481 +            set _emtstp_tmpDat;
18482 +            _tmp_ind=_n_;
18483 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
18484 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
18485 +            ID _tmp_ind;
18486 +            var &panelTSVar;
18487 +        run;
18488 +    %end;
18490 +      * merge ID maps to the transpose data set;
18491 +      proc sql noprint;
18492 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
18493 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
18494 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
18495 +          ;
18496 +      quit;
18498 +      * update the TS ID map;
18499 +      data &outIDMap;
18500 +          set &inIDMap;
18501 +      run;
18502 +%end;
18504 +proc datasets lib=work nolist;
18505 +    delete _emtstp:;
18506 +run; quit;
18508 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSSIM_SCORE.SOURCE.
18510 +/*----------------------------------------------------------------------------------+
18511 + |
18512 + |   Title :  TS Similarity Node
18513 + |
18514 + |
18515 + |  Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
18516 + |
18517 + +-----------------------------------------------------------------------------------*/
18519 +%macro EM_TSSIM_SCORE;
18521 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
18522 +%EM_GETNAME(KEY=OUTSUMMARY, TYPE=DATA);
18523 +%EM_GETNAME(KEY=OUT, TYPE=DATA);
18524 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
18527 +%let _EXPORT_DATA  = ;
18528 +%if &EM_IMPORT_DATA ne  %then %do;
18529 +       %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
18530 +%end;
18531 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
18532 +       %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
18533 +%end;
18535 +%let _clustering = &EM_PROPERTY_CLUSTERING ;
18536 +%if &_clustering eq  DEFAULT %then %do;
18537 +     %if  (&EM_NUM_INTERVAL_TARGET <1)  %then %let _clustering = Y ;
18538 +     %else %let _clustering = N;
18539 +%end;
18541 +%if ( &_clustering eq Y ) %then %do;
18543 +   %EM_GETNAME(KEY=CLUSTERDS, TYPE=DATA);
18544 +   %EM_GETNAME(KEY=OUTSEGMENT, TYPE=DATA);
18545 +   %EM_GETNAME(KEY=OUTTREE, TYPE=DATA);
18546 +   proc tree data=&EM_USER_OUTTREE ncl=&EM_PROPERTY_NCLUSTER
18547 +             out=&EM_USER_CLUSTERDS(rename=(_INPUT_=_NAMEID_)) horizontal;
18548 +        id _INPUT_;
18549 +        *by &crossid;
18550 +   run;
18552 +   proc datasets lib=work nolist;
18553 +     delete gseg / mt=cat;
18554 +   run;quit;
18557 +   proc sort data=&EM_USER_TSIDMAP; by _NAMEID_;
18558 +   proc sort data=&EM_USER_CLUSTERDS;by _NAMEID_;
18559 +   run;
18561 +   data &EM_USER_OUTSEGMENT;
18562 +        merge &EM_USER_TSIDMAP &EM_USER_CLUSTERDS;by _NAMEID_;
18563 +        drop CLUSNAME;
18564 +        label CLUSTER  ="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_cluster, noquote))";
18565 +        rename CLUSTER = _SEGMENT_;
18566 +   run;
18568 +%end;
18570 +%if ( &EM_PROPERTY_OUTPUTDS eq DISTMATRIX) %then %do;
18572 +      data &_EXPORT_DATA;
18573 +             set &EM_USER_OUTSUMMARY;
18574 +             DROP _STATUS_;
18575 +             rename _INPUT_ = _NAMEID_;
18576 +      run;
18577 +        /*------ Merge TSIDMAP ---------*/
18578 +      /*
18579 +      proc sort data = &EM_USER_TSIDMAP out=_tmpTSIDMAP(keep=_NAMEID_ _TSID_ %EM_CROSSID) ;
18580 +              by _NAMEID_;
18581 +      run; */
18582 +      proc sort data = &EM_USER_TSIDMAP;
18583 +              by _NAMEID_;
18584 +      run;
18585 +      proc sort data = &_EXPORT_DATA;
18586 +              by _NAMEID_;
18587 +      run;
18588 +      data &_EXPORT_DATA;
18589 +             merge &EM_USER_TSIDMAP &_EXPORT_DATA;
18590 +              by _NAMEID_;
18591 +      run;
18592 +/*
18593 +        %if &EM_PROPERTY_INCTARGETINDIST eq N %then %do;
18595 +           %let target = %EM_TARGET;
18596 +           data &_EXPORT_DATA;
18597 +             merge &_EXPORT_DATA;
18598 +             if upcase(_NAMEID_) eq upcase("&target") then delete;
18599 +             drop _TSID_;
18600 +           run;
18602 +        %end;
18603 +*/
18604 +%end;
18605 +%else %if ( &_clustering eq Y ) and ( &EM_PROPERTY_OUTPUTDS eq CLUSTSEGMENT ) %then %do;
18606 +       data &_EXPORT_DATA;
18607 +            set &EM_USER_OUTSEGMENT;
18608 +       run;
18609 +%end;
18610 +%else %do;
18612 +        %EM_TS_Time2Seq(inDS=&EM_USER_OUT, tsmeta=&EM_USER_TSMETA); /* If TimeInterval ne SEQ, this macro does not do anything */
18613 +        data &_EXPORT_DATA;
18614 +           set &EM_USER_OUT;
18615 +        run;
18616 +        %EM_TS_CreateIDMap(inDS=&_EXPORT_DATA, outIDMap =&EM_USER_TSIDMAP, outDS =&_EXPORT_DATA, variableSet =&EM_DATA_VARIABLESET, TSIDbyCrossID =Y);
18617 +%end;
18622 +%mend EM_TSSIM_SCORE;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: There were 1 observations read from the data set EMWS2.TSSIM_TSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK._EMTS_TMPP1 has 1 observations and 2 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._EMTS_TMPP1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set EMWS2.TSSIM_OUT.
NOTE: The data set EMWS2.TSSIM_TRAIN has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._EMTSCM_CONTENTS has 13 observations and 1 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 12 observations read from the data set EMWS2.TSSIM_VARIABLESET.
      WHERE (UPCASE(STRIP(level))='INTERVAL') and (((UPCASE(STRIP(role))='INPUT') and UPCASE(STRIP(use)) in ('D', 'Y')) or ((UPCASE(STRIP(role))='REJECTED') and (UPCASE(STRIP(use))='Y')) or ((UPCASE(STRIP(role))='TARGET') and UPCASE(STRIP(use)) in ('D',
      'Y')));
NOTE: The data set EMWS2.TSSIM_TSIDMAP has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set EMWS2.TSSIM_TRAIN.
NOTE: The data set EMWS2.TSSIM_TRAIN has 1096 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Variable _varname_ is uninitialized.
NOTE: There were 12 observations read from the data set EMWS2.TSSIM_TSIDMAP.
NOTE: The data set EMWS2.TSSIM_TSIDMAP has 12 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._EMTSCM_CONTENTS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
18626
18627
18628  *------------------------------------------------------------*;
18629  * End SCORE: TSSIM;
18630  *------------------------------------------------------------*;
 
18632  *------------------------------------------------------------*;
18633  * TSSIM: Computing metadata for TRAIN data;
18634  *------------------------------------------------------------*;
 
*------------------------------------------------------------*
* Report Log
Date:                January 06, 2024
Time:                00:17:51
*------------------------------------------------------------*
19003  %let EMEXCEPTIONSTRING=;
19004  *------------------------------------------------------------*;
19005  * REPORT: TSSIM;
19006  *------------------------------------------------------------*;
19007  %let EM_ACTION = REPORT;
19008  %let syscc = 0;
19009
19010  %macro EM_TSSIM_MAIN;
19011
19012     filename temp catalog 'sashelp.emtsdm.tssim_macros.source';
19013     %include temp;
19014     filename temp catalog 'sashelp.emtsdm.tsutility_macros.source';
19015     %include temp;
19016     filename temp;
19017
19018     %if %upcase(&EM_ACTION) = CREATE %then %do;
19019         filename temp catalog 'sashelp.emtsdm.tssim_create.source';
19020         %include temp;
19021         filename temp;
19022         %EM_TSSIM_CREATE;
19023     %end;
19024     %else
19025     %if %upcase(&EM_ACTION) = TRAIN %then %do;
19026          filename temp catalog 'sashelp.emtsdm.tssim_train.source';
19027             %include temp;
19028             filename temp;
19029          %EM_TSSIM_TRAIN;
19030     %end;
19031     %else
19032     %if %upcase(&EM_ACTION) = SCORE %then %do;
19033             filename temp catalog 'sashelp.emtsdm.tssim_score.source';
19034             %include temp;
19035             filename temp;
19036          %EM_TSSIM_SCORE;
19037     %end;
19038     %else
19039     %if %upcase(&EM_ACTION) = REPORT %then %do;
19040             filename temp catalog 'sashelp.emtsdm.tssim_report.source';
19041             %include temp;
19042             filename temp;
19043          %EM_TSSIM_REPORT;
19044     %end;
19045
19046  %mend EM_TSSIM_MAIN;
19047  %EM_TSSIM_MAIN;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSSIM_MACROS.SOURCE.
19048 +/*----------------------------------------------------------------------------------+
19049 + |
19050 + |   Title :
19051 + |   TS Similarity Search Macros for Time Series Data Mining
19052 + |
19053 + |
19054 + |   Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
19055 + |
19056 + |   Notes:
19057 + |
19058 + |----------------------------------------------------------------------------------*/
19060 +%macro EM_TSSIM_Similarity(inds=,
19061 +                  outds=,
19062 +                  outsum=,
19063 +                  outmeasure=,
19064 +                  outpath=,
19065 +                  outsequence = ,
19066 +                  out= ,
19067 +                  exportdistancematrix=,
19068 +                  crossid=,
19069 +                  timeid=,
19070 +                  measure=,
19071 +                  interval=,
19072 +                  accumulation=,
19073 +                  missing=,
19074 +                  slide=,
19075 +                  normalization=,
19076 +                  clustering =,
19077 +                  inctargetindist=,
19078 +                  scale=,
19079 +                  compress=,
19080 +                  compglobalabs=,
19081 +                  compglobalpct=,
19082 +                  complocalabs=,
19083 +                  complocalpct=,
19084 +                  expand=,
19085 +                  expglobalabs=,
19086 +                  expglobalpct=,
19087 +                  explocalabs=,
19088 +                  explocalpct=
19089 +                  );
19091 +data _tmpinds(KEEP = &crossid &timeid %EM_TARGET  %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED);
19092 +     set &inds;
19093 +proc sort data=_tmpinds out=_tmpinds;
19094 +     by  &crossid &timeid;
19095 +run;
19097 +proc similarity data=_tmpinds
19098 +/*
19099 +%if ( &exportdistancematrix eq Y ) %then %do;
19100 +               outsum=&outds
19101 +               out=&out
19102 +%end;
19103 +%else %do;
19104 +               out=&outds
19105 +               outsum=&outsum
19106 +%end;
19107 +*/
19108 +               out=&EM_USER_OUT
19109 +               outsum=&EM_USER_OUTSUMMARY
19111 +              /* outmeasure=&outmeasure
19112 +                 outpath=&outpath
19113 +                 outsequence =&outsequence
19114 +               */
19115 +              /* print = summary*/
19117 +;
19118 +by &crossid;
19119 +id &timeid interval=&interval accumulate=&accumulation
19120 +%if &missing eq ZERO %then %do;
19121 +    setmissing= 0
19122 +%end;
19123 +%else %do;
19124 +    setmissing=&missing
19125 +%end;
19126 +;
19127 +%if (&clustering eq Y) or ( %EM_TARGET eq )  %then %do;
19128 +        target
19129 +        %if &inctargetindist eq Y %then %do;
19130 +          %EM_TARGET
19131 +        %end;
19132 +        %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED / measure=&measure normalize=&normalization slide=&slide TRIMMISSING=none
19133 +            %if &compress eq ABS %then %do;
19134 +               compress=(localabs=&complocalabs globalabs=&compglobalabs)
19135 +            %end;
19136 +            %else %if &compress eq PERCENT %then %do;
19137 +                compress=(localpct=&complocalpct globalpct=&compglobalpct)
19138 +            %end;
19140 +            %if &expand eq ABS %then %do;
19141 +            expand=(localabs=&explocalabs globalabs=&expglobalabs)
19142 +            %end;
19143 +            %else %if &expand eq PERCENT %then %do;
19144 +             expand=(localpct=&explocalpct globalpct=&expglobalpct)
19145 +            %end;
19146 +        ;
19147 +%end;
19148 +%else %do;
19149 +        target %EM_TARGET / measure=&measure normalize=&normalization slide=&slide TRIMMISSING=none
19150 +            %if &compress eq ABS %then %do;
19151 +               compress=(localabs=&complocalabs globalabs=&compglobalabs)
19152 +            %end;
19153 +            %else %if &compress eq PERCENT %then %do;
19154 +                compress=(localpct=&complocalpct globalpct=&compglobalpct)
19155 +            %end;
19157 +            %if &expand eq ABS %then %do;
19158 +            expand=(localabs=&explocalabs globalabs=&expglobalabs)
19159 +            %end;
19160 +            %else %if &expand eq PERCENT %then %do;
19161 +             expand=(localpct=&explocalpct globalpct=&expglobalpct)
19162 +            %end;
19163 +        ;
19164 +        input  %EM_INTERVAL_INPUT  %EM_INTERVAL_REJECTED /  normalize=&normalization scale=&scale TRIMMISSING=none ;
19165 +%end;
19167 +run;
19170 +/*
19172 +%if ( &exportdistancematrix eq Y ) %then %do;
19174 +        data &EM_USER_OUTSUMMARY;
19175 +             set &outds;
19176 +        run;
19177 +        data &outds;
19178 +             set &outds;
19179 +             DROP _STATUS_;
19180 +             rename _INPUT_ = _NAMEID_;
19181 +        run;
19182 +        *------ Merge TSIDMAP ---------;
19183 +        proc sort data = &EM_USER_TSIDMAP;
19184 +              by _NAMEID_;
19185 +        run;
19186 +        proc sort data = &outds;
19187 +              by _NAMEID_;
19188 +         run;
19189 +        data &outds;
19190 +             merge &EM_USER_TSIDMAP &outds;
19191 +              by _NAMEID_;
19192 +        run;
19194 +        %if &inctargetindist eq N %then %do;
19196 +       %let target = %EM_TARGET; * need to fix ;
19198 +        data &outds;
19199 +             merge &outds;
19200 +             if upcase(_NAMEID_) eq upcase("&target") then delete;
19201 +             drop _TSID_;
19202 +        run;
19204 +        %end;
19205 +%end;
19206 +  ---*/
19208 +/*%if ( (&EM_PROPERTY_EXPORTDISTANCEMATRIX eq Y ) or (%EM_TARGET eq ) ) and (&clustering eq Y ) %then %do;  */
19209 +  %if (&clustering eq Y ) %then %do;
19210 +     %EM_GETNAME(KEY=OUTTREE, TYPE=DATA);
19211 +     %EM_GETNAME(KEY=OUTLINK, TYPE=DATA);
19212 +     %EM_GETNAME(KEY=OUTNODE, TYPE=DATA);
19214 +     proc cluster data=&EM_USER_OUTSUMMARY(type=Distance drop=_STATUS_) method=Ward outtree=&EM_USER_OUTTREE;
19215 +         id _INPUT_;
19216 +         *by &crossid;
19217 +     run;
19219 +     %EM_TS_MakeConstellPlotData(intreedata=&EM_USER_OUTTREE, outnode=&EM_USER_OUTNODE, outlink=&EM_USER_OUTLINK);
19220 +%end;
19222 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpinds);
19223 +quit;
19225 +%mend EM_TSSIM_Similarity;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSUTILITY_MACROS.SOURCE.
19236 +/*
19237 +       MACRO: TS Utility macros
19239 +       PURPOSE: TS Utility macros
19240 +       SUPPORT: Taiyeong Lee and Ruiwen Zhang
19242 +       HISTORY:
19243 +       NOTE:
19245 +*/
19247 +/*
19248 +%macro  EM_TS_CreateTsMetaDs(data= , decdata= , decmeta= , cmeta=, crossid=, outfile=,
19249 +                          timeid=, timeformat=, timeinformat=);
19250 + %global m_data m_decdata m_decmeta  m_cmeta m_outfile m_crossid m_timeid m_timeformat m_timeinformat;
19252 +    %do;
19253 +    %let m_data      = &data;
19254 +    %let m_decdata   = &decdata;
19255 +    %let m_decmeta   = &decmeta;
19256 +    %let m_cmeta     = &cmeta;
19257 +    %let m_outfile   = &outfile;
19258 +    %let m_crossid   = &crossid;
19259 +    %let m_timeid    = &timeid;
19260 +    %let m_timeformat    = &timeformat;
19261 +    %let m_timeinformat    = &timeinformat;
19262 +    dm "afa c=sashelp.emtsdm.Createtsmetads.scl";
19263 +  %end;
19264 +%mend EM_TS_CreateTsMetaDs;
19265 +*/
19266 +%macro  EM_TS_CreateTSMetaData(indata=, timeid=, timeformat=,timeformattype=, timeinterval=, outds=);
19267 +proc sql;
19268 +      create table _tmp_inds
19269 +      as select distinct &timeid from  &indata;
19270 +quit;
19271 +run;
19272 +proc timeid data=_tmp_inds outinterval=_tmp_tsmeta;
19273 +  id &timeid
19274 +%if &timeinterval ne %then %do;
19275 +    %if &timeformattype eq DATE %then %do;
19276 +        interval=&timeinterval
19277 +    %end;
19278 +    %else %if &timeformattype eq DATETIME  %then %do;
19279 +        %let dttimeinterval= DT&timeinterval;
19280 +         interval=&dttimeinterval
19281 +    %end;
19282 +%end;
19283 +;
19284 +run;
19286 +data &outds;
19287 +     set _tmp_tsmeta;
19288 +     format START &timeformat;
19289 +     format END &timeformat;
19290 +     length APPLY_START_END $8;
19291 +     APPLY_START_END ="No";
19292 +     FORMAT = "&timeformat";
19293 +     ROLE ="TIMEID";
19294 +     rename TIMEID = NAME;
19295 +     rename SEASONALITY= LengthOfCycle;
19296 +     rename INTERVAL = TIMEINTERVAL ;
19297 +     rename FORMAT = TIMEFORMAT;
19298 +     output;
19299 +     Label  ROLE  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
19300 +     Label  APPLY_START_END  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
19301 +     keep TIMEID ROLE START END INTERVAL SEASONALITY FORMAT APPLY_START_END;
19302 +run;
19304 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmptsmeta);
19305 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp_inds);
19307 +%mend EM_TS_CreateTSMetaData;
19311 +%macro EM_TS_GETTSMETA(updated=, eminfodata=);
19313 +/* if updated = Y it will pass the TSMETA created by just the previous node */
19315 +%let _tsmetads = ;
19317 +%if &updated = Y %then %do;
19318 +%let _tsmetads = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSMETA;
19319 +%if %sysfunc(exist(&_tsmetads)) %then %do;
19320 +%goto endline;
19321 +%end;
19322 +%end;
19324 +%if &eminfodata eq %then %do;
19325 +    %let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19326 +    data &EM_DATA_EMINFO;
19327 +         set &EM_IMPORT_DATA_EMINFO;
19328 +    run;
19329 +%end;
19330 +%else %do;
19331 +    %let dsid=%sysfunc(open(&eminfodata));
19332 +    data &EM_DATA_EMINFO;
19333 +         set &eminfodata;
19334 +    run;
19335 +%end;
19336 +%if &dsid > 0 %then %do;
19337 +    %let vn_data =%sysfunc(varnum(&dsid, DATA));
19338 +    %let vn_key =%sysfunc(varnum(&dsid, KEY));
19339 +    %do %while(^ %sysfunc(fetch(&dsid)));
19340 +         %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19341 +         %if &_key eq TSMETA %then %do;
19342 +              %let _tsmetads  = %sysfunc(getvarc(&dsid, &vn_data));
19343 +         %end;
19344 +    %end;
19345 +    %let dsid = %sysfunc(close(&dsid));
19346 +%end; /* the end of %if &dsid > 0 %then %do; */
19348 +%endline:
19350 +%if &_tsmetads ne %then %do;
19351 +    %EM_REGISTER(KEY=TSMETA, TYPE=DATA);
19352 +    %EM_GETNAME(KEY=TSMETA, TYPE=DATA);
19353 +     %if %sysfunc(exist(&_tsmetads)) %then %do;
19354 +         data &EM_USER_TSMETA;
19355 +                   set &_tsmetads;
19356 +         run;
19357 +    %end;
19358 +%end;
19360 +*proc print data=&EM_DATA_EMINFO;
19361 +*proc print data=&EM_IMPORT_DATA_EMINFO;
19362 +*run;
19363 +%MEND EM_TS_GETTSMETA;
19366 +/*
19367 +%macro EM_GETTSMETAVARS(TimeInterval=);
19368 +%global &TimeInterval;
19369 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19370 +%if &dsid > 0 %then %do;
19371 +%let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19372 +%let vn_role =%sysfunc(varnum(&dsid, ROLE));
19373 +%do %while(^ %sysfunc(fetch(&dsid)));
19374 +     %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19375 +     %if &_role eq TIMEID %then %do;
19376 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19377 +     %end;
19378 +%end;
19379 +%let dsid = %sysfunc(close(&dsid));
19380 +%end;
19381 +%MEND EM_GETTSMETAVARS;
19382 +*/
19383 +%macro EM_TS_GETTSMETAVARS(TimeInterval=, TimeId=, EndTime=);
19384 +%global &TimeInterval;
19385 +%global &TimeId;
19386 +%global &EndTime;
19387 +%let dsid=%sysfunc(open(&EM_USER_TSMETA));
19388 +proc print data=&EM_USER_TSMETA;
19389 +run;
19390 +%if &dsid > 0 %then %do;
19391 +%if &TimeInterval ne %then %do;
19392 +    %let vn_timeinterval =%sysfunc(varnum(&dsid, TIMEINTERVAL));
19393 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19394 +    %do %while(^ %sysfunc(fetch(&dsid)));
19395 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19396 +        %if &_role eq TIMEID %then %do;
19397 +            %let &TimeInterval  = %sysfunc(getvarc(&dsid, &vn_timeinterval));
19398 +        %end;
19399 +     %end;
19400 +%end;
19401 +%if &TimeId ne %then %do;
19402 +    %let vn_varname =%sysfunc(varnum(&dsid, NAME));
19403 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19404 +    %do %while(^ %sysfunc(fetch(&dsid)));
19405 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19406 +        %if &_role eq TIMEID %then %do;
19407 +            %let &TimeId  = %sysfunc(getvarc(&dsid, &vn_varname);
19408 +        %end;
19409 +    %end;
19410 +%end;
19412 +%if &EndTime ne %then %do;
19413 +    %let vn_end =%sysfunc(varnum(&dsid, END));
19414 +    %let vn_role =%sysfunc(varnum(&dsid, ROLE));
19415 +    %do %while(^ %sysfunc(fetch(&dsid)));
19416 +        %let _role  = %sysfunc(getvarc(&dsid, &vn_role));
19417 +        %if &_role eq TIMEID %then %do;
19418 +            %let &EndTime  = %sysfunc(getvarn(&dsid, &vn_end));
19419 +        %end;
19420 +     %end;
19421 +%end;
19422 +%let dsid = %sysfunc(close(&dsid));
19423 +%end;
19424 +%MEND EM_TS_GETTSMETAVARS;
19428 +/*------------------------------------------------------------------
19430 +      Macro EM_GETTSIDMAP
19432 +------------------------------------------------------------------+*/
19435 +%macro EM_TS_GETTSIDMAP(updated=);
19437 +%let _tsidmap = ;
19439 +%if &updated = Y %then %do;
19440 +%let _tsidmap = &EM_LIB..%sysfunc(strip(&EM_METASOURCE_NODEID))_TSIDMAP ;
19441 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19442 +%goto endline;
19443 +%end;
19444 +%end;
19446 +%let dsid=%sysfunc(open(&EM_IMPORT_DATA_EMINFO));
19447 +%if &dsid > 0 %then %do;
19448 +%let vn_data =%sysfunc(varnum(&dsid, DATA));
19449 +%let vn_key =%sysfunc(varnum(&dsid, KEY));
19450 +%do %while(^ %sysfunc(fetch(&dsid)));
19451 +     %let _key  = %sysfunc(getvarc(&dsid, &vn_key));
19452 +     %if &_key eq TSIDMAP %then %do;
19453 +          %let _tsidmap  = %sysfunc(getvarc(&dsid, &vn_data));
19454 +     %end;
19455 +%end;
19457 +%let dsid = %sysfunc(close(&dsid));
19458 +%end;
19460 +%endline:
19462 +%if &_tsidmap ne %then %do;
19464 +%EM_REGISTER(KEY=TSIDMAP, TYPE=DATA);
19465 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
19467 +%if %sysfunc(exist(&_tsidmap)) %then %do;
19468 +         data &EM_USER_TSIDMAP;
19469 +               set &_tsidmap;
19470 +         run;
19471 +    %end;
19472 +%end;
19473 +%MEND EM_TS_GETTSIDMAP;
19475 +/*------------------------------------------------------------------*/
19480 +%MACRO EM_TS_GET_STAT(data=, var=, stat=, value=);
19481 +%global &value;
19484 +%let dsid = %sysfunc(open(&data));
19485 +%if &dsid > 0 %then %do;
19486 +    %let vn_var =%sysfunc(varnum(&dsid, &var));
19487 +    %if &vn_var < 1 %then %do;
19488 +        %let &value = 0;
19489 +        %let dsid = %sysfunc(close(&dsid));
19490 +        %goto endline;
19491 +    %end;
19492 +%let dsid = %sysfunc(close(&dsid));
19493 +%end;
19495 +%let _tmp=_tmpDS;
19496 +proc means data=&data &stat;
19497 +     var &var;
19498 +     output out=&_tmp;
19499 +run;
19501 +%let dsid = %sysfunc(open(&_tmp));
19502 +%if &dsid > 0 %then %do;
19503 +     %let vn_var =%sysfunc(varnum(&dsid, &var));
19504 +     %let vn_stat =%sysfunc(varnum(&dsid, _STAT_));
19505 +     %do %while(^%sysfunc(fetch(&dsid)));
19506 +         %let _stat  = %sysfunc(getvarc(&dsid, &vn_stat));
19507 +         %if &_stat eq &stat %then %do;
19508 +            %let &value  = %sysfunc(getvarn(&dsid, &vn_var));
19509 +          %end;
19510 +      %end;
19511 +%let dsid = %sysfunc(close(&dsid));
19512 +%end;
19513 +proc datasets lib=work nolist;
19514 + delete &_tmp;
19515 +run;
19516 +%endline:
19517 +%MEND EM_TS_GET_STAT;
19520 +%MACRO EM_TS_GET_VAR_FORMAT(data=, var=, format=, informat=);
19521 +%global &format;
19522 +%global &informat;
19523 +%let dsid = %sysfunc(open(&data));
19524 +%if &dsid > 0 %then %do;
19525 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19526 +%if &vn_var > 0 %then %do; /* may causing a problem at this %if */
19527 +   %let &format  = %sysfunc(varfmt(&dsid, &vn_var));
19528 +   %let &informat  = %sysfunc(varinfmt(&dsid, &vn_var));
19529 +%end;
19530 +%let dsid = %sysfunc(close(&dsid));
19531 +%end;
19532 +%MEND EM_TS_GET_VAR_FORMAT;
19534 +%Macro EM_TS_DELETE_DATA(lib=, dsname=);
19535 +      %if &lib eq %then %let lib=work;
19536 +       proc datasets lib=&lib nolist;
19537 +              delete &dsname;
19538 +       run;
19539 +%Mend  EM_TS_DELETE_DATA;
19542 +%macro EM_TS_GetNObs(inds=, nobs=);
19543 +    %global &nobs;
19544 +    %let &nobs=0;
19545 +    data _null_;
19546 +        set &inds end=eof;
19547 +        if eof then call symput("&nobs", _N_);
19548 +    run;
19549 +    quit;
19551 +    /*
19552 +    %let dsid=%sysfunc(open(&outdata));
19553 +    %if dsid > 0 %then %do;
19554 +        %let _extobs = %sysfunc(attrn(&dsid, NOBS));
19555 +        %let dsid = %sysfunc(close(&dsid));
19556 +     %end;
19557 +    */
19558 +%mend  EM_TS_GetNObs;
19561 +%MACRO EM_TS_GET_TIME_VALUES(data=, time1=, time2=, default=);
19562 +%global &time1;
19563 +%global &time2;
19564 +%if &default = Y %then %do;
19565 +   data _null_;
19566 +        set &data end=eof;
19567 +        if _N_ = 1 then  call symput("&time1", DATE);
19568 +        if eof then call symput("&time2", DATE);
19569 +    run;%end;
19570 +%else %do;
19571 +    %let dsid = %sysfunc(open(&data));
19572 +    %if &dsid > 0 %then %do;
19573 +        %let vn_date =%sysfunc(varnum(&dsid, DATE));
19574 +        %let vn_index =%sysfunc(varnum(&dsid, _INDEX_));
19575 +        %do %while(^%sysfunc(fetch(&dsid)));
19576 +             %let _index  = %sysfunc(getvarn(&dsid, &vn_index));
19577 +             %if &_index eq 1 %then %do;
19578 +                %let &time1  = %sysfunc(getvarn(&dsid, &vn_date));
19579 +             %end;
19580 +             %if &_index eq 2 %then %do;
19581 +                %let &time2  = %sysfunc(getvarn(&dsid, &vn_date));
19582 +             %end;
19583 +        %end;
19584 +    %let dsid = %sysfunc(close(&dsid));
19585 +    %end;
19586 +%end;
19588 +%MEND EM_TS_GET_TIME_VALUES;
19590 +%MACRO EM_TS_GET_VAR_EXIST(data=, var=, exist=);
19591 +%global &exist;
19592 + %let &exist = N;
19593 +%let dsid = %sysfunc(open(&data));
19594 +%if &dsid > 0 %then %do;
19595 +%let vn_var =%sysfunc(varnum(&dsid, &var));
19596 +%if &vn_var > 0 %then %do;
19597 +    %let &exist = Y;
19598 +%end;
19599 +%let dsid = %sysfunc(close(&dsid));
19600 +%end;
19601 +%MEND EM_TS_GET_VAR_EXIST;
19604 +%macro EM_TS_MakeConstellPlotData(intreedata=, outnode=, outlink=);
19605 +data  &outlink &outnode(keep=_NAME_ NodeType LinkID);
19606 +      set &intreedata;
19607 +        LENGTH NodeType $32;
19608 +      if _PARENT_ eq " " then delete;
19609 +        if _INPUT_ ne " " then NodeType = "VARIABLE";
19610 +        else NodeType = "CLUSTER";
19611 +        LinkID = _N_;
19612 +run;
19613 +%Mend EM_TS_MakeConstellPlotData;
19618 +%macro EM_TS_CreateIDMap(
19619 +/*-------------------------------------------------------------------------*/
19620 +/*---   Written by Xiangxiang Meng                                         */
19621 +/*-------------------------------------------------------------------------*/
19622 +inDS          =,      /* imported data set in TS data mining               */
19623 +outIDMap      =,      /* output data set of TS ID map                      */
19624 +outDS         =,      /* output data set of TS and TS ID merged            */
19625 +variableSet   =,      /* EM variable set                                   */
19626 +TSIDbyCrossID =Y,
19627 +inEM          =Y
19628 +/*-------------------------------------------------------------------------*/
19629 +);
19631 +%global EM_TS_ERR;
19632 +%let EM_TS_ERR = 0;
19634 +%if &inEM eq Y %then %do;
19635 +    %let num_crossIDVar = &EM_NUM_CROSSID;
19636 +    proc sql noprint;
19637 +        select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID';
19638 +    quit;
19639 +%end;
19640 +%else %do;
19641 +    proc sql noprint;
19642 +         select count(*) into :num_crossIDVar from &variableSet
19643 +             where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19644 +         ;
19645 +         select name into :timeIDVar from &variableset where upcase(role) eq 'TIMEID'
19646 +         ;
19647 +    quit;
19648 +    %let num_crossIDVar=&num_crossIDVar;
19649 +%end;
19651 +* see if _TSID_ exists;
19653 +proc contents data=&inDS noprint out=_emtscm_contents(keep=name);
19654 +run;
19656 +proc sql noprint;
19657 +    select count(*) into :has_TSID
19658 +        from _emtscm_contents
19659 +        where upcase(strip(name)) eq '_TSID_'
19660 +    ;
19661 +quit;
19663 +/*-------------------------------------------------------------------------*/
19664 +* Creating TSID map..;
19665 +/*-------------------------------------------------------------------------*/
19667 +%if (&num_crossIDVar gt 0) %then %do;
19669 +    data _emtscm_tmpIDMap;
19670 +        set &variableSet;
19671 +        where  (upcase(strip(level)) eq 'INTERVAL')
19672 +              and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19673 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19674 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19675 +          );
19676 +        _emts_dummy=1;
19677 +        keep name label role _emts_dummy;
19678 +    run;
19680 +    proc sql noprint;
19681 +        * create a string of crossID variable like A,B,C,D..;
19682 +        select distinct name into :crossIDVar separated by ','
19683 +            from &variableSet
19684 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19685 +            order by name
19686 +        ;
19687 +        select distinct name into :IDVar1-:IDVar&num_crossIDVar
19688 +            from &variableSet
19689 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
19690 +            order by name
19691 +        ;
19692 +        * create the TSID map data set;
19693 +        create table _emtscm_tmp1 as
19694 +            select distinct &crossIDVar, 1 as _emts_dummy from &inDS
19695 +        ;
19696 +        * create a level list of cross ID variables and time series variables;
19697 +        create table &outIDMap as
19698 +            select distinct a.name as _NAMEID_ format=$32., a.role as _role_, a.label as _LABELID_ format=$200., &crossIDVar
19699 +            from _emtscm_tmpIDMap as a, _emtscm_tmp1 as b
19700 +            where a._emts_dummy eq b._emts_dummy
19701 +            order by a.name, &crossIDVar
19702 +        ;
19703 +    quit;
19705 +    %if &TSIDbyCrossID = Y %then %do;
19706 +        * create unique TSID only by Cross ID;
19707 +        data &outIDMap;
19708 +            length _TSID_ 8;
19709 +            set &outIDMap;
19710 +            by _NAMEID_;
19711 +            if first._NAMEID_
19712 +                then _TSID_=1;
19713 +                else _TSID_+1;
19714 +        run;
19715 +        %if "&outDS" ne "" %then %do;
19716 +            * merge TSID into &inDS;
19717 +            proc sql noprint;
19718 +                create table &outDS as
19719 +                    select a.*, b._TSID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
19720 +                    from &inDS%if &has_TSID gt 0 %then %do;(drop=_TSID_)%end;   as a,
19721 +                        (select distinct _TSID_, &crossIDVar from &outIDMap)    as b
19722 +                        where %do i = 1 %to &num_crossIDVar;
19723 +                                 (a.&&&IDVar&i eq b.&&&IDVar&i) and
19724 +                              %end;
19725 +                             b._TSID_ is not missing
19726 +                    order by b._TSID_, a.&timeIDVar
19727 +                ;
19728 +            quit;
19729 +        %end;
19730 +    %end;
19731 +    %else %do;
19732 +        * create unique TSID by Cross ID and _NAMEID_;
19733 +        data &outIDMap;
19734 +            length _TSID_ 8;
19735 +            set &outIDMap;
19736 +            _TSID_=_n_;
19737 +        run;
19738 +        %if "&outDS" ne "" %then %do;
19739 +            *no merge in this output;
19740 +            data &outDS;
19741 +                set &inDS;
19742 +            run;
19743 +        %end;
19744 +    %end;
19746 +    proc sort data=&outIDMap;
19747 +        by _NAMEID_ _TSID_;
19748 +    data &outIDMap(rename=(_NAMEID2_=_NAMEID_));
19749 +        format _TSID_ best12. _NAMEID2_ $40.;
19750 +        set &outIDMap;
19751 +        by _NAMEID_;
19752 +        if first._NAMEID_
19753 +            then _emts_ind=1;
19754 +            else _emts_ind+1;
19755 +        drop _emts_ind;
19756 +        rename _NAMEID_=_VARNAME_;
19757 +        _NAMEID2_=catx('_',_NAMEID_,_emts_ind);
19758 +        if _labelID_ eq ' '
19759 +            then _labelID_ = catx(' ',_NAMEID_,_emts_ind);
19760 +            else _labelID_ = catx(' ',_labelID_,_emts_ind);
19761 +    run;
19763 +    %EM_TS_DELETE_DATA(lib=work, dsname=_emtscm:);
19765 +%end;
19766 +%else %do; /* if no crossid's the nameid needs to be created */
19768 +    data &outIDMap(keep=_NAMEID_ _ROLE_ _TSID_ _LABELID_);
19769 +        length _TSID_ 8;
19770 +        set &variableSet;
19771 +        where  (upcase(strip(level)) eq 'INTERVAL')
19772 +            and ( (upcase(strip(role)) eq 'INPUT' and upcase(strip(use)) in ('Y' 'D'))
19773 +                 or (upcase(strip(role)) eq 'REJECTED' and upcase(strip(use)) eq 'Y')
19774 +                 or (upcase(strip(role)) eq 'TARGET' and upcase(strip(use)) in ('Y' 'D'))
19775 +          );
19776 +        format _NAMEID_ $40. _VARNAME_ $32. _LABELID_ $200.;
19777 +        rename ROLE = _ROLE_;
19778 +        _NAMEID_=strip(name);
19779 +        _VARNAME_=strip(name);
19780 +        if label eq ' '
19781 +            then _LABELID_ = strip(name);
19782 +            else _LABELID_ = strip(label);
19783 +        _TSID_=_n_;
19784 +    run;
19786 +    %if "&outDS" ne "" %then %do;
19787 +        *no merge in this output;
19788 +        data &outDS;
19789 +            set &inDS;
19790 +        run;
19791 +    %end;
19792 +%end;
19794 +data &outIDMap;
19795 +    set &outIDMap;
19796 +    label _tsid_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))";
19797 +    label _nameID_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))";
19798 +    label _labelID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_labelid, noquote))";
19799 +    label _varname_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvarname, noquote))";
19800 +run;
19802 +proc datasets lib=work nolist;
19803 +    delete _emtscm_:;
19804 +run; quit;
19806 +%mend EM_TS_createIDMap;
19808 +%macro EM_TS_CreateMetaData(
19809 +/*-------------------------------------------------------------------------*/
19810 +  inDS          =,      /* imported data set in TS data mining             */
19811 +  outDS         =,      /* output data set of TS metadata                  */
19812 +  variableSet   =,      /* EM variable set                                 */
19813 +  timeInterval  =,      /* time interval                                   */
19814 +  rc            =       /* return code                                     */
19815 +/*-------------------------------------------------------------------------*/
19816 +);
19818 +%if %eval(
19819 +      &EM_NUM_BINARY_INPUT   +
19820 +      &EM_NUM_ORDINAL_INPUT  +
19821 +      &EM_NUM_NOMINAL_INPUT  +
19822 +      &EM_NUM_BINARY_REJECTED   +
19823 +      &EM_NUM_ORDINAL_REJECTED  +
19824 +      &EM_NUM_NOMINAL_REJECTED  +
19825 +      &EM_NUM_ORDINAL_TARGET  +
19826 +      &EM_NUM_NOMINAL_TARGET +
19827 +      &EM_NUM_BINARY_TARGET
19828 +      ) > 0
19829 +%then %do;
19830 +        %let  EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintervalinputtarget;
19831 +        %put &em_codebar;
19832 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine,TSDM.USEONLYINTERVALINPUTTARGET_ERR , NOQUOTE));
19833 +        %put &errormsg;
19834 +        %put &em_codebar;
19835 +        %goto ENDLINE;
19836 +%end;
19838 +%global EM_TS_ERR;
19839 +%let EM_TS_ERR = 0;
19841 +%if &timeInterval eq AUTO
19842 +    %then %let timeInterval  = ;
19843 +    %else %let timeInterval  = %upcase(&timeInterval);
19845 +/*-------------------------------------------------------------------------*/
19846 +* check time ID variable;
19847 +/*-------------------------------------------------------------------------*/
19849 +* number of variables in the Variableset with ROLE=TIMEID;
19850 +proc sql noprint;
19851 +    select count(*) into :num_timeID from &variableset
19852 +        where upcase(role) eq 'TIMEID';
19853 +quit;
19855 +/*-------------------------------------------------------------------------*/
19856 +* process only when there is one Time ID, otherwise exception message;
19857 +/*-------------------------------------------------------------------------*/
19859 +%if &num_timeID eq 0 %then %do;
19861 +    %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1TIMEID;
19862 +    %let EM_TS_ERR = 11;
19863 +    %put &em_codebar;
19864 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USE1TIMEID_ERR, NOQUOTE));
19865 +    %put &errormsg;
19866 +    %put &em_codebar;
19867 +    %goto tscm_endline;
19869 +%end;
19870 +%else %if &num_timeID gt 1 %then %do;
19872 +    %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyonetimeid ;
19873 +    %let EM_TS_ERR = 12;
19874 +    %put &em_codebar;
19875 +    %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYONETIMEID_ERR, NOQUOTE));
19876 +    %put &errormsg;
19877 +    %put &em_codebar;
19878 +    %goto tscm_endline;
19880 +%end;
19881 +%else %do;
19882 +    *** proceed when there is one Time ID;
19884 +    data _null_;
19885 +        set &variableset(where=(upcase(role)='TIMEID'));
19886 +        call symput('timeIDFormat',     strip(format));
19887 +        call symput('timeID',           strip(upcase(name)      ));
19888 +        call symput('timeIDLevel',      strip(upcase(level))     );
19889 +        call symput('timeIDFormatType', strip(upcase(formattype)));
19890 +    run;
19892 +    *** exception message if the time ID is not an interval variable;
19893 +    %if &timeIDLevel ne INTERVAL %then %do;
19894 +        %let EMEXCEPTIONSTRING = exception.server.tsdm.useintervaltimeid;
19895 +        %let EM_TS_ERR = 13;
19896 +        %put &em_codebar;
19897 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEINTERVALTIMEID_ERR, NOQUOTE));
19898 +        %put &errormsg;
19899 +        %put &em_codebar;
19900 +        %goto tscm_endline;
19901 +    %end;
19903 +    %if (&timeIDFormatType ne DATETIME) and
19904 +        (&timeIDFormatType ne DATE) and
19905 +        (&timeIDFormatType ne TIME) and
19906 +        (&timeIDFormatType ne USER)
19907 +    %then %do;
19908 +        *** sequential format-type of time ID;
19910 +        %let timeInterval = DAY;
19911 +        %let timeIDFormatType = SEQ;
19913 +        proc sql noprint;
19914 +            create table _emtscm_inds as
19915 +                 select distinct &timeID from &inDS(keep=&timeID)
19916 +                 where &timeID is not missing;
19917 +            select count(*) into :num_nonInteger from _emtscm_inds
19918 +                where &timeID ne int(&timeID);
19919 +        quit;
19921 +        %if &num_nonInteger gt 0 %then %do;
19922 +            %let EMEXCEPTIONSTRING = exception.server.tsdm.useonlyintegerforseqtimeID;
19923 +            %let EM_TS_ERR = 14;
19924 +            %put &em_codebar;
19925 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.USEONLYINTEGERFORSEQTIMEID_ERR, NOQUOTE));
19926 +            %put &errormsg;
19927 +            %put &em_codebar;
19928 +            %goto tscm_endline;
19929 +        %end;
19930 +    %end;
19931 +    %else %do;
19932 +        *** date, datetime, time format-type of time ID;
19934 +        *** must have a format;
19935 +        %if ( &timeIDFormat = ) or  ( &timeIDFormat = .) %then %do;
19936 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeidformat;
19937 +            %let EM_TS_ERR = 15;
19938 +            %put &em_codebar;
19939 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEIDFORMAT_ERR, NOQUOTE));
19940 +            %put &errormsg;
19941 +            %put &em_codebar;
19942 +            %goto tscm_endline;
19943 +        %end;
19945 +         *** time intervals that are shorter than DAY cannot be used for a DATE timeID variable;
19946 +        %if (&timeIDFormatType eq DATE) and (&timeInterval ne ) %then %do;
19947 +            %if (&timeInterval eq HOUR) or (&timeInterval eq MINUTE) or (&timeInterval eq SECOND) %then %do;
19948 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfordate;
19949 +                %let EM_TS_ERR = 16;
19950 +                %put &em_codebar;
19951 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORDATE_ERR, NOQUOTE));
19952 +                %put &errormsg;
19953 +                %put &em_codebar;
19954 +                %goto tscm_endline;
19955 +            %end;
19956 +        %end;
19958 +        *** time intervals that are longer than HOUR cannot be used for a TIME timeID variable;
19959 +        %if (&timeIDFormatType eq TIME) and (&timeInterval ne ) %then %do;
19960 +            %if (&timeInterval ne HOUR) and (&timeInterval ne MINUTE) and (&timeInterval ne SECOND) %then %do;
19961 +                %let  EMEXCEPTIONSTRING = exception.server.tsdm.invalidtimeintervalfortime;
19962 +                %let EM_TS_ERR = 17;
19963 +                %put &em_codebar;
19964 +                %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVALFORTIME_ERR, NOQUOTE));
19965 +                %put &errormsg;
19966 +                %put &em_codebar;
19967 +                %goto tscm_endline;
19968 +            %end;
19969 +        %end;
19971 +        *** the AUTO function is currently turned off for TIME timeID variable;
19972 +        %if (&timeIDFormatType eq TIME) and (&timeInterval eq ) %then %do;
19973 +            %let  EMEXCEPTIONSTRING = exception.server.tsdm.noautointervalfortime;
19974 +            %let EM_TS_ERR = 18;
19975 +            %put &em_codebar;
19976 +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.NOAUTOINTERVALFORTIME_ERR, NOQUOTE));
19977 +            %put &errormsg;
19978 +            %put &em_codebar;
19979 +            %goto tscm_endline;
19980 +        %end;
19982 +        %if (&timeInterval ne ) and (&timeIDFormatType eq DATETIME)
19983 +            %then %let timeInterval =DT&timeInterval;
19985 +        proc sql noprint;
19986 +            create table _emtscm_inds as select distinct &timeID from &inDS(keep=&timeID)
19987 +                where &timeID is not missing;
19988 +        quit;
19989 +    %end;
19991 +    proc timeid data=_emtscm_inds outinterval=_emtscm_meta;
19992 +        id &timeID %if &timeInterval ne %then %do; interval=&timeinterval %end;;
19993 +    run;
19995 +    %let hasValidInterval = 0;
19996 +    %let hasLengthOne     = 0;
19998 +    proc sql noprint;
19999 +        create table _emtscm_label as
20000 +            select name,label
20001 +            from dictionary.columns
20002 +            where libname eq "WORK" and memname eq "_EMTSCM_INDS"
20003 +        ;
20004 +        create table _emtscm_meta2 as
20005 +            select a.*, b.label
20006 +            from _emtscm_meta as a, _emtscm_label as b
20007 +            where upcase(a.timeID) eq upcase(b.name)
20008 +        ;
20009 +    quit;
20011 +    data &outDS;
20012 +        set _emtscm_meta2;
20013 +        format
20014 +            timeformat      $30.
20015 +            role            $10.
20016 +            start           &timeIDformat
20017 +            end             &timeIDformat
20018 +            apply_start_end $8.
20019 +        ;
20020 +        rename
20021 +            timeID      = name
20022 +            seasonality = lengthOfCycle
20023 +            interval    = timeinterval
20024 +        ;
20025 +        keep timeID role seasonality interval timeformat start end apply_start_end timeformattype label;
20027 +        role            = "TIMEID";
20028 +        apply_start_end = 'N';
20029 +        timeformat      = symget('timeIDformat');
20030 +        timeformattype  = symget('timeIDformatType');
20032 +        label  timeID           = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_name,       noquote))";
20033 +        label  role             = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole,       noquote))";
20034 +        label  seasonality      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_lengthOfCycle, noquote))";
20035 +        label  interval         = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeinterval,  noquote))";
20036 +        label  timeformat       = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformat,    noquote))";
20037 +        label  start            = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timestart,     noquote))";
20038 +        label  end              = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeend,       noquote))";
20039 +        label  apply_start_end  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_applystartend, noquote))";
20040 +        label  timeformattype   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_timeformatype, noquote))";
20041 +        label  label            = "%sysfunc(sasmsg(sashelp.dmine, meta_label_vlabel,      noquote))";
20043 +        if timeformattype eq 'SEQ' then do;
20044 +            timeformat='BEST12.';
20045 +            seasonality=1;
20046 +        end;
20048 +        call symput('_tinterval',interval);
20050 +        *** add SEMIMON WEEKDAY17W DTSEMIMON DTWEEKDAY17W 05092012;
20052 +        if upcase(timeformattype) eq 'DATE' and
20053 +           upcase(interval) in ('YEAR' 'SEMIYEAR' 'QTR' 'MONTH' 'SEMIMONTH' 'TENDAY' 'WEEK' 'WEEKDAY' 'DAY' 'SEMIMON' 'WEEKDAY17W')
20054 +            then call symput('hasValidInterval',1);
20056 +        if upcase(timeformattype) eq 'DATETIME' and
20057 +           upcase(interval) in ('DTYEAR' 'DTSEMIYEAR' 'DTQTR' 'DTMONTH' 'DTSEMIMONTH' 'DTTENDAY'
20058 +                              'DTWEEK' 'DTWEEKDAY' 'DTDAY' 'DTHOUR' 'DTMINUTE' 'DTSECOND' 'DTSEMIMON' 'DTWEEKDAY17W')
20059 +            then call symput('hasValidInterval',1);
20061 +        if upcase(timeformattype) eq 'TIME' and
20062 +           upcase(interval) in ('HOUR' 'MINUTE' 'SECOND')
20063 +            then call symput('hasValidInterval',1);
20065 +        if upcase(timeformattype) eq 'SEQ'
20066 +            then call symput('hasValidInterval',1);
20068 +        if upcase(timeformattype) eq 'USER'
20069 +            then call symput('hasValidInterval',1);
20071 +        if start eq end
20072 +            then call symput('hasLengthOne',1);
20073 +    run;
20075 +    %EM_TS_DELETE_DATA(lib=work, dsname=_em_tscm: );
20077 +    *** detect any missing time interval after running PROC TIMEID;
20078 +    %if &_tinterval eq %then %do;
20079 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.INVALIDTIMEINTERVAL;
20080 +        %let EM_TS_ERR = 19;
20081 +        %put &em_codebar;
20082 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.INVALIDTIMEINTERVAL_ERR, NOQUOTE));
20083 +        %put &errormsg;
20084 +        %put &em_codebar;
20085 +        %goto tscm_endline;
20086 +    %end;
20088 +    *** detect any missing time interval after running PROC TIMEID;
20089 +    %if &hasValidInterval eq 0 %then %do;
20090 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.CANNOTAUTODETECTTIMEINTERVAL;
20091 +        %let EM_TS_ERR = 20;
20092 +        %put &em_codebar;
20093 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.CANNOTAUTODETECTTIMEINTERVAL_ERR, NOQUOTE));
20094 +        %put &errormsg;
20095 +        %put &em_codebar;
20096 +        %goto tscm_endline;
20097 +    %end;
20099 +    %if &hasLengthOne eq 1 %then %do;
20100 +        %let EMEXCEPTIONSTRING = exception.server.TIMESERIES.TIMESERIESTOOSHORT;
20101 +        %let EM_TS_ERR = 21;
20102 +        %put &em_codebar;
20103 +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, TSDM.TIMESERIESTOOSHORT_ERR, NOQUOTE));
20104 +        %put &errormsg;
20105 +        %put &em_codebar;
20106 +        %goto tscm_endline;
20107 +    %end;
20109 +%end;
20111 +%tscm_endline:;
20113 +%mend EM_TS_CreateMetaData;
20116 +%macro EM_TS_Time2Seq(inDS=,tsmeta=);
20118 +data _null_;
20119 +    set &tsmeta;
20120 +    call symput('_timeidFormatType', timeformattype);
20121 +    call symput('_timeid', strip(name));
20122 +    call symput('_seqstartnum',strip(put(start,best12.)));
20123 +run;
20125 +proc contents data=&inDS noprint
20126 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20127 +run; quit;
20129 +data _null_;
20130 +    set _emts_tmpp1;
20131 +    call symput('_timeIDlabel',label);
20132 +run;
20134 +%if &_timeidFormatType eq SEQ
20135 +%then %do;
20136 +    proc sql noprint;
20137 +        select min(&_timeid) format=date9. into :_dummystarttime from &inDS;
20138 +    quit;
20139 +    %let _dummystarttime=&_dummystarttime;
20141 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20142 +        set &inDS;
20143 +        _tsdp_tmpID = intck('DAY',"&_dummystarttime"d,&_timeid)+&_seqstartnum;
20144 +        drop &_timeid;
20145 +        label _tsdp_tmpID = "&_timeIDlabel";
20147 +    run;
20148 +%end;
20150 +%mend;
20152 +%macro EM_TS_Datetime2Time(inDS=,tsmeta=);
20154 +data _null_;
20155 +    set &tsmeta;
20156 +    call symput('_timeidFormatType', timeformattype);
20157 +    call symput('_timeidFormat', timeformat);
20158 +    call symput('_timeid', strip(name));
20159 +    call symput('_timeinterval',strip(upcase(timeinterval)));
20160 +run;
20162 +/* manually change time ID format to a longer enough time format */
20163 +/* because proc timeid returns time5. for second time interval */
20164 +/* which is not long enough for transpose with time unit as seconds */
20165 +%if &_timeinterval eq SECOND
20166 +%then %do;
20167 +    %let _timeIDformat = %str(time8.);
20168 +%end;
20170 +proc contents data=&inDS noprint
20171 +    out=_emts_tmpp1(keep=name label where=(upcase(name) eq "%upcase(&_timeID)"));
20172 +run; quit;
20174 +data _null_;
20175 +    set _emts_tmpp1;
20176 +    call symput('_timeIDlabel',label);
20177 +run;
20179 +%if &_timeidFormatType eq TIME
20180 +%then %do;
20181 +    data &inDS(rename=(_tsdp_tmpID=&_timeid));
20182 +        set &inDS;
20183 +        _tsdp_tmpID = timepart(&_timeID);
20184 +        format _tsdp_tmpID &_timeidFormat;
20185 +        label  _tsdp_tmpID = "&_timeIDlabel";
20186 +        drop &_timeid;
20187 +    run;
20188 +%end;
20190 +%mend;
20192 +%macro EM_TS_CreateTimeStartAndEnd(inDS=, outDS=, timeIDVar=, compare=N);
20194 + proc sql noprint;
20195 +     create table _tmptimetable as
20196 +         select distinct &timeidvar as DATE from &inDS
20197 +         where &timeIDVar is not missing
20198 +         order by &timeIDVar;
20199 + quit;
20201 +%if &compare eq Y %then %do;
20202 +    * compare with the existing time table;
20203 +    proc compare data=&EM_USER_TIMESTARTANDEND(keep=DATE)
20204 +        compare=_tmptimetable(keep=DATE) out=_tmpdiff outdif outnoequal noprint;
20205 +    run;
20207 +    %EM_TS_GetNObs(inds=_tmpdiff, nobs=_diffobs);
20209 +    %if &_diffobs > 0 %then %do; /* create it again */
20210 +        data &outDS(keep=DATE _INDEX_);
20211 +            set _tmptimetable end = _eof_;
20212 +            if _N_ = 1
20213 +                then _INDEX_ = 1;
20214 +                else _INDEX_ = 0;
20215 +            if _eof_ then _INDEX_= 2;
20216 +        run;
20217 +    %end;
20219 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmpdiff);
20220 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20221 +%end;
20222 +%else %do;
20223 +    * create a new time table directly;
20224 +    data &outDS(keep=DATE _INDEX_);
20225 +        set _tmptimetable end = _eof_;
20226 +        if _N_ = 1
20227 +            then _INDEX_ = 1;
20228 +            else _INDEX_ = 0;
20229 +        if _eof_ then _INDEX_= 2;
20230 +    run;
20232 +    %EM_TS_DELETE_DATA(lib=work, dsname=_tmptimetable);
20233 +%end;
20235 +* assign a defult format BEST12. for sequential time ID;
20237 +proc contents data=&outDS noprint out=_tmpcontents(keep=name format);
20239 +%let _nodatefmt=N;
20241 +data _null_;
20242 +    set _tmpcontents;
20243 +    where upcase(name) eq 'DATE';
20244 +    if strip(format) eq ' ' then call symput('_nodatefmt','Y');
20245 +run;
20247 +%if "&_nodatefmt" eq "Y" %then %do;
20248 +    data &outDS;
20249 +        set &outDS;
20250 +        format date best12.;
20251 +    run;
20252 +%end;
20254 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmpcontents);
20256 +%mend;
20260 +%macro EM_TS_Transpose(
20261 +/*-------------------------------------------------------------------------*/
20262 +  inDS          =,      /* imported data set in TS data mining             */
20263 +  inIDMap       =,      /* input TS ID map                                 */
20264 +  variableSet   =,      /* variable set                                    */
20265 +  transposeBy   =,      /* byTSID or byTimeID                              */
20266 +  outDS         =,      /* output transposed data set                      */
20267 +  outIDMap      =,      /* output TS ID map for the new transposed data set*/
20268 +  inEM          =Y,
20269 +  timePrefix    =_T
20270 +/*-------------------------------------------------------------------------*/
20271 +);
20273 +%let timePrefix = &timePrefix;
20275 +%if  &EM_NUM_CROSSID > 0 %then %do;
20277 +data _emtstp_map0(rename=(_VARNAME_=_NAMEID_));
20278 +    set &inIDMap;
20279 +    drop _NAMEID_;
20280 +    run;
20281 +%let inIDMap=_emtstp_map0;
20283 +%end;
20285 +proc sql noprint;
20286 +    * number of TS Variables to be transposed;
20287 +    select count(distinct _NAMEID_) into :num_TSVar from &inIDMap
20288 +    ;
20289 +    * number of TS Variables to be transposed;
20290 +    select max(_TSID_) into :num_TSID from &inIDMap
20291 +    ;
20292 +    * name list of TS Variables;
20293 +    select distinct _NAMEID_ into :TSVar1-:TSVar%left(&num_TSVar)
20294 +        from &inIDMap
20295 +        order by _NAMEID_
20296 +    ;
20297 +    * total number of time series =max(_TSID_)*&num_TSVar;
20298 +    * and the number of digits of this variable is &num_digits;
20299 +    select ceil(log(max(_TSID_)*&num_TSVar+1)/log(10)) into :num_digits
20300 +        from &inIDMap
20301 +    ;
20302 +      * Time ID variable;
20303 +    select name into:timeIDVar from &variableset
20304 +        where upcase(role) eq 'TIMEID'
20305 +    ;
20306 +quit;
20307 +%let num_digits = &num_digits;
20308 +%let num_TS     = %eval(&num_TSVar*&num_TSID);
20310 +/*-------------------------------------------------------------------------*/
20312 +* get number of cross IDs and also the TIME ID variable name;
20313 +%if &inEM eq Y %then %do;
20314 +    %let num_crossIDVar = &EM_NUM_CROSSID;
20315 +    %let crossIDVar     = %EM_CROSSID;
20316 +%end;
20317 +%else %do;
20318 +    proc sql noprint;
20319 +        * number of cross ID;
20320 +        select count(*) into :num_crossIDVar
20321 +            from &variableSet
20322 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20323 +        ;
20324 +        * create a string of crossID variable like A B C D..;
20325 +        select distinct name into :crossIDVar separated by ' '
20326 +            from &variableSet
20327 +            where upcase(role) eq "CROSSID" and upcase(use) in ('Y' 'D')
20328 +            order by name
20329 +        ;
20330 +    quit;
20331 +    %let num_crossIDVar=&num_crossIDVar;
20332 +%end;
20334 +/*-------------------------------------------------------------------------*/
20336 +%if (&num_crossIDVar gt 0) %then %do;
20338 +    data _emtstp_tmpDat;
20339 +        set &inDS(keep=%do i=1 %to &num_TSVar; &&&TSVar&i %end; &crossIDVar &timeIDVar _TSID_);
20340 +        _NAMEID_ = cats("_TS_",_TSID_);
20341 +        label %do i=1 %to &num_TSVar; &&&TSVar&i=" " %end; ;
20342 +    run;
20344 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20346 +        * update the ID maps;
20347 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20348 +            by _NAMEID_ _TSID_;
20349 +        data &outIDMap;
20350 +            set _emtstp_tmpmap;
20351 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20352 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20353 +        run;
20355 +        * get the names for the new variables;
20356 +        proc sql noprint;
20357 +            select strip(_NAMEID_) into :tsname1-:tsname%left(&num_TS) from &outIDMap
20358 +            ;
20359 +            select strip(_LABELID_) into :tslabel1-:tslabel%left(&num_TS) from &outIDMap
20360 +            ;
20361 +        quit;
20363 +        * data must be sorted before transposed;
20364 +        proc sort data=_emtstp_tmpDat;
20365 +            by &timeIDvar;
20366 +        run;
20368 +        %do i = 1 %to &num_TSVar;
20369 +            %let i = &i;
20370 +            * transpose one cross-type time series data by TSID;
20371 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=_V_&i;
20372 +                id _NAMEID_;
20373 +                by &timeIDVar;
20374 +                var &&&TSVar&i;
20375 +            run;
20376 +        %end;
20378 +        * merge all vertical time series, rename and label them;
20379 +        data &outDS;
20380 +            merge %do i=1 %to &num_TSVar; _emtstp_td&i %end;;
20381 +            by &timeIDVar;
20382 +            rename
20383 +                %do i = 1 %to &num_TSVar;
20384 +                    %do j = 1 %to &num_TSID;
20385 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20386 +                        /* %put &i &j &num1 &num_TSID; */
20387 +                        _V_&i._TS_&j = &&&tsname&num1
20388 +                    %end;
20389 +                %end;
20390 +            ;
20391 +            label
20392 +                %do i = 1 %to &num_TSVar;
20393 +                    %do j = 1 %to &num_TSID;
20394 +                        %let num1 = %eval((&i-1)*&num_TSID+&j);
20395 +                        /* %put &i &j &num1 &num_TSID; */
20396 +                        _V_&i._TS_&j = "%nrbquote(&&&tslabel&num1)"
20397 +                    %end;
20398 +                %end;
20399 +            ;
20400 +        run;
20401 +    %end;
20402 +    %else %do;
20404 +        * update the ID maps;
20405 +        proc sort data=&inIDMap out=_emtstp_tmpmap;
20406 +            by _NAMEID_ _TSID_;
20407 +        data &outIDMap;
20408 +            set _emtstp_tmpmap;
20409 +            *_LABELID_ = catx(' ',_LABELID_,_TSID_);
20410 +            _NAMEID_  = cats("_TS_",put(_N_,z&num_digits..));
20411 +        run;
20413 +        proc sql noprint;
20414 +            * get the roles for the new variables;
20415 +            select distinct _role_ into :TSRole1-:TSRole%left(&num_TSVar)
20416 +                from &inIDMap
20417 +                order by _NAMEID_
20418 +            ;
20419 +            * get the length of the time series;
20420 +            select count(distinct &timeIDvar) into :num_T
20421 +                from _emtstp_tmpDat
20422 +            ;
20423 +        quit;
20425 +        * data must be sorted before transposed;
20426 +        proc sort data=_emtstp_tmpDat;
20427 +            by _TSID_ &crossIDVar &timeIDvar;
20428 +        run;
20430 +        %do i = 1 %to &num_TSVar;
20431 +            %let i = &i;
20432 +            * transpose one cross-type time series data by TIMEID;
20433 +            proc transpose data=_emtstp_tmpDat out=_emtstp_td&i(drop=_name_) prefix=&timePrefix;
20434 +                by _TSID_ &crossIDVar;
20435 +                var &&&TSVar&i;
20436 +            run;
20437 +        %end;
20439 +        * stack all horizontal time series;
20440 +        data &outDS;
20441 +            format _TSID_ best12. _NAMEID_ $32. _ROLE_ $32.;
20442 +            length %do t=1 %to &num_T; &timePrefix.&t 8 %end;;
20443 +            set %do i=1 %to &num_TSVar; _emtstp_td&i(in=in&i) %end;;
20444 +            %do i=1 %to &num_TSVar;
20445 +                if in&i then do;
20446 +                    _NAMEID_ ="&&&TSVar&i";
20447 +                    _ROLE_   ="&&&TSRole&i";
20448 +                end;
20449 +            %end;
20450 +            label _tsid_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"   ;
20451 +            label _nameID_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_nameid, noquote))" ;
20452 +            label  role    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_varrole, noquote))";
20453 +        run;
20454 +    %end;
20455 +%end;
20456 +%else %do;
20458 +    proc sql noprint;
20459 +        select _NAMEID_ into :panelTSVar separated by ' ' from &inIDMap
20460 +            order by _NAMEID_
20461 +        ;
20462 +    quit;
20464 +    %if %upcase(&transposeBy) eq BYTSID %then %do;
20465 +        * transpose the panel-type time series data by TSID;
20466 +        proc sort data=&inDS out=_emtstp_tmpDat;
20467 +            by &timeIDvar;
20468 +        proc transpose data=_emtstp_tmpDat
20469 +            out=_emtstp_tmpDat2(keep=&timeIDvar _name_ col1 rename=(_name_=_ts_tmpname_ col1=_TSVALUE_));
20470 +            by &timeIDVar;
20471 +            var &panelTSVar;
20472 +        run;
20473 +        proc datasets lib=work nolist;
20474 +            modify _emtstp_tmpDat2;
20475 +            label _TSVALUE_= "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsvalue, noquote))";
20476 +            run; quit;
20477 +    %end;
20478 +    %else %do;
20479 +        * transpose the panel-type time series data by TIMEID;
20480 +        proc sort data=&inDS out=_emtstp_tmpDat;
20481 +            by &timeIDvar;
20482 +        data _emtstp_tmpDat;
20483 +            set _emtstp_tmpDat;
20484 +            _tmp_ind=_n_;
20485 +        proc transpose data=_emtstp_tmpDat prefix=&timePrefix
20486 +            out=_emtstp_tmpDat2(keep=_name_ &timePrefix: rename=(_name_=_ts_tmpname_));
20487 +            ID _tmp_ind;
20488 +            var &panelTSVar;
20489 +        run;
20490 +    %end;
20492 +      * merge ID maps to the transpose data set;
20493 +      proc sql noprint;
20494 +          create table &outDS(drop=_ts_tmpname_ _role_ _LABELID_ /*_TSID_*/ rename=(_NAMEID_=_TSNAME_)) as
20495 +              select a.*, b.* from &inIDMap as a, _emtstp_tmpDat2 as b
20496 +              where upcase(a._NAMEID_) eq upcase(b._ts_tmpname_)
20497 +          ;
20498 +      quit;
20500 +      * update the TS ID map;
20501 +      data &outIDMap;
20502 +          set &inIDMap;
20503 +      run;
20504 +%end;
20506 +proc datasets lib=work nolist;
20507 +    delete _emtstp:;
20508 +run; quit;
20510 +%mend EM_TS_Transpose;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMTSDM.TSSIM_REPORT.SOURCE.
20512 +/*----------------------------------------------------------------------------------+
20513 + |
20514 + |   Title :  TS Similarity Node
20515 + |
20516 + |
20517 + |   Support : Taiyeong Lee(Taiyeong.Lee@sas.com)
20518 + |
20519 + +-----------------------------------------------------------------------------------*/
20521 +%macro EM_TSSIM_REPORT;
20523 +%let _EXPORT_DATA  = ;
20524 +%if &EM_IMPORT_DATA ne  %then %do;
20525 +    %let _EXPORT_DATA   = &EM_EXPORT_TRAIN;
20526 +%end;
20527 +%else %if &EM_IMPORT_TRANSACTION ne  %then %do;
20528 +    %let _EXPORT_DATA  =  &EM_EXPORT_TRANSACTION;
20529 +%end;
20531 +%EM_GETNAME(KEY=OUT, TYPE=DATA);
20532 +%EM_GETNAME(KEY=OUTSUMMARY, TYPE=DATA);
20533 +%EM_GETNAME(KEY=TSIDMAP, TYPE=DATA);
20534 +%EM_GETNAME(KEY=OUT, TYPE=DATA);
20535 +%EM_GETNAME(KEY=TSMETA, TYPE=DATA);
20537 +%let viewnum=1;
20539 +%let _existcsid = N;
20540 +%if %EM_CROSSID ne %then  %let _existcsid = Y;
20542 +%let _clustering = &EM_PROPERTY_CLUSTERING ;
20543 +%if &_clustering eq  DEFAULT %then %do;
20544 +     %if  (&EM_NUM_INTERVAL_TARGET <1)  %then %let _clustering = Y ;
20545 +     %else %let _clustering = N;
20546 +%end;
20548 +%EM_REPORT(key=TSMETA, viewtype=DATA, block=Model, autodisplay=N, description=tsmetatable) ;
20550 +%if &_clustering eq Y %then %do;
20551 +    %EM_REPORT(key=OUTSEGMENT, view=&viewnum, viewtype=DATA, block=Model, Autodisplay=Y, description=tsidmaptable) ; /* may change the table name */
20552 +%end;
20553 +%else %do;
20554 +   %EM_REPORT(key=TSIDMAP, view=&viewnum, viewtype=DATA, block=Model, Autodisplay=Y, description=tsidmaptable) ;
20555 +%end;
20556 +%let viewnum=%eval(&viewnum+1);
20558 +data _tmp_viewnum;
20559 +    viewnum=input(symget('viewnum'),best12.);
20560 +run;
20562 +%EM_TSSIM_CreateDistMap(viewnumdat=_tmp_viewnum);
20564 +%if %EM_TARGET ne and &_clustering = N %then %do;
20566 +    %EM_TS_MakeSimBarChart(targetvar=%EM_TARGET, timeidvar=%EM_TIMEID, existcrossid=&_existcsid, viewnumdat=_tmp_viewnum);
20567 +    %EM_TS_MakeSimLinePlot(targetvar=%EM_TARGET, timeidvar=%EM_TIMEID, existcrossid=&_existcsid, viewnumdat=_tmp_viewnum);
20569 +%end;
20571 +%if &_clustering = Y %then %do;
20573 +    %EM_GETNAME(KEY=OUTTREE, TYPE=DATA);
20574 +    %EM_GETNAME(KEY=OUTNODE, TYPE=DATA);
20575 +    %EM_GETNAME(KEY=OUTLINK, TYPE=DATA);
20577 +    data &EM_USER_OUTTREE;
20578 +        /*        format _PARENT_ $200.;*/
20579 +        length _parent_ $ 200;
20580 +        set &EM_USER_OUTTREE;
20581 +        label _NAME_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clustername, noquote))";
20582 +        label _PARENT_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterparent, noquote))";
20583 +        label _NCL_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterncl, noquote))";
20584 +        label _FREQ_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterfreq, noquote))";
20585 +        label _HEIGHT_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterheight, noquote))";
20586 +        label _RMSSTD_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterrmsstd, noquote))";
20587 +        label _SPRSQ_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clustersprsq, noquote))";
20588 +        label _RSQ_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterrsq, noquote))";
20589 +        label _PSF_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterpsf, noquote))";
20590 +        label _PST2_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterpst2, noquote))";
20591 +        label _INPUT_   = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterinput, noquote))";
20592 +    run;
20594 +    data &EM_USER_OUTNODE;
20595 +        set &EM_USER_OUTNODE;
20596 +        label _NAME_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clustername, noquote))";
20597 +        label NodeType  = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusternode, noquote))";
20598 +        label LinkID    = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_clusterlinkid, noquote))";
20599 +    run;
20601 +    data _null_;
20602 +        set _tmp_viewnum;
20603 +        call symput('viewnum',viewnum);
20604 +    run;
20606 +    /*** adding variable labels starts ***/
20607 +    proc sql noprint;
20608 +        create table _tmptssim_OUTTREE as
20609 +            select a.*, b._LABELID_
20610 +            from &EM_USER_OUTTREE as a left join &EM_USER_TSIDMAP as b
20611 +                on strip(upcase(a._NAME_)) eq strip(upcase(b._NAMEID_))
20612 +        ;
20613 +        create table _tmptssim_OUTLINK as
20614 +            select a.*, b._LABELID_
20615 +            from &EM_USER_OUTLINK as a left join &EM_USER_TSIDMAP as b
20616 +                on strip(upcase(a._NAME_)) eq strip(upcase(b._NAMEID_))
20617 +        ;
20618 +        create table _tmptssim_OUTNODE as
20619 +            select a.*, b._LABELID_
20620 +            from &EM_USER_OUTNODE as a left join &EM_USER_TSIDMAP as b
20621 +                on strip(upcase(a._NAME_)) eq strip(upcase(b._NAMEID_))
20622 +        ;
20623 +    quit;
20625 +    data &EM_USER_OUTTREE;
20626 +        format _NAME_ $200.;
20627 +        set _tmptssim_OUTTREE;
20628 +        if _LABELID_ ne "" then _NAME_=_LABELID_;
20629 +    data &EM_USER_OUTLINK;
20630 +        format _NAME_ $200.;
20631 +        set _tmptssim_OUTLINK;
20632 +        if _LABELID_ ne "" then _NAME_=_LABELID_;
20633 +    data &EM_USER_OUTNODE;
20634 +        format _NAME_ $200.;
20635 +        set _tmptssim_OUTNODE;
20636 +        if _LABELID_ ne "" then _NAME_=_LABELID_;
20637 +    run;
20638 +    /*** adding variable labels ends ***/
20640 +    %EM_REPORT(KEY=OUTTREE, VIEWTYPE=DENDROGRAM,  autodisplay=Y, block =Plot, Name=_NAME_, view=&viewnum,
20641 +        PARENT=_PARENT_, HEIGHT=_HEIGHT_ , TipText = Variable, description=tsdendrogram );
20642 +    %let viewnum=%eval(&viewnum+1);
20644 +    %EM_REPORT(linkkey=OUTLINK, nodekey=OUTNODE, viewtype=Constellation,  autodisplay=Y, block=Plot, view=&viewnum,
20645 +        linkfrom=_NAME_, linkto=_PARENT_, linkid=LINKID, nodeid=_NAME_, nodeShape = NodeType, description=tsconstellplot);
20646 +    %let viewnum=%eval(&viewnum+1);
20648 +    proc delete data=_tmptssim_OUTTREE; run;
20649 +    proc delete data=_tmptssim_OUTNODE; run;
20650 +    proc delete data=_tmptssim_OUTLINK; run;
20652 +%end;
20654 +%mend EM_TSSIM_REPORT;
20657 +/*--------------------------------------------------------------------*/
20658 +/*------Create Distance (similarity) map -----------------------------*/
20659 +/*--------------------------------------------------------------------*/
20661 +%Macro EM_TSSIM_CreateDistMap(viewnumdat=);
20663 +%EM_GETNAME(KEY=OUTSUMMARY, TYPE=DATA);
20664 +%EM_GETNAME(KEY=MAPDS, TYPE=DATA);
20666 +/*** adding variable labels starts ***/
20667 +proc sql noprint;
20668 +    create table _tmp(drop=_STATUS_) as
20669 +        select a.*, b._LABELID_ as _LABELID1_
20670 +        from &EM_USER_OUTSUMMARY as a
20671 +            left join &EM_USER_TSIDMAP as b
20672 +            on strip(upcase(a._INPUT_)) eq strip(upcase(b._NAMEID_))
20673 +        order by a._INPUT_, b._LABELID_
20674 +    ;
20675 +quit;
20677 +proc transpose data =_tmp out= &EM_USER_MAPDS Prefix=TSID_;
20678 +    by _INPUT_ _LABELID1_;
20679 +run;
20681 +data &EM_USER_MAPDS;
20682 +    set &EM_USER_MAPDS;
20683 +    label
20684 +        _INPUT_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
20685 +        _NAME_      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_tsid, noquote))"
20686 +        TSID_1      = "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_distmeasure, noquote))"
20687 +        _LABELID1_  = "%sysfunc(sasmsg(sashelp.dmine, rpt_TimeSeries_desc, noquote))"
20688 +        _LABEL_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_TimeSeries_desc, noquote))"
20689 +    ;
20690 +    rename
20691 +        _INPUT_  = ROW_VAR
20692 +        _NAME_   = COL_VAR
20693 +        TSID_1   = SIMILARITY
20694 +        _LABEL_  = _LABELID2_
20695 +    ;
20696 +    if _LABEL_ eq " " then _LABEL_ = _NAME_;
20697 +run;
20698 + /*** adding variable labels ends ***/
20700 +proc sql noprint;
20701 +    select count(*) into :_ncell_mapds from &EM_USER_MAPDS;
20702 +quit;
20704 +data _null_;
20705 +    set &viewnumdat;
20706 +    call symput('viewnum',viewnum);
20707 +run;
20709 +%if &_ncell_mapds le 10000
20710 +%then %do;
20711 +    %EM_REPORT(key=MAPDS, viewtype=HISTOGRAM, VIEW=&viewnum, Y=_LABELID2_,X=_LABELID1_, FREQ=SIMILARITY,
20712 +        autodisplay=Y, block=Plot, description=tsdistancemap);
20713 +%end;
20715 +%if %EM_CROSSID ne  %then %do;
20716 +    %EM_REPORT(VIEW=&viewnum, FREQ=_ANYNUMERIC_ );
20717 +%end;
20719 +data &viewnumdat;
20720 +    set &viewnumdat;
20721 +    viewnum=input(symget('viewnum'),best12.)+1;
20722 +run;
20724 +%EM_TS_DELETE_DATA(lib=work, dsname=_tmp);
20726 +%Mend EM_TSSIM_CreateDistMap;
20729 +/*--------------------------------------------------------------------*/
20730 +/*------Create similarity measure bar chart --------------------------*/
20731 +/*--------------------------------------------------------------------*/
20733 +%Macro EM_TS_MakeSimBarChart(targetvar=, timeidvar=, existcrossid=, viewnumdat=);
20735 +%EM_GETNAME(KEY=MULTBARDS , TYPE=DATA);
20736 +data &EM_USER_MULTBARDS;
20737 +     set &EM_USER_OUTSUMMARY;
20738 +     drop _STATUS_;
20739 +     label _INPUT_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_input, noquote ))";
20740 +run;
20741 +/*-- when there are crossids ------------
20742 +%if %EM_CROSSID ne  %then %do;
20743 +         proc sort data = &EM_USER_TSIDMAP;
20744 +             by &_crossid;
20745 +        run;
20746 +        proc sort data = &EM_USER_OUTSUMMARY;
20747 +             by &_crossid;
20748 +        run;
20749 +        data &EM_USER_MULTBARDS;
20750 +             merge &EM_USER_TSIDMAP &EM_USER_OUTSUMMARY ;
20751 +             by &_crossid;
20752 +             drop _STATUS_;
20753 +        run;
20754 +%end;
20755 +%else %do;
20756 +      data &EM_USER_MULTBARDS;
20757 +          set &EM_USER_OUTSUMMARY;
20758 +         drop _STATUS_;
20759 +         label _INPUT_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_label_input, noquote ))";
20760 +      run;
20761 +%end;
20762 +-----------------------------------------*/
20764 +%let j=1;
20766 +data _null_;
20767 +    set &viewnumdat;
20768 +    call symput('viewnum',viewnum);
20769 +run;
20771 +%do %while(%scan(&targetvar, &j) ne );
20772 +    %let _tvar=%scan(&targetvar, &j);
20774 +    %EM_REGISTER(KEY=SIMVARDS&j, TYPE=DATA);
20775 +    %EM_GETNAME(KEY=SIMVARDS&j, TYPE=DATA);
20777 +    proc sort data=&EM_USER_MULTBARDS  out=&&&EM_USER_SIMVARDS&j;
20779 +        %if &existcrossid eq Y %then %do; key _TSID_/ASCENDING; %end;
20781 +        %if &EM_PROPERTY_SIMPLOTPREFERENCE eq MOST  %then %do;
20782 +            key &_tvar / ASCENDING;
20783 +         %end;
20784 +         %else %do;
20785 +            key &_tvar / DESCENDING;
20786 +         %end;
20787 +    run;
20789 +    data _tmptssim_simvards;
20790 +        set &&&EM_USER_SIMVARDS&j;
20791 +        %if &existcrossid eq Y %then %do;
20792 +            retain _R 1;
20793 +            by _TSID_;
20794 +            if first._TSID_ then _R=1;
20795 +            else _R=_R+1;
20796 +            if _R <= &EM_PROPERTY_NUMSIMPLOT then output;
20797 +            KEEP _TSID_ _INPUT_ _VARNAME_ &_tvar;
20798 +        %end;
20799 +        %else %do;
20800 +            if _N_ <= &EM_PROPERTY_NUMSIMPLOT then output;
20801 +            KEEP _INPUT_ &_tvar;
20802 +        %end;
20803 +    run;
20805 +    /*** adding variable labels starts ***/
20806 +    proc sql noprint;
20807 +        create table &&&EM_USER_SIMVARDS&j as
20808 +            select a.*, b._labelID_ label="%sysfunc(sasmsg(sashelp.dmine, rpt_TimeSeries_desc, noquote))" from
20809 +                _tmptssim_simvards as a left join &EM_USER_TSIDMAP as b
20810 +                on strip(upcase(a._INPUT_)) eq strip(upcase(b._NAMEID_))
20811 +            order by a._INPUT_
20812 +        ;
20813 +        select _labelID_ into :_tvarlabel from &EM_USER_TSIDMAP
20814 +            where strip(upcase(_NAMEID_)) eq "%upcase(&_tvar)"
20815 +        ;
20816 +    quit;
20817 +    proc delete data=_tmptssim_simvards; run;
20818 +    /*** adding variable labels ends ***/
20820 +    /*---------- will use this later ----------------------------+
20821 +    %if &existcrossid eq Y %then %do;
20822 +        proc sort data=&&&EM_USER_SIMVARDS&j(keep=_VARNAME_) out=_tmpds;
20823 +          by _VARNAME_;
20824 +        run;
20825 +        data _tmpds;
20826 +            set _tmpds;
20827 +            by _VARNAME_;
20828 +            if first._VARNAME_;
20829 +        run;
20830 +    %end;
20831 +    +------------------------------------------------------------*/
20833 +    %let siminputvsinput = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_siminputvsinput, noquote, &_tvarlabel));
20835 +    %let _autodisplayflag = Y;
20836 +    %if &j > 3 %then %let _autodisplayflag = N;
20838 +    %let viewnum=%eval(&viewnum+1);
20840 +    /* For fix S1035929 */
20841 +    proc sort data=&&&EM_USER_SIMVARDS&j;
20843 +        %if &existcrossid eq Y %then %do; key _TSID_/ASCENDING; %end;
20845 +        %if &EM_PROPERTY_SIMPLOTPREFERENCE eq MOST  %then %do;
20846 +            key &_tvar / ASCENDING;
20847 +         %end;
20848 +         %else %do;
20849 +            key &_tvar / DESCENDING;
20850 +         %end;
20851 +    run;
20854 +    %if &existcrossid eq Y %then  %do;
20855 +        %EM_REPORT(key=SIMVARDS&j, block=Plot, view=&viewnum, viewtype=BAR, X=_labelID_, Freq=&_tvar, byset=_TSID_,
20856 +               autodisplay = &_autodisplayflag, description = &siminputvsinput);
20857 +    %end;
20858 +    %else %do;
20859 +        %EM_REPORT(key=SIMVARDS&j, block=Plot, view=&viewnum, viewtype=BAR, X=_labelID_, Freq=&_tvar,
20860 +               autodisplay = &_autodisplayflag, description = &siminputvsinput);
20861 +    %end;
20862 +    %let j=%eval(&j+1);
20863 +%end;  /* end of %do %while(%scan(&_targetvar, &j) ne ); */
20865 +data &viewnumdat;
20866 +    set &viewnumdat;
20867 +    viewnum=input(symget('viewnum'),best12.)+1;
20868 +run;
20870 +%mend EM_TS_MakeSimBarChart;
20874 +/*--------------------------------------------------------------------*/
20875 +/*------Create time series plots based on similarity measure ---------*/
20876 +/*--------------------------------------------------------------------*/
20878 +%Macro EM_TS_MakeSimLinePlot(targetvar=, timeidvar=, existcrossid=, viewnumdat=);
20880 +%let j=1;
20882 +data _null_;
20883 +    set &viewnumdat;
20884 +    call symput('viewnum',viewnum);
20885 +run;
20887 +%do %while(%scan(&targetvar, &j) ne );
20888 +    %let _tvar=%scan(&targetvar, &j);
20889 +    %EM_GETNAME(KEY=SIMVARDS&j, TYPE=DATA);
20890 +    %EM_REGISTER(KEY=SIMPLOTDS&j, TYPE=DATA);
20891 +    %EM_GETNAME(KEY=SIMPLOTDS&j, TYPE=DATA);
20893 +    data &&&EM_USER_SIMPLOTDS&j;
20894 +        retain
20895 +         %let dsid=%sysfunc(open(&&&EM_USER_SIMVARDS&j));
20896 +         %if &dsid > 0 %then %do;
20897 +             %let vn_name =%sysfunc(varnum(&dsid, _INPUT_));
20898 +             %do %while(^ %sysfunc(fetch(&dsid)));
20899 +                 %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
20900 +                 &_varname
20901 +             %end;
20902 +             %let dsid = %sysfunc(close(&dsid));
20903 +         %end;
20904 +         ;
20906 +         set  &EM_USER_OUT ;
20907 +         keep &timeidVar  &_tvar
20908 +         %let dsid=%sysfunc(open(&&&EM_USER_SIMVARDS&j));
20909 +         %if &dsid > 0 %then %do;
20910 +             %let vn_name =%sysfunc(varnum(&dsid, _INPUT_));
20911 +             %do %while(^ %sysfunc(fetch(&dsid)));
20912 +                 %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
20913 +                 &_varname
20914 +             %end;
20915 +             %let dsid = %sysfunc(close(&dsid));
20916 +         %end;
20917 +    ;
20918 +    run;
20920 +    proc sql noprint;
20921 +        select _labelID_ into :_tvarlabel from &EM_USER_TSIDMAP
20922 +            where strip(upcase(_NAMEID_)) eq "%upcase(&_tvar)"
20923 +        ;
20924 +    quit;
20926 +    %let _autodisplayflag = Y;
20927 +    %if &j > 3 %then %let _autodisplayflag = N;
20929 +    %if &existcrossid eq Y %then  %do;
20931 +        %let dsid=%sysfunc(open(&&&EM_USER_SIMVARDS&j));
20932 +        %if &dsid > 0 %then %do;
20933 +            %let vn_name =%sysfunc(varnum(&dsid, _INPUT_));
20934 +            %let viewnum = %eval(1+&viewnum);
20935 +            %let nvar=1;
20936 +            %do %while(^ %sysfunc(fetch(&dsid)));
20937 +                 %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
20938 +                 %if &nvar = 1  %then %do;
20939 +                        %let targetvsinput = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_targetvsinput, noquote, &_tvarlabel ));
20940 +                        %EM_REPORT(Key=SIMPLOTDS&j, ViewType=LINEPLOT, VIEW=&viewnum, block=Plot, X=&timeidvar, Y=&_tvar, Y2=&_varname,
20941 +                        autodisplay=&_autodisplayflag, byset=_TSID_,  description=&targetvsinput);
20942 +                 %end;
20943 +                 %else
20944 +                        %EM_REPORT(VIEW=&viewnum, Y=&_tvar, Y2=&_varname);
20945 +                 %let nvar=%eval(&nvar+1);
20946 +            %end;
20947 +            %let dsid = %sysfunc(close(&dsid));
20948 +        %end;
20950 +    %end;
20951 +    %else %do;
20953 +        %let dsid=%sysfunc(open(&&&EM_USER_SIMVARDS&j));
20954 +        %if &dsid > 0 %then %do;
20955 +            %let vn_name =%sysfunc(varnum(&dsid, _INPUT_));
20956 +            %let viewnum = %eval(1+&viewnum);
20957 +            %let nvar=1;
20959 +            %do %while(^ %sysfunc(fetch(&dsid)));
20960 +                 %let _varname  = %sysfunc(getvarc(&dsid, &vn_name));
20961 +                 %if &nvar = 1  %then %do;
20962 +                        %let targetvsinput = %sysfunc(sasmsg(sashelp.dmine, rpt_tsdm_targetvsinput, noquote, &_tvarlabel ));
20963 +                        %EM_REPORT(Key=SIMPLOTDS&j, ViewType=LINEPLOT, VIEW=&viewnum, block=Plot, X=&timeidvar,
20964 +                                   Y2=&_tvar, Y=&_varname, autodisplay=&_autodisplayflag, description=&targetvsinput);
20965 +                 %end;
20966 +                 %else  %do;
20967 +                        %EM_REPORT(VIEW=&viewnum, Y=&_varname);
20968 +                 %end;
20969 +                 %let nvar=%eval(&nvar+1);
20970 +            %end;
20971 +            %let dsid = %sysfunc(close(&dsid));
20972 +        %end;
20974 +    %end;
20976 +    %let j=%eval(&j+1);
20978 +%end;  /* end of %do %while(%scan(&_targetvar, &j) ne ); */
20980 +data &viewnumdat;
20981 +    set &viewnumdat;
20982 +    viewnum=input(symget('viewnum'),best12.)+1;
20983 +run;
20985 +%mend EM_TS_MakeSimLinePlot;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: The data set WORK._TMP_VIEWNUM has 1 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
NOTE: Table WORK._TMP created, with 11 rows and 3 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 11 observations read from the data set WORK._TMP.
NOTE: The data set EMWS2.TSSIM_MAPDS has 11 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 11 observations read from the data set EMWS2.TSSIM_MAPDS.
NOTE: The data set EMWS2.TSSIM_MAPDS has 11 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      175:137
NOTE: There were 1 observations read from the data set WORK._TMP_VIEWNUM.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 397 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._TMP_VIEWNUM.
NOTE: The data set WORK._TMP_VIEWNUM has 1 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 11 observations read from the data set EMWS2.TSSIM_OUTSUMMARY.
NOTE: The data set EMWS2.TSSIM_MULTBARDS has 11 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      39:137
NOTE: There were 1 observations read from the data set WORK._TMP_VIEWNUM.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK.EM_USER_KEY has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 11 observations read from the data set EMWS2.TSSIM_MULTBARDS.
NOTE: The data set EMWS2.TSSIM_SIMVARDS1 has 11 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 11 observations read from the data set EMWS2.TSSIM_SIMVARDS1.
NOTE: The data set WORK._TMPTSSIM_SIMVARDS has 5 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Table EMWS2.TSSIM_SIMVARDS1 created, with 5 rows and 3 columns.
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMPTSSIM_SIMVARDS (memtype=DATA).
NOTE: PROCEDURE DELETE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 5 observations read from the data set EMWS2.TSSIM_SIMVARDS1.
NOTE: The data set EMWS2.TSSIM_SIMVARDS1 has 5 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 397 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 529 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._TMP_VIEWNUM.
NOTE: The data set WORK._TMP_VIEWNUM has 1 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      10:137
NOTE: There were 1 observations read from the data set WORK._TMP_VIEWNUM.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK.EM_USER_KEY.
NOTE: The data set WORK.EM_USER_KEY has 2 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1096 observations read from the data set EMWS2.TSSIM_OUT.
NOTE: The data set EMWS2.TSSIM_SIMPLOTDS1 has 1096 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 529 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 662 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 662 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 795 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 795 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 928 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 928 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1061 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 1061 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1194 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1 observations read from the data set WORK._TMP_VIEWNUM.
NOTE: The data set WORK._TMP_VIEWNUM has 1 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
20988
20989
20990  *------------------------------------------------------------*;
20991  * End REPORT: TSSIM;
20992  *------------------------------------------------------------*;
 
20993  /* Reset EM Options */
20994  options formchar="|----|+|---+=|-/\<>*";
20995  options nocenter ls=256 ps=10000;
20996  goptions reset=all device=GIF NODISPLAY;
 
20997  proc sort data=WORK.EM_USER_REPORT;
20998  by ID VIEW;
20999  run;
 
NOTE: There were 1194 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1194 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
